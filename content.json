{"meta":{"title":"DragonBaby308","subtitle":null,"description":null,"author":"DragonBaby308","url":""},"pages":[{"title":"client","date":"2018-12-20T15:13:35.000Z","updated":"2019-11-15T17:29:48.000Z","comments":false,"path":"client/index.html","permalink":"/client/index.html","excerpt":"","text":"直接下载 or 扫码下载：","keywords":"Android客户端"},{"title":"comment","date":"2018-12-20T15:13:48.000Z","updated":"2019-12-14T07:30:34.172Z","comments":true,"path":"comment/index.html","permalink":"/comment/index.html","excerpt":"","text":"斗酒百篇 叙别梦、扬州一觉。 【宋代】吴文英《夜游宫·人去西楼雁杳》","keywords":"留言板"},{"title":"lab","date":"2019-01-05T13:47:59.000Z","updated":"2019-11-15T17:29:48.000Z","comments":false,"path":"lab/index.html","permalink":"/lab/index.html","excerpt":"","text":"sakura主题balabala","keywords":"Lab实验室"},{"title":"donate","date":"2018-12-20T15:13:05.000Z","updated":"2019-12-14T07:43:41.644Z","comments":false,"path":"donate/index.html","permalink":"/donate/index.html","excerpt":"","text":"","keywords":"Nice~一百个飞机！"},{"title":"rss","date":"2018-12-20T15:09:03.000Z","updated":"2019-11-15T17:29:48.000Z","comments":true,"path":"rss/index.html","permalink":"/rss/index.html","excerpt":"","text":""},{"title":"music","date":"2018-12-20T15:14:28.000Z","updated":"2019-11-15T17:29:48.000Z","comments":false,"path":"music/index.html","permalink":"/music/index.html","excerpt":"","text":"","keywords":"喜欢的音乐"},{"title":"about","date":"2018-12-12T14:14:36.000Z","updated":"2019-12-13T16:49:59.273Z","comments":false,"path":"about/index.html","permalink":"/about/index.html","excerpt":"","text":"关于DragonBaby308的二三事 与&nbsp; DragonBaby308&nbsp; （ Hello World! ） 对话中... bot_ui_ini()","keywords":"关于"},{"title":"tags","date":"2018-12-12T14:14:16.000Z","updated":"2019-11-15T17:29:48.000Z","comments":true,"path":"tags/index.html","permalink":"/tags/index.html","excerpt":"","text":""},{"title":"theme-sakura","date":"2019-01-04T14:53:25.000Z","updated":"2019-11-15T17:29:48.000Z","comments":false,"path":"theme-sakura/index.html","permalink":"/theme-sakura/index.html","excerpt":"","text":"Hexo主题Sakura修改自WordPress主题Sakura，感谢原作者Mashiro","keywords":"Hexo 主题 Sakura 🌸"},{"title":"links","date":"2018-12-19T15:11:06.000Z","updated":"2019-12-13T15:49:24.826Z","comments":true,"path":"links/index.html","permalink":"/links/index.html","excerpt":"","text":"","keywords":"友人帐"},{"title":"video","date":"2018-12-20T15:14:38.000Z","updated":"2019-11-15T17:29:48.000Z","comments":false,"path":"video/index.html","permalink":"/video/index.html","excerpt":"","text":"var videos = [ { img: 'https://lain.bgm.tv/pic/cover/l/0e/1e/218971_2y351.jpg', title: '朝花夕誓——于离别之朝束起约定之花', status: '已追完', progress: 100, jp: 'さよならの朝に約束の花をかざろう', time: '放送时间: 2018-02-24 SUN.', desc: ' 住在远离尘嚣的土地，一边将每天的事情编织成名为希比欧的布，一边静静生活的伊欧夫人民。在15岁左右外表就停止成长，拥有数百年寿命的他们，被称为“离别的一族”，并被视为活着的传说。没有双亲的伊欧夫少女玛奇亚，过着被伙伴包围的平稳日子，却总感觉“孤身一人”。他们的这种日常，一瞬间就崩溃消失。追求伊欧夫的长寿之血，梅萨蒂军乘坐着名为雷纳特的古代兽发动了进攻。在绝望与混乱之中，伊欧夫的第一美女蕾莉亚被梅萨蒂带走，而玛奇亚暗恋的少年克里姆也失踪了。玛奇亚虽然总算逃脱了，却失去了伙伴和归去之地……。' }, { img : 'https://lain.bgm.tv/pic/cover/l/0e/1e/218971_2y351.jpg', title: '朝花夕誓——于离别之朝束起约定之花', status: '已追完', progress: 100, jp: 'さよならの朝に約束の花をかざろう', time: '2018-02-24 SUN.', desc: ' 住在远离尘嚣的土地，一边将每天的事情编织成名为希比欧的布，一边静静生活的伊欧夫人民。在15岁左右外表就停止成长，拥有数百年寿命的他们，被称为“离别的一族”，并被视为活着的传说。没有双亲的伊欧夫少女玛奇亚，过着被伙伴包围的平稳日子，却总感觉“孤身一人”。他们的这种日常，一瞬间就崩溃消失。追求伊欧夫的长寿之血，梅萨蒂军乘坐着名为雷纳特的古代兽发动了进攻。在绝望与混乱之中，伊欧夫的第一美女蕾莉亚被梅萨蒂带走，而玛奇亚暗恋的少年克里姆也失踪了。玛奇亚虽然总算逃脱了，却失去了伙伴和归去之地……。' } ] .should-ellipsis{overflow:hidden;text-overflow:ellipsis;white-space:nowrap;width:95%;}.should-ellipsis-full{overflow:hidden;text-overflow:ellipsis;white-space:nowrap;width:100%;}.should-ellipsis i{position:absolute;right:24px;}.grey-text{color:#9e9e9e !important}.grey-text.text-darken-4{color:#212121 !important}html{line-height:1.15;-ms-text-size-adjust:100%;-webkit-text-size-adjust:100%}body{margin:0}img{border-style:none}progress{display:inline-block;vertical-align:baseline}::-webkit-file-upload-button{-webkit-appearance:button;font:inherit}html{-webkit-box-sizing:border-box;box-sizing:border-box}*,*:before,*:after{-webkit-box-sizing:inherit;box-sizing:inherit}ul:not(.browser-default){padding-left:0;list-style-type:none}ul:not(.browser-default)>li{list-style-type:none}.card{-webkit-box-shadow:0 2px 2px 0 rgba(0,0,0,0.14),0 3px 1px -2px rgba(0,0,0,0.12),0 1px 5px 0 rgba(0,0,0,0.2);box-shadow:0 2px 2px 0 rgba(0,0,0,0.14),0 3px 1px -2px rgba(0,0,0,0.12),0 1px 5px 0 rgba(0,0,0,0.2)}.hoverable{-webkit-transition:-webkit-box-shadow .25s;transition:-webkit-box-shadow .25s;transition:box-shadow .25s;transition:box-shadow .25s,-webkit-box-shadow .25s}.hoverable:hover{-webkit-box-shadow:0 8px 17px 0 rgba(0,0,0,0.2),0 6px 20px 0 rgba(0,0,0,0.19);box-shadow:0 8px 17px 0 rgba(0,0,0,0.2),0 6px 20px 0 rgba(0,0,0,0.19)}i{line-height:inherit}i.right{float:right;margin-left:15px}.bangumi .right{float:right !important}.material-icons{text-rendering:optimizeLegibility;-webkit-font-feature-settings:'liga';-moz-font-feature-settings:'liga';font-feature-settings:'liga'}.row{margin-left:auto;margin-right:auto;margin-bottom:20px}.row:after{content:\"\";display:table;clear:both}.row .col{float:left;-webkit-box-sizing:border-box;box-sizing:border-box;padding:0 .75rem;min-height:1px}.row .col.s12{width:100%;margin-left:auto;left:auto;right:auto}@media only screen and (min-width:601px){.row .col.m6{width:50%;margin-left:auto;left:auto;right:auto}}html{line-height:1.5;font-family:-apple-system,BlinkMacSystemFont,\"Segoe UI\",Roboto,Oxygen-Sans,Ubuntu,Cantarell,\"Helvetica Neue\",sans-serif;font-weight:normal;color:rgba(0,0,0,0.87)}@media only screen and (min-width:0){html{font-size:14px}}@media only screen and (min-width:992px){html{font-size:14.5px}}@media only screen and (min-width:1200px){html{font-size:15px}}.card{position:relative;margin:.5rem 0 1rem 0;background-color:#fff;-webkit-transition:-webkit-box-shadow .25s;transition:-webkit-box-shadow .25s;transition:box-shadow .25s;transition:box-shadow .25s,-webkit-box-shadow .25s;border-radius:2px}.card .card-title{font-size:24px;font-weight:300}.card .card-title.activator{cursor:pointer}.card .card-image{position:relative}.card .card-image img{display:block;border-radius:2px 2px 0 0;position:relative;left:0;right:0;top:0;bottom:0;width:100%}.card .card-content{padding:24px;border-radius:0 0 2px 2px}.card .card-content p{margin:0}.card .card-content .card-title{display:block;line-height:32px;margin-bottom:8px}.card .card-content .card-title i{line-height:32px}.card .card-reveal{padding:24px;position:absolute;background-color:#fff;width:100%;overflow-y:auto;left:0;top:100%;height:100%;z-index:3;display:none}.card .card-reveal .card-title{cursor:pointer;display:block}.waves-effect{position:relative;cursor:pointer;display:inline-block;overflow:hidden;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;-webkit-tap-highlight-color:transparent;vertical-align:middle;z-index:1;-webkit-transition:.3s ease-out;transition:.3s ease-out}.waves-effect img{position:relative;z-index:-1}.waves-block{display:block}::-webkit-input-placeholder{color:#d1d1d1}::-moz-placeholder{color:#d1d1d1}:-ms-input-placeholder{color:#d1d1d1}::-ms-input-placeholder{color:#d1d1d1}[type=\"radio\"]:not(:checked){position:absolute;opacity:0;pointer-events:none}[type=\"radio\"]:not(:checked)+span{position:relative;padding-left:35px;cursor:pointer;display:inline-block;height:25px;line-height:25px;font-size:1rem;-webkit-transition:.28s ease;transition:.28s ease;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none}[type=\"radio\"]:not(:checked)+span:before,[type=\"radio\"]:not(:checked)+span:after{border-radius:50%}[type=\"radio\"]:not(:checked)+span:before,[type=\"radio\"]:not(:checked)+span:after{border:2px solid #5a5a5a}[type=\"radio\"]:not(:checked)+span:after{-webkit-transform:scale(0);transform:scale(0)}[type=\"checkbox\"]:not(:checked){position:absolute;opacity:0;pointer-events:none}[type=\"checkbox\"]:not(:checked):disabled+span:not(.lever):before{border:none;background-color:rgba(0,0,0,0.42)}[type=\"checkbox\"].filled-in:not(:checked)+span:not(.lever):before{width:0;height:0;border:3px solid transparent;left:6px;top:10px;-webkit-transform:rotateZ(37deg);transform:rotateZ(37deg);-webkit-transform-origin:100% 100%;transform-origin:100% 100%}[type=\"checkbox\"].filled-in:not(:checked)+span:not(.lever):after{height:20px;width:20px;background-color:transparent;border:2px solid #5a5a5a;top:0px;z-index:0}input[type=checkbox]:not(:disabled) ~ .lever:active:before,input[type=checkbox]:not(:disabled).tabbed:focus ~ .lever::before{-webkit-transform:scale(2.4);transform:scale(2.4);background-color:rgba(0,0,0,0.08)}input[type=range].focused:focus:not(.active)::-webkit-slider-thumb{-webkit-box-shadow:0 0 0 10px rgba(38,166,154,0.26);box-shadow:0 0 0 10px rgba(38,166,154,0.26)}input[type=range].focused:focus:not(.active)::-moz-range-thumb{box-shadow:0 0 0 10px rgba(38,166,154,0.26)}input[type=range].focused:focus:not(.active)::-ms-thumb{box-shadow:0 0 0 10px rgba(38,166,154,0.26)} 番组计划 这里将是永远的回忆 window.onload = function(){ videos.forEach(function(video, i){ $('#rootRow').append(` ${video.title} ${video.jp} ${video.status} ${video.title} ${video.jp} 放送时间: ${video.time} ${video.desc} ${video.status} `) }) }","keywords":"B站"},{"title":"bangumi","date":"2019-02-10T13:32:48.000Z","updated":"2019-12-14T03:00:52.360Z","comments":false,"path":"bangumi/index.html","permalink":"/bangumi/index.html","excerpt":"","text":"","keywords":null}],"posts":[{"title":"《三只小猪》初稿","slug":"3pigs","date":"2019-12-22T09:48:48.000Z","updated":"2019-12-25T11:06:15.235Z","comments":true,"path":"3pigs/","link":"","permalink":"/3pigs/","excerpt":"","text":"《三只小猪》 观《Revolting Rhymes》有感，蹒跚学步之作。 一、Gambino&emsp; &emsp;贫民窟的猪妈妈是战争遗孀。丈夫牺牲在战场上后，她始终没有改嫁，独自抚养着三只小猪。倒也不是她爱那个短命的死鬼爱得多么深沉，只是因为她长得很丑 —— 膀大腰圆，铜铃大眼，又尖又长的獠牙戳破了上嘴唇，闪烁着寒芒。即便是镇子上最爱多管闲事的老太太，也不愿与她说亲，她们在背地里谈论着她：“天哪！你知道镇上的瘦狼先生吗？我打赌三个它都没有猪太太壮！那副尊容，上帝创造她的时候保管是偷工减料了，还带着三个小拖油瓶，没有谁会瞎了心找她结婚呀！”&emsp; &emsp;所以猪妈妈在乱世中没了依靠，万幸的是她会针线活，还有一膀子力气。白天她在码头当卸货工，她不仅干起活来狠，打起架来也比所有人狠，码头上的苦工们都不敢和她抢活。到了晚上，猪妈妈还要为城堡里的阔太太织些花边补贴家用。猪妈妈没日没夜地工作，忘了自己是男人还是女人，即便如此，她还是只能领到微薄的薪水，她节衣缩食，过着食不果腹、衣不蔽体的生活。有时候深夜，她停下针线歇一口气的时候，看着睡得香甜的三只小猪，听着它们的呼噜声和饿肚子的咕噜声，也会忍不住默默流泪。&emsp; &emsp;三只小猪就这么野蛮生长起来，它们调皮捣蛋，总是和其他孩子打架，但是它们兄弟三人非常友爱。吃不饱、穿不暖，也没有受过教育，它们当然也不会有自己的名字，猪妈妈就叫它们“老大”、“老二”、“老三”，有的时候更简单，就叫“喂”或者“那谁”，生气的时候也叫它们“小畜生”。&emsp; &emsp;如果你不能像动物一样根据气味来区分三只小猪，当然也不妨叫它们日后搅动风云时的名字 —— 老大叫做Gambino，继承了母亲的肥头大耳，它逞强斗狠，污渍和血迹让它总是脏兮兮的，散发着一股臭水沟混合着铁锈的味道；老二叫做Yi，在这一家子里面它绝对是一个另类，不像它的其他家人，Yi生得俊俏，刘海在额前俏皮地梳成个旋儿，偷来的古龙水让它香喷喷的；老三Tony是三兄弟中最寡言少语的一位，它的味道就像是暴风雨来临前的空气，沉闷而压抑。&emsp; &emsp;经年累月的劳作终于让猪妈妈病倒了，它把三只小猪叫到床边说：“好啦，你们这三个小畜生可算是把老娘的血榨干啦！从今往后你们自己出去闯荡吧，往西去，去伦敦做一番事业，上帝保佑别让你们穷一辈子。”于是三兄弟商量一番，老二、老三留下来照顾病榻上的猪妈妈，老大穿上家里唯一体面的衣服，先动身前往伦敦，它打定主意一定要赚大钱，让家人过上富足的生活。&emsp; &emsp;老大一路向西，沿途它乞讨过，也打过短工，但更多的时候都是饿着肚子，餐风饮雪，终于它远远地能看到笼罩在工业黑烟下的伦敦城了，林立的高楼线条冷峻，屹立在那里就像一个铁石心肠的巨人，在老大的睡梦里，伦敦城却却仿佛会活过来，变成张牙舞爪的野兽朝着它扑来，机械和蒸汽的轰鸣就是它的吼声，黑黢黢的大口将它一口吞噬，它迷失在那张巨口里，虽说总是在睡梦中被惊醒，但是转醒后远望着伦敦城，老大总不自觉咧嘴笑起来 —— 那时它便发下宏愿，以后出人头地了，也要像现在这样，嗤笑以前穷困的生活。&emsp; &emsp;终于它进到了伦敦城中 ——&emsp; &emsp;高楼。比高楼更高的烟囱。白烟黑烟混杂着冲天而起，在天空中形成一团巨大的乌云，云脚低垂，化成一双雾气大手，死死捏住了伦敦城的咽喉。它满满吸入一口湿润的空气，木柴和燃油燃烧的味道猛扑它的呼吸道，在肺内燃烧起来，烧得它面红耳赤、脚步虚浮，蒸汽机的轰鸣、金属撞击时的当啷声、吆喝声、叫卖声、男人的咒骂咆哮、女人刺耳的娇笑织在一起，从它的耳朵钻入，撩拨着它的心弦。它只顾着仰头注视那些林林总总的高楼，它能感觉那些高楼也在审视着它，跌跌撞撞地向前走，留下一路的惊叫和咒骂，汽车扯着破喇叭飞驰而过，差点撞到它身上，它急忙躲开，惊惧地回头看着那不可名状的机器，司机也回头挥舞着拳头怒斥道：“聋了吗？你这个土包子！”骂声被扯成了一条细线，在空中曳荡，又被各式各样的杂音给切成了段，传到小猪耳朵里时早已听不清了，它还以为司机在和它打招呼呢，也傻笑着和司机挥手告别。这一切都被路旁两个善于察言观色的掮客看在眼里，它们相视一笑，猛嘬一口手里的烟卷后，用脚碾灭了，双手揣在兜里，踢踏着朝老大走来。&emsp; &emsp;它们一左一右搀住了小猪，左边那头肥狼笑道：“早安，我的朋友，天气不错不是吗？”&emsp; &emsp;小猪看了眼不见天日的天空，迟疑地说道：“不错……吧？”&emsp; &emsp;右手边的独眼狼舔了下嘴唇，恶狠狠说道：“你这肮脏的丑东西，这么神色匆匆是急着干嘛去呀？城北的培根铺吗？”&emsp; &emsp;肥狼急忙拉了同伴一下，赔笑道：“亲爱的朋友，您一定是新到伦敦城的吧？为什么不陪我们到旁边的酒吧喝两杯，让我们兄弟给您介绍介绍伦敦城呢？我们兄弟俩能为您介绍份工作，您要是厌倦了工作，我们还知道不少发大财的路子呢！”&emsp; &emsp;小猪眼睛亮了，急忙问道：“真的吗——”，它摸了下兜里仅剩的一个钱币，亮晶晶的眸子又熄灭了，“谢谢你们，两位好心人，我还是不喝了。”&emsp; &emsp;肥狼察言观色，急忙道：“别呀！您远来是客，我们是慈悲心肠，怕您一个人在城里吃亏，跟我们来吧，我们请您喝两杯。不用您掏腰包，来吧！”小猪半推半就，跟着兄弟俩进了路边的一家小酒馆。&emsp; &emsp;清早的酒馆很冷清，除了酒香外，还有一股烤红薯的香味 —— 这倒不常见，肥狼打量了一下四周 —— 靠门几桌睡着几个宿醉的酒鬼，嘴里嘟囔着谁也听不懂的梦呓；吧台边站着一个长啤酒肚的中年人，神色里带着急躁和满足，一看就知道是酒虫上脑的小工，喝完这杯他就要去上工了；最里头靠墙坐着一头干瘦的狐狸，毛发灰白驳杂，两只爪子倒是漆黑得像夜幕，椅子旁摆着一个黑漆漆的古怪仪器，桌上放着的烤红薯还热气腾腾，原来是街角卖烤红薯的狐狸老头，它两指夹着一个高脚杯，双眼乜斜着，也不知是在品酒还是打盹。&emsp; &emsp;兄弟俩夹着小猪来到吧台坐下，不多时三大杯啤酒就端了上来。肥狼嘴上不停，东家长西家短，好像伦敦城往来几百年的事情都一清二楚，小猪不时配合着发出几声慨叹或惊呼，心里佩服极了。独眼狼沉默寡言，自顾自地喝着酒，只是时不时舔着嘴唇看着小猪，脸上挂着莫名奇妙的诡异笑容。肥狼不停劝酒，小猪头一次喝酒，再加上腹内无食，推杯换盏下，只觉得恍恍惚惚，如坠五里雾中，它笑道：“这就是酒吗？真、真是个好东西！”&emsp; &emsp;两兄弟看它喝得差不多了，交换了下眼神，突然一左一右勾住了它的脖子。肥狼道：“亲爱的朋友，你的酒量可真差，趁着你还清醒，先来结账吧。”&emsp; &emsp;小猪道：“结什么账？你们不是说要请我的吗？”&emsp; &emsp;肥狼在它眼前做了个数钱的动作，笑道：“没错，我的朋友，酒钱当然是我们兄弟来付，可是情报费呢？您听了我们兄弟俩的独家情报，可不能不付费呀！这样以后还有谁愿意苦哈哈地去打听情报呢，您说是吗？”&emsp; &emsp;小猪心里明白自己是被勒索了，酒醒了大半，挣扎着要站起身来，道：“是你自己要说的，我不是非听不可！我可没有钱给你们。”&emsp; &emsp;独眼狼听了，照着小猪面门就给了它一拳，道：“那可由不得你！”&emsp; &emsp;吧台上的老板适时地敲了下桌子，挽起袖子，露出手臂上的大灰狼纹身，恶狠狠道：“你们两个杂种，打听一下这是谁的产业，刮花了桌椅，Charles先生要你们的命！”&emsp; &emsp;肥狼变了脸色，陪笑道：“借我们10个胆也不敢在黑手党的酒馆里闹事呀！兄弟，把这个欠债不还的小混蛋拖到旁边的巷子里去！”小猪猛烈地挣扎起来，但到底醉醺醺的没了气力，两兄弟掀起它的外套盖在脸上，劈头盖脸一通乱拳，小猪渐渐的没了声响，两兄弟摸走了它身上唯一一个钱币，扒走了它的衣物，把它丢在了巷子里。&emsp; &emsp;小猪昏昏沉沉睡到第二天晌午，醒来后它又冷又饿，全身骨头缝都犯疼，搜肠刮肚了一番，终于想起了昨天的经理。它不由得怒火中烧，双眼从被打肿的眼眶中射出愤恨的目光，摸着墙，踉踉跄跄地又来到了昨天的酒馆门口。中午的酒馆比清晨喧闹很多，上午下工的工人们痛饮着啤酒，笑声和骂声在碰杯声的间隙中传来。卖红薯的老头还是一如既往地坐在角落里，品着一杯猩红的葡萄酒，脚边是那个奇怪的机器。它的仇人 —— 肥狼和独眼狼仍坐在吧台上，狡诈的目光在人群中逡巡着，寻找着下一个倒霉鬼。&emsp; &emsp;小猪握紧了拳，冲上前去，眼尖的肥狼已经看见了它，站起身来道：“这不是我亲爱的小猪朋友吗？今天也要听听伦敦城的新闻吗？”&emsp; &emsp;独眼狼恶狠狠说道：“这个穷鬼，浑身上下就一个钱币。它的衣服又脏又臭，就是当抹布也没人买。要不是你拦着我，昨天就应该杀了它，把肉卖到培根铺的。”&emsp; &emsp;肥狼笑呵呵地说道：“我的兄弟，我们可是好心肠的正经买卖人，一手交钱，一手交货，怎么能害人性命呢？”&emsp; &emsp;小猪听了，无名怒火从蹄心直冲天灵盖，浑身颤抖，骂道：“你们这两个坏蛋，够胆就来试试看吧！”&emsp; &emsp;独眼狼见小猪战栗，以为它在害怕，舔着嘴唇，慢悠悠地走了过来，却不料小猪先它一步动手，一巴掌甩在它脸上，然后一脚踹在它肚子上，力道极大，根本不像一个饿了几顿的人。独眼狼被踹飞出去，一连撞翻好张桌子，杯子、瓶子、罐子劈里啪啦地碎了一地，各路酒徒都骂骂咧咧地站起身来，要找小猪算账。小猪坦然不惧，从小打架的它练出一身好本领，拳脚并用，舞得虎虎生风，身上虽然挨上些拳脚，但它都会加倍奉还，几次三番下来，它也动了肝火，不躲不避，笃定一命换一命的觉悟，下手更不留情，揍趴下了好几人。小猪圆睁怒目，冲着四周咆哮起来，那些酒徒哪里见过这么不要命的，气势上不由得矮了一头，都踌躇着不敢上前来了。&emsp; &emsp;突然，小猪身后的肥狼死死锁住了它的脖颈，独眼狼则抽出匕首朝小猪心口扎来，小猪连忙右肘往后一捣，然后一个过肩摔将肥狼摔在地板上，但是独眼狼的匕首也到了，小猪一矮身，匕首扎在了肩胛骨上，小猪痛得大叫，但还是用锁骨卡住了匕首，不让独眼狼抽出去，然后一把抓住独眼狼持匕首的右手，狠狠一手刀就打脱了臼，然后再扯过痛呼着的独眼狼的左手，按在吧台上，咬牙从肩头拔出了匕首，将它的左手钉在了吧台上。独眼狼眼前一黑，滑倒下去，又扯痛了钉住的左手清醒过来，上不来也下不去，身体以一种滑稽的角度蜷在一起。&emsp; &emsp;小猪抓起了肥狼的衣领，吼道：“把我的东西还给我！”&emsp; &emsp;肥狼冷汗直流，两股战战，掏出一个钱币高举着，道：“还给您！还给您！衣服已经卖掉了，您放过我，我去为您赎回来！”&emsp; &emsp;小猪夺过钱币，心想：“这人心黑极了，要留心它骗我。”，咂摸着肥狼的话，突然心里一闪念，开窍了似的，道：“还不快滚！记住了，你想要赎回你兄弟，就给我10个 —— 不！100个钱币！”肥狼急忙答应下来，点头哈腰地夺门而逃。&emsp; &emsp;酒吧老板突然掏出枪指着小猪，开腔道：“小子真是不怕死，竟然敢在Charles先生的地盘闹事！”&emsp; &emsp;一只漆黑的爪子搭在了老板的枪上，道：“你还是好好担心自己吧，Gambino。连一家酒馆都管不住，Charles一生气，你的干部也做到头了。”&emsp; &emsp;酒馆老板恼羞成怒，看了一眼爪子的主人 —— 卖红薯的老狐狸不知什么时候已经走到了台前，它单手擎着烤红薯的机器。老板骂道：“臭卖红薯的也敢来趟浑水？不想死就让开！”狐狸听了也不生气，解开了自己的长风衣披在小猪身上，问道：“孩子，你知道那个胖子不会再回来了吧？”小猪道：“它的同伴还在我手里，它会回来的。”老狐狸笑弯了腰，道：“那你就太高估这些上不了台面的小混混了，伦敦城可没教会它们什么是义气。”小猪狠狠道：“没有关系，只要它还在伦敦城，我就总能找到它，到时我就让它知道骗我的代价！”老狐狸哈哈大笑，问小猪道：“亲爱的孩子，你叫什么？”小猪道：“老先生，我也想告诉您，可是我没有名字。”老狐狸脸上的微笑更浓了，道：“那么从今天开始，你就叫Gambino吧！”言毕，手里的机器突然发出一声震耳欲聋的轰鸣，火光迸射，将半边柜台连带着独眼狼和那个叫Gambino的酒馆老板一起轰成了齑粉，“孩子，从今天开始你就是黑手党的新干部！跟我来吧，我会教会你怎么经营没本钱的买卖。”&emsp; &emsp;等到黑手党的Boss —— 大灰狼Charles带着喽罗们来到时，酒馆内已经人去楼空了，仅剩的半边吧台上只留下了一个黑手印，旁边写道：“Charles，我为你找到了接班人。”&emsp; &emsp;Charles喃喃道：“Mike教父，您还真是清闲不下来。” 二、Yi&emsp; &emsp;猪妈妈熬过了冬天，却没来得及享受春天，终于还是溘然辞世了，老三留下来料理后事，老二独自动身前往伦敦城。它天生风流倜傥，明亮的眼眸就像是夜空中最亮的星，不论是谁，见了那双脉脉含情的眸子，都会不自觉地轻呼一声“噫！”，然后对它心生好感。久而久之，它就开始这么自我介绍：“小生叫Yi，敢问姑娘芳名？”。它是天生的好演员，谈笑风生丝毫不犯怵，也是天底下一等一的绝情人儿，一路上，它处处留情，却总是能及时抽身，躲过了各路父亲和丈夫的追杀，惹得各路小姐和太太空劳牵挂。靠着情人们的周济，Yi走走停停来到了伦敦，此时它的打扮俨然就是一个翩翩贵公子了，那份风姿气度，即便是专门上过贵族学校的少爷也拍马难及。&emsp; &emsp;进了伦敦城，它不动声色地观察着城里人的一举一动，没有一丝一毫行差走错，任谁也看不出来它是个乡下来的小子。它走得口渴，就走进了一家酒馆 —— 正好就是它的哥哥待过的那家，这时这家酒馆已经是Gambino的产业了。&emsp; &emsp;酒馆老板见它打扮体面，气度不凡，客气道：“需要什么？这位新面孔的老爷。”&emsp; &emsp;Yi随手甩出两枚金币，道：“来一杯你们店里最好的龙舌兰酒，柠檬片要最新鲜的。顺便说说吧，伦敦城最近有什么新闻？”&emsp; &emsp;老板见它出手阔绰，自然不敢怠慢，款款道来：“最近城里可不怎么太平，四处都在打打杀杀，这些日子黑手党一直在肃清其他势力呢！去年冬天黑手党新来了一员叫Gambino的干部，大家都管它叫‘狂笑的恶魔’。不过您在我们酒馆保管高枕无忧，您知道我们酒馆现在幕后老板是谁吗？”老板狡黠地眨着眼。Yi微微一笑，顺着老板的话问道：“是谁呢？”老板哈哈大笑起来，不知道的还以为它是奸计得逞了呢，道：“就是Gambino先生！它可是现任老板Charles先生的教父老Mike亲自挑选的接班人，有万夫不当之勇，冲锋陷阵起来身先士卒，不仅拳脚功夫了得，还从老Mike那儿继承了重火器‘烤红薯机’，现在黑手党的地盘越来越大，全是拜它所赐！”说着它装模做样地四下打量了一番，压低了声音，“我听说现在组织内部越来越多狼族都支持它，大家都说它迟早是下一任当家的，虽然说是一头猪——”&emsp; &emsp;Yi急忙打断了老板：“一头什么？”&emsp; &emsp;老板正要回答，忽听得门外咚咚作响，老板道：“您听，这就是那‘烤红薯机’的声音，这是Gambino先生正要偷袭血骷髅帮呢！”Yi起身就往外走，心想哪里有这么明目张胆偷袭的？老板叫道：“先生，您不喝了吗？您的金币忘拿了！”Yi摆摆手，道：“算给你的小费！”&emsp; &emsp;Yi出了酒馆，直奔声源，远远地就看到了Gambino那魁梧的身材，它扛着一个古怪笨重的重炮，走起路来尘土飞扬，脚步咚咚作响，Yi大叫一声“哥哥”，分奔上前。Gambino远远便认出了自己的弟弟，急忙也迎了上来，兄弟俩久别重逢，喜不自胜，互道寒暄，Gambino从口袋掏出钥匙给Yi，道：“弟弟，你先去我贝克街221B号的公寓歇会儿，我出完这次任务就来！”Yi接过钥匙，担忧道：“哥哥，你们就这么明目张胆地去偷袭吗？”Gambino浑不在意，哈哈笑道：“怕啥！你且放宽心，等我凯旋！”&emsp; &emsp;于是Yi来到公寓前，开锁推门进来，只见大厅内鳄鱼小姐正在拖地，它围着围裙，鳞片光滑锃亮，牙尖嘴利，尾巴粗大有力，Yi这么多年万花丛中过，从来都是片叶不沾身，没有动过真心，此刻脑中却闪过一个词 —— “一见钟情”，不由得愣住了。鳄鱼小姐看着它，也迷失在Yi深邃的眸子里，好容易它才回过神来，眨巴着眼，问道：“先生您好，您找谁？”Yi此刻终于从幻想的漩涡中脱身，羞愧地说道：“您好，美丽的小姐，小生是Gambino的弟弟，叫做Yi，请问您是？”鳄鱼小姐掩嘴笑道：“您好，我是它的室友，常听它说起你们兄弟俩。”&emsp; &emsp;鳄鱼小姐羞答答走上前来撑住门，道：“我光顾着和您说话了，真是个笨蛋。您快进来，我给您倒杯咖啡吧。”&emsp; &emsp;Yi拉住了鳄鱼小姐的手，看着它的眸子，道：“您要是不嫌弃的话，叫我Yi就可以了。”&emsp; &emsp;Yi的眸子很深，仿佛能装下无垠星河，鳄鱼小姐不由自主地深陷了进去，它心想：“它的手好暖，就像唤醒冬眠的春阳！”终于，有一道电流顺着两人牵着的手淌过，鳄鱼小姐鳞片翕动，苏醒过来，呢喃道：“好的，Yi。”&emsp; &emsp;一夜无话。Yi的睡眠很浅，这些日子来窃玉偷香的生活让它不敢安眠，生怕被堵在卧室里，临近破晓的时候，Yi隐约听到楼下有人声，它惊醒过来，将床边的一桶冷水泼在了铺盖上，拉过被子盖住，然后蹑手蹑脚地离开了房间。&emsp; &emsp;门被粗暴地踹开了，鳄鱼小姐惊慌失措地看着楼下荷枪实弹的黑帮成员，强装镇定地问道：“你们想要干什么？”&emsp; &emsp;大灰狼Charles道：“Gambino背叛了黑手党，我们死了几十个好兄弟，你是它的什么人？”鳄鱼小姐道：“Gambino？就是住隔壁房间的小猪吗？”Charles道：“看来你是它的室友，我的手下告诉我今天Gambino的弟弟来找了它，我怀疑它们是同伙，你有见过它吗？”鳄鱼小姐深吸一口气，道：“我白天一直在家，没见过生人。” Charles一指Gambino的房间，道：“给我搜！”&emsp; &emsp;黑手党众人闯入了房间，鳄鱼小姐心跳到了嗓子眼，不住地祈祷着。房间内陈列简单，只有一张床和一个衣柜，Charles先是打开了衣柜，又俯身下来看了下床底，一无所获，接着它摸了摸被子，没有任何温度 —— 看来确实没人睡过，Charles将枪插回了腰间，道：“很抱歉打扰到您的睡眠，亲爱的小姐。”然后一挥手，“我们走，算那头小猪走运”。&emsp; &emsp;Charles走后，鳄鱼小姐瘫坐在地上，她都不记得自己是怎么样回到自己房间的，刚打开门，房间内就有人将它搂进怀中，一只手堵住了它的嘴，鳄鱼小姐正要挣扎便听到那人说话：“是我，Yi！”鳄鱼小姐也闻出了Yi身上的古龙水味，松了一口气。Yi松开了捂住鳄鱼小姐嘴巴的手，鳄鱼小姐道：“谢天谢地，黑手党没抓住您，这到底是是怎么回事呀！”Yi道：“小生也不知道，亲爱的小姐。现在当务之急是找到我哥哥，您能帮帮我吗？”鳄鱼小姐道：“当然！天哪，您不知道它们创进房间的时候我有多紧张，它们都带着枪！您要是有个三长两短，我——”它的话被Yi的吻堵住了，鳄鱼小姐也激烈地回应着它的炽热的感情，事已至此，一切都在不言中了。&emsp; &emsp;第二天鳄鱼小姐终于打探到了事情的来龙去脉 —— 大家津津乐道着Gambino出卖了黑手党，导致黑手党偷袭血骷髅帮时被埋伏，折损了几十个成员，Gambino自己也没有活着回来，不过它死的时候脸上终于不再带着那该死的狂笑了，而是一种错愕的表情。Yi痛苦地抱住了头，十指用力揪着头发，鳄鱼小姐将它抱在自己怀中，轻声宽慰着。&emsp; &emsp;接下来的日子，Yi乔装打扮，和鳄鱼小姐度过了一段幸福的时光，鳄鱼小姐的温柔舒缓了它的难过，两人俨然就是一对热恋中的情侣了。可惜好景不长，仲夏夜的时候，Yi和鳄鱼小姐在巷弄的拐角中亲热时，看到Charles带人将一只老狐狸堵在巷中，老狐狸道：“Charles，你难道就一点都不念旧情吗？”Charles道：“教父，要怪就怪您不肯闲下来，这么多年来我苦心经营黑手党，Boss的位置只能是我的！我可没有老到需要什么接班人！”说着它打了个响指，身后一个干部拖出了那门重炮，“您还认识这个吗？‘烤红薯机’，您宁肯把它交给一头猪也不愿意传给我！现在如何？我还是拿到了它！我背后捅刀子，陷害了Gambino，把它的行踪泄露给血骷髅帮，顺便除掉了它的心腹。您的徒弟有勇无谋，根本就不配继承黑手党，Boss的位置只能是我的！”重炮轰鸣，烟尘夹杂着血肉在Yi眼前飞过，它咬牙切齿，发誓一定要为哥哥报仇。&emsp; &emsp;……&emsp; &emsp;这些天来，Yi总是一个人在外奔波，也不许鳄鱼小姐跟着。终于有一天，鳄鱼小姐实在太担心Yi会做傻事了，就偷偷跟踪了它，但是Yi穿大街过小巷很快就甩开了她，鳄鱼小姐忧心忡忡地回到了家，却发现Yi已经做好了烛光晚餐在等她。饭菜冒着腾腾热气，珠光映在红酒杯上熠熠生辉，Yi微笑道：“亲爱的你去哪了？今天是我们相爱100天，小生为你准备了惊喜。”鳄鱼小姐心想：原来它一直瞒着我就是为了准备我们的纪念日！Yi将一杯红酒递给她，自己也斟满了和她碰杯，两人拥吻着，鳄鱼小姐呢喃道：“我爱你，Yi！”Yi的眼泪滴在了她的脸庞上，道：“对不起。”&emsp; &emsp;门突然开了，一只肥头大耳的河马走了进来，急不可耐地解着自己那考究的礼服。鳄鱼小姐大吃一惊，道：“Yi，它是谁？”她突然像一滩烂泥一样瘫倒在地，“你在酒里面下了药！”Yi低着头，喃喃道：“对不起，亲爱的。一切都是为了复仇。”它抓住了正要脱裤子的河马，问道：“小生的请柬呢？议员先生。”河马急匆匆地从裤兜里掏出一封请柬甩在了它脸上，道：“拿着快滚！别让我知道你在Charles先生的宴会上偷鸡摸狗，假若连累了我，我保证会让你见识到伦敦城的残忍！”Yi捡起了请柬，关上了房门走出去，它无力地靠在墙上，听着屋内传来男人的淫笑和女人的嚎啕大哭，它死死地攥住了手里的请柬，咬紧牙关，一头闯进了夜幕中。&emsp; &emsp;往后的故事便乏善可陈了 —— Yi在宴会上结识了Charles的妻子Mafia，靠着花言巧语和英俊皮囊骗取了她的欢心。英雄难过美人关，枭雄Charles深爱着自己的美人蛇Mafia，对她言听计从，终于在酒后，被Mafia和Yi联手杀死在浴缸中。&emsp; &emsp;大仇得报的Yi回到了鳄鱼小姐家中，鳄鱼小姐流着泪咬下了它的头颅。 三、Tony&emsp; &emsp;伦敦城新来了一只叫Tony的小猪。&emsp; &emsp;它自称是东郡来的理发师，只因为给当地的领主大人剃须时刮破了皮，领主便要绞死它，不得已才逃难来到了伦敦城，它阴险狡诈，对黑手党忠心耿耿，很快就成为了Mafia夫人的左膀右臂，在它的辅佐下，黑手党统一了伦敦城的地下黑道。&emsp; &emsp;在一个大雪纷飞的冬日，供暖系统发生了故障，Mafia夫人被迫冬眠，但却再也没有苏醒过来。Tony接受了黑手党的全部生意，伦敦城迎来了可怖的黑暗统治。&emsp; &emsp;长夜漫漫，朝阳还没来得及升起，便又教乌云笼罩住，暴风雨将要来临了。","categories":[{"name":"随笔","slug":"随笔","permalink":"/categories/随笔/"}],"tags":[{"name":"Novel","slug":"Novel","permalink":"/tags/Novel/"}],"keywords":[{"name":"随笔","slug":"随笔","permalink":"/categories/随笔/"}]},{"title":"分布式事务解决方案 & 一致性协议","slug":"Transaction-Consistency","date":"2019-12-17T12:47:23.000Z","updated":"2019-12-20T15:52:18.578Z","comments":true,"path":"Transaction-Consistency/","link":"","permalink":"/Transaction-Consistency/","excerpt":"","text":"分布式事务解决方案 &amp; 一致性协议 （一）分布式事务分布式事务就是指事务的参与者、支持事务的服务器、资源服务器以及事务管理器分别位于不同的分布式系统的不同节点之上。 1.特性 A：原子性。事务操作要么全部完成，要么全部不完成，不存在只完成部分的中间状态。 C：一致性。 I：隔离性。事务与事务之间不会相互影响，一个事务的中间状态不会被其他事务感知。 D：持久性。一旦事务完成，其对数据做出的更改就保存在了数据库中。 2.解决方案（1）TCC：补偿型事务解决方案TCC指的是Try（尝试）、Confirm（确认）、Cancel（取消）。其核心思想是：针对每一个操作，都需要注册一个与其相对应的确认和取消操作。 Try：对业务系统做检测及资源预留 —— 类似于2PC的Precommit准备阶段。 Confirm：对业务系统做确认提交 —— 类似于2PC的Commit提交阶段。 Cancel：在业务执行错误时，需要回滚的状态下，取消业务，释放预留资源。 比如A向B转账：1.在Try阶段，首先将A和B的钱冻结起来。2.在Confirm阶段，转账，转账成功则解冻两个账户。3.如果第2步执行失败，在Cancel阶段，将两个账户解冻。 优点：和2PC相比，流程简单 缺点：数据一致性弱于2PC，且在第2/3步都可能失败 （2）基于可靠消息的最终一致性解决方案 如：订单系统创建订单成功后，库存系统需要扣减相应库存。 订单系统 创建订单前，创建预发送消息，保存到消息表中，此时消息状态为：未发送 创建订单，如果失败则将消息表预发消息删除 创建订单成功，修改消息表消息状态为：发送中，并将消息发送至MQ 消息发送失败，则订单回滚，在消息表中删除对应消息；发送成功则OK 库存系统 从MQ监听并消费消息，同时根据消息ID查询消息是否被消费，保证幂等性 如果消息未被消费（消息表中存在此消息），则库存系统扣减库存；如果消息已经被消费（消息表中无此消息），则不做处理 库存系统扣减库存成功，则删除消息表中消息；失败则不做处理 定时任务会定时扫描消息表中超时未被消费的消息，然后尝试重发，如果超过最大重试次数后仍未被消费，则记录日志通知人工补偿 （二）一致性协议1.2PC（也称XA） 2PC即二阶段提交协议，在数据库中的应用即XA协议： 第一阶段（准备阶段，Precommit）：事务协调器要求每个事务参与者锁定资源、执行事务，但是不提交事务，而是只反映是否可以提交； 第二阶段（提交阶段，Commit/Rollback）：①如果所有事务参与者反映可以提交，则提交事务，释放锁定的资源；②如果有事务参与者反馈不可提交，则回滚事务，同样释放锁定资源 2PC的特点 强一致性：牺牲了部分可用性，换取数据的强一致性； 先斩后奏：先锁定资源、执行事务，再根据反馈决定提交还是回滚 2PC的缺点 阻塞：任何一次指令必须收到明确的响应才会执行下一步，否则一直处于阻塞状态，锁住的资源也不会释放 3PC引入超时机制解决了阻塞问题。 单点问题：一旦协调者宕机，参与者没有协调者指挥，会一直阻塞 脑裂：协调者二阶段发送Commit，有的节点收到了消息提交了事务，有的节点没有收到就没有提交事务，多个参与者之间数据不一致 2.3PC 3PC即三阶段提交协议： 询问阶段：协调者询问事务参与者是否可以执行事务，参与者只需要回答Yes/No，不需要真正执行 询问阶段 超时 导致中止！ 准备阶段：①如果所有事务参与者反馈可以执行事务，协调者向所有参与者发送执行请求，参与者锁定资源、执行事务，但是不提交，只反馈是否可以提交；②如果有事务参与者反馈不可用执行、或是超时没有收到某些事务参与者的反馈，那么协调者向参与者发送中止事务请求 准备阶段相当于2PC的PreCommit阶段，这阶段 超时 默认成功！ 提交阶段：①如果所有事务参与者反映可以提交、或是超时没有收到某些参与者的反馈，则默认执行成功、提交事务，释放锁定的资源；②如果有事务参与者反馈不可提交，则回滚事务，同样释放锁定资源 提交阶段相当于2PC的Commit/Rollback阶段 3PC的缺点 仍然可能存在脑裂：试想协调者提交阶段发送Commit，有的节点收到了消息提交了事务，有的节点没有收到就没有提交事务，多个参与者之间仍然会数据不一致 3.Paxos（超过半数）核心：超过半数 即所谓的Quorum机制：要求机器数量是奇数，每次需要有超过半数的机器ACK，操作方才会认为操作成功。ZK集群用的就是这种方式。 ZooKeeper的ZAB协议崩溃恢复 Leader宕机，集群恢复后发现已有新Leader被选举出来，那么原Leader会变为新Leader的Follower，同步新的Leader 4.Raft（日志复制、更多）Raft是一种管理复制日志的分布式一致性算法。 参考自http://ifeve.com/raft/ 节点3种状态 每个节点有3个状态，可以相互切换（选举流程）： Leader：主节点，用于写数据 Candidate：候选节点 Follower：从节点，用于读数据 任期每个Leader都有自己的任期： 任期结束后如果没有新的Candidate参与选举，那么Leader可以连任 如果任期结束有新的Candidate参与选举，那么两者进行选举，选票更多的成为Leader 选举流程 节点状态初始都是Follower，每个Follower会记录其Leader，然后和Leader之间维持一个心跳 Follower100-300ms没有收到Leader的心跳回复，Follower就变成Candidate Candidate给所有节点发送选票，获得更多Follower选票的Candidate就有资格成为Leader 如果多个Candidate获得的票同样多，那么两个Candidate会重新发选票，直到票数较多的节点当选Leader 日志复制流程 只有Leader才能接收客户端的写请求 每次Leader收到写请求，都会先记录日志 Leader将日志同步给所有Follower节点进行复制 Leader等待超过半数的Follower节点写日志成功后才提交数据，反馈客户端提交成功 集群中断当集群之间的部分节点失去通讯时，Leader的日志不能复制给多个Follower就不能进行提交。 崩溃恢复 集群恢复后，如果Leader发现自己的票数不是最多的，就会变成Follower，并回滚自己的日志 最后Leader会将自己的日志同步给所有Follower，保证主从数据一致性 Raft和Paxos崩溃恢复的区别：①Paxos的集群恢复是原Leader无论如何都变成新Leader的Follower；②而Raft不同于Paxos，集群恢复后原Leader不是直接变为Follower，而是和新Leader进行比较，票更多的才当选新Leader","categories":[{"name":"分布式","slug":"分布式","permalink":"/categories/分布式/"}],"tags":[{"name":"分布式","slug":"分布式","permalink":"/tags/分布式/"},{"name":"CAP","slug":"CAP","permalink":"/tags/CAP/"},{"name":"ZooKeeper","slug":"ZooKeeper","permalink":"/tags/ZooKeeper/"},{"name":"ZAB","slug":"ZAB","permalink":"/tags/ZAB/"},{"name":"高可用","slug":"高可用","permalink":"/tags/高可用/"},{"name":"2PC","slug":"2PC","permalink":"/tags/2PC/"},{"name":"XA","slug":"XA","permalink":"/tags/XA/"},{"name":"3PC","slug":"3PC","permalink":"/tags/3PC/"},{"name":"Paxos","slug":"Paxos","permalink":"/tags/Paxos/"},{"name":"Raft","slug":"Raft","permalink":"/tags/Raft/"},{"name":"Quorum","slug":"Quorum","permalink":"/tags/Quorum/"},{"name":"TCC","slug":"TCC","permalink":"/tags/TCC/"},{"name":"MQ","slug":"MQ","permalink":"/tags/MQ/"},{"name":"幂等性","slug":"幂等性","permalink":"/tags/幂等性/"}],"keywords":[{"name":"分布式","slug":"分布式","permalink":"/categories/分布式/"}]},{"title":"使用jsDeliver和GitHub白嫖CDN","slug":"cdn","date":"2019-12-14T02:53:13.000Z","updated":"2019-12-14T02:55:20.185Z","comments":true,"path":"cdn/","link":"","permalink":"/cdn/","excerpt":"","text":"使用jsDeliver和GitHub白嫖CDN查看文档可知，jsDeliver CDN主要使用了GitHub的release版本特性： // load any GitHub release, commit, or branch // note: we recommend using npm for projects that support it https://cdn.jsdelivr.net/gh/user/repo@version/file 新建GitHub public仓库，名称就叫cdn。 在本地电脑克隆远程仓库，将需要的静态资源（比如图片、不超过20M的视频……）加入本地仓库，然后提交到远程仓库。 默认你已经配置好了GitHub的SSH，并且本地Git也已经配置用户和邮箱。参考《Pro Git》 git clone git@github.com:DragonBaby308/cdn.git cd cdn //添加静态资源，建议创建不同目录存储，防止太乱 mkdir js mkdir img mkdir movie git add . git commit -m &quot;release 1.0&quot; git push 在GitHub远程仓库中点击release发布。 通过jsDeliver引用资源 //加载js https://cdn.jsdelivr.net/gh/DragonBaby308/cdn@1.0/js/jquery.js //加载图片 https://cdn.jsdelivr.net/gh/DragonBaby308/cdn@1.0/img/db3.png","categories":[{"name":"GitHub","slug":"GitHub","permalink":"/categories/GitHub/"}],"tags":[{"name":"GitHub","slug":"GitHub","permalink":"/tags/GitHub/"},{"name":"Git","slug":"Git","permalink":"/tags/Git/"},{"name":"CDN","slug":"CDN","permalink":"/tags/CDN/"},{"name":"jsDeliver","slug":"jsDeliver","permalink":"/tags/jsDeliver/"}],"keywords":[{"name":"GitHub","slug":"GitHub","permalink":"/categories/GitHub/"}]},{"title":"Hexo主题 —— Sakura 入门","slug":"hexo-theme-sakura","date":"2019-12-13T09:20:00.000Z","updated":"2019-12-14T07:38:52.433Z","comments":true,"path":"hexo-theme-sakura/","link":"","permalink":"/hexo-theme-sakura/","excerpt":"","text":"Hexo主题 —— Sakura 入门使用NexT主题有一段时间了，做了很多魔改，舍不得放弃。但是看别人的Sakura主题好香，又觉得眼馋 呵，男人o(￣▽￣)o 所以我决定再白嫖一个.github.io的站点，这次使用Sakura主题：https://dragonbaby308.github.io/ （一）安装Hexo与hexo-theme-sakura 参考《静态博客Hexo搭建教程（本地、服务器两开花）》和《唯美主题hexo-sakura使用教程》 mkdir HexoSakura //默认你已经安装好了npm和hexo-cli hexo init 根据作者的建议，直接访问https://github.com/honjun/hexo-theme-sakura获取压缩包，解压到博客根目录（注意，不是主题目录！），替换原有文件，然后运行npm i安装依赖。到这一步，使用hexo clean &amp;&amp; hexo g &amp;&amp; hexo s就已经可以看到站点效果了，不过我们还需要进行一系列自定义的配置。 （二）配置1.站点配置文件_config.yaml（1）简介# Site # 主标题：这个是你鼠标放标签页显示的名称，主页的名称要在主题配置文件中设置 title: DragonBaby308 # 副标题：不展示 subtitle: # 描述：不展示 description: keywords: # 作者名 author: DragonBaby308 # 语言 language: zh-CN # 简体中文 timezone: （2）部署 默认你已经配置好了GitHub的SSH，并且本地Git也已经配置用户和邮箱。参考《Pro Git》 # Deployment ## Docs: https://hexo.io/docs/deployment.html deploy: type: git repo: https://github.com/DragonBaby308/DragonBaby308.github.io.git #你的github.io的网址 branch: master （3）备份 首先需要在你远程GitHub仓库新建一个backup分支。 # backup backup: type: git message: https://DragonBaby308.github.io/ 备份 repository: github: https://github.com/DragonBaby308/DragonBaby308.github.io.git,backup 配置完成后每次通过hexo clean &amp;&amp; hexo b &amp;&amp; hexo d -g就可以完成部署和备份。 2.主题配置文件theme/Sakura/_config.yaml# site name # 站点名前缀，可以省略 prefixName: 想进阿里の # 站点名，显示为：前缀+站点名 siteName: DB3 # favicon and site master avatar # 标签页小图标： favicon: XXXXX # 头像： avatar: XXXXX # 站点URL url: https://DragonBaby308.github.io/ # 描述 description: 2019年只剩下尾巴了，希望2020年春招可以进ATM！ # 站点CDN，可以为空，图片需要填完整路径 cdn: https://cdn.jsdelivr.net/gh/DragonBaby308/cdn@1.0 # 开启pjax pjax: 1 # 公告 notice: 我不玩游戏，我定规则。 # 懒加载的加载中图片 lazyloadImg: https://cdn.jsdelivr.net/gh/honjun/cdn@1.6/img/loader/orange.progress-bar-stripe-loader.svg # 站点菜单配置【暂时保持，以后慢慢改】 menus: 首页: { path: /, fa: fa-fort-awesome faa-shake } 归档: { path: /archives, fa: fa-archive faa-shake, submenus: { 技术: {path: /categories/技术/, fa: fa-code }, 生活: {path: /categories/生活/, fa: fa-file-text-o }, 资源: {path: /categories/资源/, fa: fa-cloud-download }, 随想: {path: /categories/随想/, fa: fa-commenting-o }, 转载: {path: /categories/转载/, fa: fa-book } } } 清单: { path: javascript:;, fa: fa-list-ul faa-vertical, submenus: { 书单: {path: /tags/悦读/, fa: fa-th-list faa-bounce }, 番组: {path: /bangumi/, fa: fa-film faa-vertical }, # 歌单: {path: /music/, fa: fa-headphones }, 图集: {path: /tags/图集/, fa: fa-photo } } } 留言板: { path: /comment/, fa: fa-pencil-square-o faa-tada } 友人帐: { path: /links/, fa: fa-link faa-shake } 赞赏: { path: /donate/, fa: fa-heart faa-pulse } 关于: { path: /, fa: fa-leaf faa-wrench , submenus: { 我: {path: /about/, fa: fa-meetup}, # 主题: {path: /theme-sakura/, fa: iconfont icon-sakura }, # Lab: {path: /lab/, fa: fa-cogs }, } } # 客户端: { path: /client/, fa: fa-android faa-vertical } RSS: { path: /atom.xml, fa: fa-rss faa-pulse } # 背景图片 bg: - XXXXX - XXXXX - XXXXX - https://cdn.jsdelivr.net/gh/yremp/cdn@2.1.5/img/cover/(2).jpg.webp - https://cdn.jsdelivr.net/gh/yremp/cdn@2.1.5/img/cover/(3).jpg.webp - https://cdn.jsdelivr.net/gh/yremp/cdn@2.1.5/img/cover/(4).jpg.webp - https://cdn.jsdelivr.net/gh/yremp/cdn@2.1.5/img/cover/(5).jpg.webp - https://cdn.jsdelivr.net/gh/yremp/cdn@2.1.5/img/cover/(7).jpg.webp # 背景图片样式： # 空：原图 # filter-dim：阴影 # filter-grid：横条 # filter-dot：点点 bgclass: filter-dot # 快速导航面板 # url：链接，如果是本站链接，可以简写 # title：大标题 # desc：描述 # img：背景图 startdash: # - {url: /theme-sakura/, title: Sakura, desc: 本站 hexo 主题, img: /img/startdash/sakura.md.png} - {url: https://space.bilibili.com/24837083, title: Bilibili, desc: 乾杯！！！, img: /img/startdash/bilibili.jpg} # your site build time or founded date # 建站时间 siteBuildingTime: 12/12/2019 # 社交按钮PC端 # url：链接 # qrcode：二维码 # img：图标 social: GitHub: {url: http://github.com/DragonBaby308, img: https://cdn.jsdelivr.net/gh/honjun/cdn@1.6/img/social/github.png} 掘金: {url: https://juejin.im/user/5cef386351882551b47a32f7, img: XXXXX} BiliBili: {url: https://space.bilibili.com/24837083, img: XXXXX} WeChat: {url: /#, qrcode: XXXXX, img: https://cdn.jsdelivr.net/gh/honjun/cdn@1.6/img/social/wechat.png} QQ: {url: /#, qrcode: XXXXX, img: https://cdn.jsdelivr.net/gh/yremp/cdn@2.1.5/img/social/qq.png} # 社交按钮移动端 # url：链接 # fontawesome：图标 # color：颜色 msocial: github: {url: http://github.com/DragonBaby308, fa: fa-github, color: 333} # weibo: {url: http://weibo.com/mashirozx?is_all=1, fa: fa-weibo, color: dd4b39} # qq: {url: https://wpa.qq.com/msgrd?v=3&amp;uin=954655431&amp;site=qq&amp;menu=yes, fa: fa-qq, color: 25c6fe} # 赞赏二维码 donate: alipay: XXXXX wechat: XXXXX # 首页视频 movies: # url前缀 url: https://cdn.jsdelivr.net/gh/DragonBaby308/cdn@1.0/movie/ # 多个视频用逗号隔开，随机获取。支持的格式目前已知MP4,Flv name: fujiko.mp4 # 左下角aplayer播放器配置 # id:歌单ID —— 在歌单的URL中会有体现，自己观察 # server:音乐服务器 —— tencent：QQ音乐 # autoplay：是否自动播放 aplayer: id: 3090329008 server: tecent type: playlist fixed: true mini: false autoplay: false loop: all order: random preload: auto volume: 0.7 mutex: true # Valine评论 # 记得要在LeanCloud -&gt; 设置 -&gt; 安全中心 -&gt; web安全域名 中，将新域名加进去 valine: true v_appId: XXXXX v_appKey: XXXXX 3.分类/标签页配置theme/Sakura/languages/zh-cn.yaml# category # 分类名称：需要和theme/Sakura/_config.yaml的menus属性对应 # 对应链接为：/categories 技术: #中文标题 zh: 野生技术协会 # 英文标题 en: Geek – Only for Love # 封面图片 img: https://cdn.jsdelivr.net/gh/honjun/cdn@1.6/img/banner/coding.jpg 算法: zh: 程序 = 数据结构 + 算法 en: Algorithm img: https://cdn.jsdelivr.net/gh/DragonBaby308/cdn@1.0/img/categories/Algorithm.jpg Java基础: zh: Java是世界上最好的语言！来战！ en: Java img: https://cdn.jsdelivr.net/gh/honjun/cdn@1.6/img/banner/coding.jpg Linux: zh: Talk is cheap, show me the code. en: Linux img: https://cdn.jsdelivr.net/gh/DragonBaby308/cdn@1.0/img/categories/Linux.jpg 随笔: zh: 我有一个埋在心里的梦想，就是成为一个畅销小说家，没有和几个人说过。 en: Code &amp; Poetry. img: https://cdn.jsdelivr.net/gh/DragonBaby308/cdn@1.0/img/categories/Novel.jpg 设计模式: zh: 设计模式 en: Design Pattern img: https://cdn.jsdelivr.net/gh/DragonBaby308/cdn@1.0/img/categories/DesignPattern.jpg 分布式: zh: 分布式 en: Distributed System img: https://cdn.jsdelivr.net/gh/DragonBaby308/cdn@1.0/img/categories/DistributedSystem.jpg Docker: zh: 容器比虚拟机更加轻量级。 —— 沃兹.基硕德 en: Docker img: https://cdn.jsdelivr.net/gh/DragonBaby308/cdn@1.0/img/categories/Docker.jpg Hexo: zh: Hexo是非常好用的静态博客。 —— 海氏.沃兹.基硕德 en: Hexo img: https://cdn.jsdelivr.net/gh/DragonBaby308/cdn@1.0/img/categories/Hexo.jpg GitHub: zh: 全世界最大同性交友平台 —— en: GayHub img: https://cdn.jsdelivr.net/gh/DragonBaby308/cdn@1.0/img/categories/GitHub.jpg Go: zh: Go语言设计得非常人性化，我愿意把它作为第二语言。 en: GoLang img: https://cdn.jsdelivr.net/gh/DragonBaby308/cdn@1.0/img/categories/Go.jpg # tag # 标签名称 # 对应链接为：/tags 悦读: # 封面图片 img: https://cdn.jsdelivr.net/gh/honjun/cdn@1.6/img/banner/reading.jpg 4.单页面封面配置比如“留言板”，修改/source/comment/index.md中的photos属性即可。 5.番组计划页source/bangumi/index.md注释只是为了描述每个属性的作用，自己配置时需要将所有注释删除！ --- layout: bangumi title: bangumi comments: false date: 2019-02-10 21:32:48 keywords: description: bangumis: # 番组图片 - img: https://lain.bgm.tv/pic/cover/l/0e/1e/218971_2y351.jpg # 番组名 title: 朝花夕誓——于离别之朝束起约定之花 # 追番状态 （追番ing/已追完） status: 已追完 # 追番进度 progress: 100 # 番剧日文名称 jp: さよならの朝に約束の花をかざろう # 放送时间 time: 放送时间: 2018-02-24 SUN. # 番剧介绍 desc: 住在远离尘嚣的土地，一边将每天的事情编织成名为希比欧的布，一边静静生活的伊欧夫人民。在15岁左右外表就停止成长，拥有数百年寿命的他们，被称为“离别的一族”，并被视为活着的传说。没有双亲的伊欧夫少女玛奇亚，过着被伙伴包围的平稳日子，却总感觉“孤身一人”。他们的这种日常，一瞬间就崩溃消失。追求伊欧夫的长寿之血，梅萨蒂军乘坐着名为雷纳特的古代兽发动了进攻。在绝望与混乱之中，伊欧夫的第一美女蕾莉亚被梅萨蒂带走，而玛奇亚暗恋的少年克里姆也失踪了。玛奇亚虽然总算逃脱了，却失去了伙伴和归去之地……。 - img: http://lain.bgm.tv/pic/cover/l/e9/15/179949_c2j50.jpg title: 小林家的龙女仆 status: 已追完 progress: 100 jp: 小林さんちのメイドラゴン time: null desc: 在单身的辛苦OL小林身边突然出现的女仆装束的美少女托尔。长着角和尾巴的她的身姿正是所谓的龙娘。在醉酒的小林邀请下说要到家里去的托尔，鬼使神差地开始以小林家女仆的身份工作……！？“女仆”+“龙”=“女仆龙”有着笨手笨脚的可爱之处！龙娘与人类之间基本上很温暖、偶尔有些黑暗的异种族间交流喜剧！！ - img: http://lain.bgm.tv/pic/cover/l/42/54/219164_TLkl2.jpg title: 鲁邦三世 PART5 status: 已追完 progress: 100 jp: ルパン三世 PART5 time: null desc: 鲁邦三世与次元大介身处法国。故事在某处乡间小镇的公寓一室开始。包括毒品枪械等非法物资在内，任何物品都能购买的地下网站，“马可波罗”。为了盗取虚拟货币，鲁邦等人侵入了戒备森严的巨大服务器设施。他们在那里遇到了神秘的天才黑客少女，阿米。鲁邦和阿米一起正面应对马可波罗的陷阱，但由于敌人设置的“鲁邦游戏”，而落得被全世界监视的下场……阿米身上接连揭晓的谜团，以及知晓鲁邦三世过去的男人出现——鲁邦正陷入前所未有的绝境！ --- 5.友链页source/links/index.md注释只是为了描述每个属性的作用，自己配置时需要将所有注释删除！ --- layout: links title: links # 创建日期，可以改下 date: 2018-12-19 23:11:06 # 图片上的标题，自定义修改 keywords: 友人帐 description: # true/false 开启/关闭评论 comments: true # 页面头部图片，自定义修改 photos: https://cdn.jsdelivr.net/gh/honjun/cdn@1.4/img/banner/links.jpg # 友链配置 links: # 类型分组 - group: 个人项目 # 类型简介 desc: 充分说明这家伙是条咸鱼 &lt; (￣︶￣)&gt; items: # 友链链接 - url: https://shino.cc/fgvf # 友链头像 img: https://cloud.moezx.cc/Picture/svg/landscape/fields.svg # 友链站点名 name: Google # 友链介绍 desc: Google 镜像 # 类型分组... - group: 小伙伴们 desc: 欢迎交换友链 ꉂ(ˊᗜˋ) items: - url: https://shino.cc/fgvf img: https://cloud.moezx.cc/Picture/svg/landscape/fields.svg name: Google desc: Google 镜像 --- （三）其他魔改1.startdash名称更改将/themes/Sakura/layout/_partial/startdash.ejs中的&lt;h1 ...&gt;startdash&lt;/h1&gt;改为&lt;h1 ...&gt;快速导航&lt;/h1&gt;。 2.Discovery名称更改将/themes/Sakura/layout/index.ejs中的&lt;h1 ...&gt;Discovery&lt;/h1&gt;改为&lt;h1 ...&gt;正文&lt;/h1&gt;。 3.文章链接更改将_config.yaml中的permalink属性修改为permalink: :title/。 4.新建帖子头部格式修改/scaffolds/post.md，可以将hexo n生成的博客头改为自定义格式： --- title: {{ title }} date: {{ date }} author: DragonBaby308 avatar: &#39;https://cdn.jsdelivr.net/gh/DragonBaby308/cdn@1.2/img/header/avatar.jpg&#39; authorLink: www.dragonbaby308.com authorAbout: 气是清风肉是泥。 authorDesc: 佯狂难免假成真。 categories: xxx comments: true tags: keywords: description: photos: xxx ---","categories":[{"name":"Hexo","slug":"Hexo","permalink":"/categories/Hexo/"}],"tags":[{"name":"GitHub","slug":"GitHub","permalink":"/tags/GitHub/"},{"name":"Git","slug":"Git","permalink":"/tags/Git/"},{"name":"CDN","slug":"CDN","permalink":"/tags/CDN/"},{"name":"jsDeliver","slug":"jsDeliver","permalink":"/tags/jsDeliver/"},{"name":"Hexo框架","slug":"Hexo框架","permalink":"/tags/Hexo框架/"},{"name":"Hexo主题","slug":"Hexo主题","permalink":"/tags/Hexo主题/"}],"keywords":[{"name":"Hexo","slug":"Hexo","permalink":"/categories/Hexo/"}]},{"title":"iTerm2和oh-my-zsh联合打造Mac终端","slug":"oh-my-zsh","date":"2019-12-10T14:21:27.000Z","updated":"2019-12-14T02:58:00.153Z","comments":true,"path":"oh-my-zsh/","link":"","permalink":"/oh-my-zsh/","excerpt":"","text":"iTerm2和oh-my-zsh联合打造Mac终端（一）iTerm21.安装并设置为默认终端 下载并安装iTerm2 将iTerm2设置为默认终端：iTerm2 -&gt; Make iTerm2 Default Term 2.背景图片设置 选择背景图片：iTerm2 -&gt; Preferences -&gt; Profiles -&gt; Window -&gt; Background Image -&gt; Enabled 设置透明度：通过Blending调节壁纸的透明度，透明度越高越透明 效果图： 3.字体设置 通过pip安装PowerLine： # 通过HomeBrew安装python3，获取easy-install brew install python3 # 通过pip获取PowerLine pip install powerline-status --user 在合适位置创建空目录，执行如下命令安装字体库： git clone https://github.com/powerline/fonts.git --depth=1 cd fonts ./install.sh # Powerline fonts installed to /Users/dragonbaby308/Library/Fonts cd /Users/dragonbaby308/Library/Fonts 设置字体：iTerm2 -&gt; Preferences -&gt; Profiles -&gt; Text -&gt; Font -&gt; 选择字体 4.配色设置 在合适位置创建空目录，执行如下命令下载配色： git clone https://github.com/altercation/solarized cd solarized/iterm2-colors-solarized/ # 打开Finder open . 在打开的窗口中，双击Solarized Dark.itermcolors和Solarized Light.itermcolors即可安装明暗两种配色： 设置配色：iTerm2 -&gt; Preferences -&gt; Profiles -&gt; Colors -&gt; Color Presets （二）oh-my-zsh1.安装 Mac默认使用dash作为终端，通过chsh -s /bin/zsh将默认终端修改为zsh 安装oh-my-zsh： sh -c &quot;$(wget https://raw.github.com/robbyrussell/oh-my-zsh/master/tools/install.sh -O -)&quot; 2.主题下载与配置 创建空目录，执行如下命令： git clone https://github.com/fcamblor/oh-my-zsh-agnoster-fcamblor.git cd oh-my-zsh-agnoster-fcamblor/ # 执行该命令会将主题拷贝到oh-my-zsh的themes目录下，当然你也可以手动进行 ./install 修改配置文件：vi ~/.zshrc # 将主题配置为ys ZSH_THEME=&quot;ys&quot; source ~/.zshrc使配置生效 3.插件安装 插件安装 # 语法高亮插件 sudo git clone https://github.com/zsh-users/zsh-syntax-highlighting.git $ZSH_CUSTOM/plugins/zsh-syntax-highlighting # 命令补全插件 sudo git clone https://github.com/zsh-users/zsh-autosuggestions $ZSH_CUSTOM/plugins/zsh-autosuggestions 修改配置文件：vi ~/.zshrc # zsh-syntax-highlighting必须是最后一个！ plugins=(git, zsh-autosuggestions, zsh-syntax-highlighting) source ~/.zshrc使配置生效 如果觉得自动补全颜色与背景色难以区分，可以在iTerm2 -&gt; Preferences -&gt; Profiles -&gt; Colors -&gt; 右侧ANSI Colors -&gt; Bright第一行中配置自动补全的字体颜色。","categories":[{"name":"Linux","slug":"Linux","permalink":"/categories/Linux/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"/tags/Linux/"},{"name":"GitHub","slug":"GitHub","permalink":"/tags/GitHub/"},{"name":"Git","slug":"Git","permalink":"/tags/Git/"},{"name":"Shell","slug":"Shell","permalink":"/tags/Shell/"},{"name":"Fun!!!!!!!","slug":"Fun","permalink":"/tags/Fun/"},{"name":"Mac","slug":"Mac","permalink":"/tags/Mac/"},{"name":"oh-my-zsh","slug":"oh-my-zsh","permalink":"/tags/oh-my-zsh/"},{"name":"iTerm2","slug":"iTerm2","permalink":"/tags/iTerm2/"},{"name":"python3","slug":"python3","permalink":"/tags/python3/"},{"name":"pip","slug":"pip","permalink":"/tags/pip/"},{"name":"HomeBrew","slug":"HomeBrew","permalink":"/tags/HomeBrew/"}],"keywords":[{"name":"Linux","slug":"Linux","permalink":"/categories/Linux/"}]},{"title":"Go语言网络编程（TCP、HTTP、Beego框架）","slug":"go-web","date":"2019-12-04T15:37:01.000Z","updated":"2019-12-14T02:57:15.683Z","comments":true,"path":"go-web/","link":"","permalink":"/go-web/","excerpt":"","text":"Go语言网络编程（TCP、HTTP、Beego框架）（一）TCP编程涉及的包：net 1.服务端 net.Listen()监听某个端口 循环获取连接，为每个连接开启一个Goroutine 在单独的Goroutine中读取每个连接的数据 关闭连接 package main import ( &quot;fmt&quot; &quot;net&quot; &quot;strings&quot; ) func main() { fmt.Println(&quot;TCP服务端启动……&quot;) //监听50000端口 listen, err := net.Listen(&quot;tcp&quot;, &quot;0.0.0.0:50000&quot;) //错误处理 if err != nil { fmt.Println(&quot;监听50000端口错误：&quot;, err) return } //开启循环，获取连接 for { conn, err := listen.Accept() if err != nil { fmt.Println(&quot;获取连接错误：&quot;, err) return } //为每个连接开启一个Goroutine go process(conn) } } //连接处理函数 func process(conn net.Conn) { //执行完关闭连接 defer conn.Close() //开启循环，处理连接 for { buf := make([]byte, 512) n, err := conn.Read(buf) if err != nil { fmt.Println(&quot;读取数据失败：&quot;, err) return } //打印接收到的数据 fmt.Printf(strings.TrimSpace(string(buf[0:n]))) } } 2.客户端 net.Dail()连接服务端的某个端口 收发数据 关闭连接 package main import ( &quot;bufio&quot; &quot;fmt&quot; &quot;net&quot; &quot;os&quot; &quot;strings&quot; ) func main() { //拨号，连接50000端口 conn, err := net.Dial(&quot;tcp&quot;, &quot;localhost:50000&quot;) if err != nil { fmt.Println(&quot;连接服务端失败：&quot;, err) return } //读取键盘输入 inputReader := bufio.NewReader(os.Stdin) for { input, _ := inputReader.ReadString(&#39;\\n&#39;) trimedInput := strings.Trim(input, &quot;\\r\\n&quot;) //输入Q退出 if trimedInput == &quot;Q&quot; { return } //将数据写入连接，发送给服务端 _, err = conn.Write([]byte(trimedInput)) if err != nil { return } } //执行结束后关闭连接 defer conn.Close() } （二）HTTP编程涉及的包：net/http 1.服务端 http.HandleFunc()：指定某个函数处理对应路径下的请求 对应的处理函数接收w http.ResponseWriter, r *http.Request两个参数。 http.ListenAndServe()：监听某个端口的请求 package main import ( &quot;fmt&quot; &quot;net/http&quot; ) func main() { http.HandleFunc(&quot;/&quot;, Hello) if err := http.ListenAndServe(&quot;0.0.0.0:8080&quot;, nil); err != nil { fmt.Println(&quot;HTTP开启失败！&quot;) } } func Hello(w http.ResponseWriter, r *http.Request) { fmt.Println(&quot;处理“localhost:8080/”路径下的请求&quot;) fmt.Fprintf(w, &quot;Hello World&quot;) } 2.客户端 http.Get(url string) (resp *Response, err error) http.Post(url, contentType string, body io.Reader) (resp *Response, err error) http.Head(url string) (resp *Response, err error) package main import ( &quot;fmt&quot; &quot;io/ioutil&quot; &quot;net/http&quot; ) func main() { response, err := http.Get(&quot;http://www.dragonbaby308.com/&quot;) if err != nil { fmt.Println(&quot;http.Get()错误：&quot;, err) return } data, err := ioutil.ReadAll(response.Body) if err != nil { fmt.Println(&quot;读取响应数据错误：&quot;, err) return } fmt.Println(string(data)) } （三）Beego MVC框架 参考《Beego开发文档》 go get github.com/astaxie/beego下载Beego框架 创建如下目录结构： beego ├─controller ：控制器层 ├─IndexController ：【/index控制器】 ├─index.go ├─conf ：配置 ├─app.conf ：【默认配置文件】 ├─main ：入口 ├─main.go ：【入口程序】 ├─model ：模型层 ├─router ：路由 ├─router.go ：【路由规则】 └─view ：视图层 ├─index ├─index.html ：【/index模板】 main/main.go中导入Beego框架，通过beego.Run()运行： package main import ( &quot;github.com/astaxie/beego&quot; _ &quot;router&quot; //调用router的init() ) func main() { //运行Beego框架 beego.Run() } router/router.go中创建路由规则： package router import &quot;github.com/astaxie/beego&quot; func init() { //路由规则： //1.URL路径 //2.对应的控制器 //3.对应处理函数 beego.Router(&quot;/index&quot;, &amp;IndexController.IndexController{}, &quot;*:Index&quot;) } 在controller/IndexController/index.go中继承Beego的控制器，配置模板： package IndexController import ( &quot;github.com/astaxie/beego&quot; &quot;github.com/astaxie/beego/logs&quot; ) //继承Beego的控制器 type IndexController struct { beego.Controller } //处理函数 func (p *IndexController) Index() { //打日志 logs.Debug(&quot;进入IndexController&quot;) //1.【页面形式】 //配置模板 p.TplName = &quot;index/index.html&quot; //2.【API形式】 //autorender=false，不再渲染页面，可以返回JSON类型的结果 // m := make(map[string]interface{}) // m[&quot;code&quot;] = 200 // m[&quot;msg&quot;] = &quot;success&quot; // p.Data[&quot;json&quot;] = m // p.ServeJSON(true) } view/index/index.html模板： &lt;html&gt; &lt;body&gt; &lt;p&gt;Hello World!&lt;/p&gt; &lt;/body&gt; &lt;/html&gt; Beego默认会解析conf/app.conf配置文件： # IP地址 httpaddr = &quot;127.0.0.1&quot; # 应用名 appname = beego_demo # 是否自动渲染模板，默认true，返回渲染后的页面； # 如果想要返回API类型的JSON数据，将其改为false autorender = true # 运行时环境 runmode = &quot;dev&quot; # 开发环境 [dev] # 端口，默认9090 httpport = 9090 # 生产环境 [prod] # 端口 httpport = 9091 bee工具参考《bee 工具简介》","categories":[{"name":"Go","slug":"Go","permalink":"/categories/Go/"}],"tags":[{"name":"GitHub","slug":"GitHub","permalink":"/tags/GitHub/"},{"name":"Go","slug":"Go","permalink":"/tags/Go/"},{"name":"TCP","slug":"TCP","permalink":"/tags/TCP/"},{"name":"HTTP","slug":"HTTP","permalink":"/tags/HTTP/"},{"name":"Goroutine","slug":"Goroutine","permalink":"/tags/Goroutine/"},{"name":"高并发","slug":"高并发","permalink":"/tags/高并发/"},{"name":"多线程","slug":"多线程","permalink":"/tags/多线程/"},{"name":"Beego","slug":"Beego","permalink":"/tags/Beego/"},{"name":"bee","slug":"bee","permalink":"/tags/bee/"},{"name":"JSON","slug":"JSON","permalink":"/tags/JSON/"}],"keywords":[{"name":"Go","slug":"Go","permalink":"/categories/Go/"}]},{"title":"GitHub小技巧","slug":"github","date":"2019-11-28T16:01:55.000Z","updated":"2019-12-14T02:57:07.226Z","comments":true,"path":"github/","link":"","permalink":"/github/","excerpt":"","text":"GitHub小技巧 （一）快捷键查看：shift + ?在任意界面输入shift + ?，可以显示快捷键。 （二）分享某段代码：#Lstart-Lend如果你想分享你的Github上某段代码，可以在URL后加#L开始行号-L结束行号，如：https://github.com/DragonBaby308/python_diy_crawlers/blob/master/xiumeim_crawler/xiumeim.py#L26-L32。其实也不需要特别去记，点中某行代码前的行号，URL后就会加#L行号，再按住shift，选择结束行号，URL就会加上#L开始行号-L结束行号。 （三）查看自己项目的访问数据：Insights - Traffic在自己的项目下，点击Insights-Traffic，里面有Referring sites（代表大家从什么网页来到你的项目）和Popular content（代表大家经常看你项目的什么文件）。 （四）编辑代码在查看任意文件时，右上角会有一个小铅笔的标识。 点击小铅笔就可以直接编辑文件，编辑完成后，直接在页面上点击Propose File Change，Github就会为你fork这个仓库，创建一个pull request，节省了在本地fork -&gt; pull -&gt; 修改 -&gt; push -&gt; 创建PR的过程。 （五）趋势图——https://octoverse.github.com/Github语言趋势图：https://octoverse.github.com/ （六）精确搜索项目 in:name keyWord：项目名中含有keyWord in:readme keyWord：项目README.md中含有keyWord in:description keyWord：项目描述中含有keyWord stars:&gt;N：星星数量大于N language:Golang：语言限定为Golang语言 pushed:&gt;2019-06-06：最后一次提交时间晚于2019-06-06 比如我想搜索Golang语言微服务项目，最后一次提交时间要晚于2019-06-06，星星数量大于1000个：in:description 微服务 language:go pushed:&gt;2019-06-06 stars:&gt;1000","categories":[{"name":"GitHub","slug":"GitHub","permalink":"/categories/GitHub/"}],"tags":[{"name":"GitHub","slug":"GitHub","permalink":"/tags/GitHub/"},{"name":"Git","slug":"Git","permalink":"/tags/Git/"},{"name":"Go","slug":"Go","permalink":"/tags/Go/"}],"keywords":[{"name":"GitHub","slug":"GitHub","permalink":"/categories/GitHub/"}]},{"title":"Go语言并发编程","slug":"goroutine","date":"2019-11-22T14:48:10.000Z","updated":"2019-12-14T02:57:31.210Z","comments":true,"path":"goroutine/","link":"","permalink":"/goroutine/","excerpt":"","text":"Go语言并发编程 采用CSP（Communication Sequential Process）模型 编程时不需要锁，不需要callback 适合分布式 （〇）Go运行时调度机制 （一）并发版Hello World Go并发编程的核心就是go和chan，也即Goroutine和通道。 创建helloworldconc目录，创建conc.go： package main //Go语言中package后的目录名可以和实际目录不一致，main表明该文件是个可执行文件 import( &quot;fmt&quot; ) func main() { //:=变量声明，并赋初值 ch := make(chan string) //定义管道 for i := 0; i &lt; 5; i++ { //通过go关键字可以开启一个Goroutine go printHelloWorld(i, ch) } //从通道获取消息 for { msg := &lt;- ch fmt.Println(msg) } } func printHelloWorld(i int, ch chan string) { for { //如果使用了像%d一样的format参数，就需要用到Printf，不能用Println ch &lt;- fmt.Sprintf(&quot;Hello World from Goroutine %d\\n&quot;, i) //将字符串送入管道 } } go run conc.go，不断循环输出： Hello World from Goroutine 3 Hello World from Goroutine 4 Hello World from Goroutine 1 Hello World from Goroutine 2 Hello World from Goroutine 0 （二）并行计算 新建目录pipeline 创建nodes.go，不包括main函数： package pipeline import &quot;sort&quot; ///...表示可变长参数 //&lt;-表明这个返回的通道是只出不进的 func ArraySource(a ...int) &lt;-chan int { //创建通道 out := make(chan int) //创建Goroutine，将数组中的元素输送到通道 go func() { for _, v := range a { out &lt;- v } //关闭通道 close(out) }() return out } //排序单个通道 func InMemSort(in &lt;-chan int) &lt;-chan int { out := make(chan int) go func() { a := []int{} //将输入通道中的数据加入切片中 for v := range in { a = append(a, v) } //排序 sort.Ints(a) //输出 for _, v := range a { out &lt;- v } //关闭通道 close(out) }() return out } //归并 func Merge(in1, in2 &lt;-chan int) &lt;-chan int { out := make(chan int) go func() { v1, ok1 := &lt;-in1 v2, ok2 := &lt;-in2 for ok1 || ok2 { if !ok2 || (ok1 &amp;&amp; v1 &lt;= v2) { out &lt;- v1 v1, ok1 = &lt;-in1 } else { out &lt;- v2 v2, ok2 = &lt;-in2 } } close(out) }() return out } 创建可执行文件main.go： package main func main() { p := pipeline.Merge( pipeline.InMemSort(pipeline.ArraySource(3, 2, 6, 7, 4)), pipeline.InMemSort(pipeline.ArraySource(7, 4, 0, 3, 2, 8, 13))) for { //通过if子句，从通道获取数组元素 if num, ok := &lt;- p; ok { fmt.Println(num) } else { break } //等价于： // for v := range p { // fmt.Println(v) // } } } 输出： 0 2 2 3 3 4 4 6 7 7 8 13","categories":[{"name":"Go","slug":"Go","permalink":"/categories/Go/"}],"tags":[{"name":"Go","slug":"Go","permalink":"/tags/Go/"},{"name":"Goroutine","slug":"Goroutine","permalink":"/tags/Goroutine/"},{"name":"高并发","slug":"高并发","permalink":"/tags/高并发/"},{"name":"OS","slug":"OS","permalink":"/tags/OS/"}],"keywords":[{"name":"Go","slug":"Go","permalink":"/categories/Go/"}]},{"title":"Go语言入门","slug":"go","date":"2019-11-20T15:03:51.000Z","updated":"2019-12-14T02:57:23.259Z","comments":true,"path":"go/","link":"","permalink":"/go/","excerpt":"","text":"Go语言入门多学一门语言多条路吧，C/C++易学难精，Go语言原生支持并发编程，现在在微服务服务端编程中也越来越常用了，或许能给只会Java的我提供一个加入鹅厂的机会也说不准呢~PS：PornHub后端也是用的Go，你懂我的意思吧。 参考：https://howistart.org/posts/go/1/ Go语言应用： Docker 静态博客框架：Hugo （〇）Go语言特点 强类型语言，静态编译，不需要运行时进行类型推导，所以速度比解释型语言（如python、php…）快 存在GC，不需要程序员进行内存回收 存在未引用变量和未引用包时会报错 Go语言所有编码都是UTF-8，不需要额外指定编码类型 （一）环境搭建 下载并安装对应版本的Go语言包 查看版本：go version 查看环境：go env 其中GOROOT=&quot;/usr/local/go&quot;熟悉就是安装目录。而GOPATH属性对应的就是Go的项目工作目录，该目录下会有bin、pkg、src三个子目录。bin：Go编译好的可运行程序存放地址；pkg：Go库源码文件；src：Go命令源码文件、第三方类库存放地址，相当于根目录，建议将代码放在src目录下 在用户目录下除了GOROOT文件夹外的地方新建一个文件夹，作为GOPATH的值，比如我是/Users/dragonbaby308/go，并创建bin、pkg、src三个子目录 vim ~/.bash_profile，加： GOROOT=/usr/local/go export GOROOT export GOPATH=/Users/dragonbaby308/go export GOBIN=$GOPATH/bin export PATH=$PATH:$GOBIN:$GOROOT/bin source ~/.bash_profile使之生效 编辑器 GoLand：JetBrains旗下产品，体验自然没得说 Sublime Text安装GoSublime插件 你要是够牛逼，直接用vim很炫酷，10个看了9个都会佩服 （二）源码文件Go语言源码文件名称都是以.go为后缀，内容以Go语言代码组织的文件。 分类 命令源码文件：声明自己属于main代码包，包含无参数声明和结果声明的main函数，是Go语言程序的入口； 每个程序只能有一个main包，只有声明了package main的才是命令源码文件，一个程序只允许一个main()。 库源码文件 除了main的其他package下的都是库源码文件，编译后会在pkg目录下生成.a静态库文件。 测试源码文件：名称以_test.go为后缀，其中至少有一个函数名称以Test/Benchmark为前缀，且该函数接受一个类型为*testing.T/*testing.B的参数。 Test：功能测试；Benchmark：性能（基准）测试 单元测试小Demo 新建test包，创建calc.go： package main func add(a, b int) int { return a + b } 同目录下创建calc_test.go： 名称以_test.go为后缀，其中至少有一个函数名称以Test/Benchmark为前缀，且该函数接受一个类型为*testing.T/*testing.B的参数 package main func TestAdd(t *testing.T) { r := add(2, 4) if r != 6 { t.Fatalf(&quot;add(2, 4) error, expect: %d, actual: %d&quot;, 6, r) } t.Logf(&quot;test add() success!&quot;) } 运行calc_test.go，或者在test目录下执行go test -v： （三）基础命令 Go语言的命令和NPM很相似。 1.go run：运行 go run用于运行源码文件 只能接受一个命令源码文件以及若干个库源码文件作为文件参数 执行go run会先编译源码文件，存放在一个临时文件夹，然后再运行命令源码文件编译得到的可执行文件、库源码文件编译得到的归档文件 如果go run不加-work参数，会在命令执行完之前删除临时文件夹 参数 -a：强制编译相关代码，不论其编译结果是否已经是最新； -n：打印编译过程中所需要运行的命令，但是不真正执行； -x：打印编译过程中所需要运行的命令，并且真正执行； -p n：并行编译，其中n为并行的数量； -v：列出被编译的代码包的名称； -a -v：列出所有（不含标准库）被编译的代码包的名称 -work：显示编译时创建的临时工作目录的路径，并且在命令执行完后不删除临时工作目录； 2.go build：编译 编译.go命令源码文件，在相同目录下得到一个可执行文件。 go build不加参数，会将当前目录当作代码包进行编译。 参数 -race：如果存在资源竞争，运行时会打印在控制台 3.go install：编译并安装 go install不加参数，会将当前目录当作代码包进行编译安装。 4.go get：从远程仓库下载并安装从远程仓库（GitHub/GitLab/Gogs）下载并安装代码包 参数 -d：只执行下载动作，而不执行安装操作； -fix：在下载代码包后先执行修正操作，而后再进行编译和安装； -n：利用网络来更新已有的代码包及其依赖包 -x：打印编译过程中所需要运行的命令，并且真正执行； 5.ds：查看目录结构 ds for directory structure 6.go test：单元测试参数 -v：打印详细信息 （四）数据类型1.关键字 package：声明代码包 import：导入代码包 通过import _ &quot;packagePath&quot;可以在导包时调用对应包的init()方法！每个包都可以有自己的init()方法，在其中可以写一些初始化资源的默认方法。 func：声明函数 var：声明变量 const：声明常量 map：声明K/V对字典 chan：声明通道 type：定义数据类型 struct：定义结构体 interface：定义接口 go：通过go关键字可以开启一个Goroutine Goroutine的本质是协程，你可以理解为轻量级的线程，很多个Goroutine可以映射到一个物理线程上。 程序流控：select/break/case/continue/default/defer/else/fallthrough/for/goto/if/range/return/switch package main import ( &quot;fmt&quot; ) func main() { fmt.Println(&quot;Hello World!&quot;) } 2.变量var &amp; 常量const 变量可以只声明不赋值，常量声明了就一定要赋值Go语言非常严格：声明了变量就一定要使用，否则就会报错 单行赋值：关键字 名称 类型 ( = 值)/ 名称 := (值) var var1 int = 1 var var0 //变量可以只声明不赋值 shortVar := (577) //短变量声明，可以进行类型推断 const cosnt1 int = 1 平行赋值 var var2, var3 int = 2, 3 const const2, const3 int = 2, 3 多行赋值 var ( var4 int = 4 var5 int = 5 ) const ( const4 int = 4 const5 int = 5 ) 3.数组（1）数组的声明//声明长度为3的数组 type Number1 [3]int var numbers2 [3]int //不赋值时数组初始值默认为0，即：[3]int{0, 0, 0} （2）数组的赋值//声明定长数组时赋值 var numbers3 [3]int{1, 2, 3} //声明不定长数组时赋值 var numbers4 [...]int{1, 2, 3} （3）获取数组元素 &amp; 数组长度（len()）//通过下标获取数组元素，从0开始 numbers3[0] = 4 //数组长度 var length = len(numbers3) 4.切片（不含长度的数组）（1）切片的声明 声明：type MySlice []int 开辟空间：make([]T, length)，其中length为切片长度 //定义长度为100的int类型的切片 type nums []int = make([]int, 100) //可以简化为 nums := make([]int, 100) slice := []int{}定义的是一个空切片，并不是为切片开辟空间！！！ Golang二维切片赋值是真TMD反人类(￣_￣|||) （2）从数组获取切片var sliceName = arrayName[sIndex, eIndex]：获得的切片是对应数组的一个[sIndex, eIndex)的子数组（不包含结束位置元素） //数组 var numbers = [5]int{1, 2, 3, 4, 5} //通过切片表达式获取切片 var slice1 = numbers[1:4] //相当于[3]int{2, 3, 4} //获取切片的切片 var slice2 = slice1[1:3] //相当于[2]int{3, 4} （3）从切片获取子切片sub1 := slice[i:j] //i到j，不包括j sub2 := slice[i:] //i到尾部 sub3 := slice[:j] //头部到j，不包括j sub4 := slice[:] //相当于复制整个切片 （4）切片的长度 &amp; 容量（cap()） 切片的长度：eIndex - sIndex 切片的容量：len - sIndex，其中len是切片来源数组的长度 未赋值的切片默认容量为nil //capacity = len - 1 //len为来源数组长度，对于切片的子切片来说，是其父切片的容量，即cap(slice1) //cap(slice1) = len(numbers) - 1 = 4 //capacity = cap(slice1) - 1 = 3 var capacity int = cap(slice2) //值为3 （5）添加元素：append() append(slice []Type, elems ...Type) []Type var numbers2 []int numbers2 = append(numbers2, 0) 5.字典 Go语言的map是无序的！业务如果需要有序需要自己实现 格式：map[K]V mm := map[int]string{1:&quot;a&quot;, 2:&quot;b&quot;, 3:&quot;c&quot;} b := mm[2] //删除：有则删除，没有则无视 delete(mm, 4) //对于字典值来说，如果其中不存在索引表达式欲取出的键值对，那么就以它的值类型的空值（或称默认值）作为该索引表达式的求值结果 e := mm[5] //e的值一定是空字符串&quot;&quot;，那么我们怎么知道它是本来就为空，还是不存在该索引值呢？ //字典的索引表达式可以有两个结果，第二个结果是bool类型的，表明该键是否存在 e, ok := mm[5] //map的value声明成空接口类型，说明value可以是任何类型 var m map[string]interface{} //通过make为map初始化 m = make(map[string]interface{}) //赋值 m[&quot;username&quot;] = &quot;user2&quot; 6.通道【Go并发编程的基础】 参考《Go语言并发编程》 通道（Channel）的一种特殊的数据结构，用于在不同Goroutine之间传递类型化的数据，并且是并发安全的。 Goroutine（也称为Go程序，本质上是协程）可以被看成是承载可被并发执行的代码块的载体，它们由Go语言的运行时系统调度，并且依托于操作系统线程来并发执行其中的代码。 声明通道：chan T，如chan int 赋值：make(chan T, length)，其中length是通道的长度，如make(chan int, 5) length可以省略，即make(chan T) 接收/发送数据：&lt;- 关闭通道：close() 重复关闭通道/向已关闭的通道发送数据，都会造成异常！ //赋值 channel := make(chan string, 5) ch := make(chan int) //发送数据到通道 channel &lt;- &quot;value1&quot; //从通道接收数据，第二个值是bool类型的，true代表通道值有效 value, ok := &lt;- channel //关闭通道 close(channel) 7.函数 Go语言中函数是一等公民，可以作为值来传递和使用，参考Java8。 Go语言中的函数可以返回多个结果。 函数类型声明：type MyFunc func(入参列表) (出参列表)，如： //如果出参只有一个，可以省略括号 //出参中的参数名称也是可以省略的，只保留参数类型 type EmployeeIdGenerator func(company string, department string, number uint32) string 函数声明：func functionName(入参列表) (出参列表){}，如： //默认公司名称 var company = &quot;Tencent or PornHub&quot; //序列号 var number uint32 func generateId(generator EmployeeIdGenerator, department string) (string, bool){ if generator == nil { return &quot;&quot;, false } //使用代码包sync/atomic中提供的原子操作，保证并发操作安全性 newNumber := atomic.AddUint32(&amp;number, 1) return generator(company, department, newNumber), true } 可以简单地认为：函数名大写是public函数，可以在包外被访问到；函数名小写是private函数，不能在包外被访问到 8.结构体 定义结构体：tpye StructName struct{若干字段声明}； //定义结构体 type Person struct{ Name string Gender string Age uint8 } //创建结构体 Person{Name:&quot;Robert&quot;, Gender:&quot;Male&quot;, Age:30} //如果键值对的顺序与其类型中的字段声明完全相同的话，我们还可以统一省略掉所有字段的名称 p := Person{&quot;Lee Tang&quot;, &quot;Male&quot;, 20} 每个字段声明后可以带标签，参考第六节的Demo 结构体的方法func (person *Person) Grow() { person.Age++ } func (person *Person) Move(newAddress string) string { old := person.Address person.Address = newAddress return old } //调用结构体的方法 p.Grow() //通过指针创建结构体 person := &amp;Person{ Name: &quot;阿里&quot;, Gender: &quot;男&quot;, Age: 20, } 9.接口 定义接口：tpye InterfaceName interface{若干方法声明}； type Animal interface{ Grow() Move(string) string } 如果一个数据类型所拥有的方法集合中包含了某一个接口类型中的所有方法声明的实现，那么就可以说这个数据类型实现了那个接口类型。 //builtin.go中的error接口 type error interface { Error() string } //定义一个结构体 type PathError struct{ path string op string time string msg string } //使用该结构体的指针，实现某个接口的全部方法，就可以认为是实现了该接口 func (p *PathError) Error() string { return fmt.Sprintf(&quot;自定义异常：\\n path=%s\\n op=%s\\n time=%s\\n msg=%s\\n&quot;, p.path, p.op, p.time, p.msg) } 如果想让一个方法能够接收/返回任何类型的参数，就将参数声明为空接口：v interface{} —— 因为任何类型都可以是空接口 10.指针 &amp;：取址，当&amp;应用到一个值上会取出指向该值的指针值 凡是需要改变一个对象的内存地址的，都需要使用&amp;取址。比如说，改变一个map中某个key的value不需要&amp;，但是反序列化时为一个新的map分配内存空间就需要用到&amp;取址，见（七）-3-（2）-①~③ *：取值，当*应用到一个指针值上会取出该指针指向的值 11.错误（1）err错误一般来说可能返回错误的函数，通过一个err对象接收后直接打印或使用即可。 （2）简单字符串错误首先看下Go语言中简单字符串错误的类库errors.go源码： package errors func New(text string) error { //返回一个错误信息结构体，使用的是传入的字符串 return &amp;errorString{text} } //错误信息结构体，只包含一个字符串 type errorString struct{ s string } 所以说想要自定义简单字符串错误，使用errors.New(text string)即可： err1 := errors.New(&quot;简单字符串错误&quot;) fmt.Println(err1) //输出： //简单字符串错误 （3）接口错误builtin.go类库下存在error接口，源码如下： package builtin type error interface{ Error() string } 通过实现error接口即可实现自定义接口错误，在Go中，实现了一个接口的全部方法就可以认为是实现了该接口： //定义结构体 type PathError struct { path string op string time string msg string } //实现error接口 func (p *PathError) Error() string { return fmt.Sprintf(&quot;自定义错误：\\n path=%s\\n op=%s\\n time=%s\\n msg=%s\\n&quot;, p.path, p.op, p.time, p.msg) } //OpenFile函数，异常时返回一个PathError结构体，实现了error接口 func OpenFile(filePath string) error { file, err := os.Open(filePath) if err != nil { return &amp;PathError{ path: filePath, op: &quot;read&quot;, time: time.Now().String(), msg: err.Error(), } } defer file.Close() return nil } func main() { err2 := OpenFile(&quot;C:/faaaaaa/gaaaaa/donotexistfile.txt&quot;) if err2 != nil { fmt.Println(err2) } } //输出： // 自定义错误： // path=C:/faaaaaa/gaaaaa/donotexistfile.txt // op=read // time=2019-12-03 15:28:14.7397259 +0800 CST m=+0.001979701 // msg=open C:/faaaaaa/gaaaaa/donotexistfile.txt: The system cannot find the path specified. switch判断错误类型switch v := err.(type) { case *PathError: fmt.Println(&quot;PathError：&quot;, v) default: fmt.Println(v) } 12.异常panic() &amp; 捕获recover()package main import &quot;fmt&quot; func main() { fmt.Println(&quot;发生异常前&quot;) //声明异常捕获方法 defer func() { if err := recover(); err != nil { fmt.Println(&quot;异常捕获：&quot;, err) } }() //可能抛出异常的方法 Panic() fmt.Println(&quot;发生异常后&quot;) } //抛出异常的方法 func Panic() { var x = 30 var y = 0 //自定义异常 panic(&quot;抛出自定义异常！&quot;) var c = x / y fmt.Println(c) } //输出： // 发生异常前 // 异常捕获： 抛出自定义异常！ （五）流程控制1.if//else if 和 else可以没有 if 100 &gt; number { number += 3 } else if 100 &lt; number { number -= 2 } else { fmt.Println(&quot;100 hun!&quot;) } if语句的初始化子句 我们可以在if子句中为变量赋值，不需要单独赋值 初始化子句要放在if和; 条件表达式中间 初始化子句中定义的变量在if语句外是不可见的，除非在if语句外进行了声明 //number的作用域只在if内 if number := 4; 100 &gt; number { //... } 2.switchnames := []string{&quot;Golang&quot;, &quot;Java&quot;, &quot;Rust&quot;, &quot;C&quot;} //switch也可以有初始化子句 switch name := names[0]; name { case &quot;Golang&quot;: fmt.Println(&quot;Tencent/PornHub&quot;) case &quot;Java&quot;: fmt.Println(&quot;Alibaba&quot;) default: fmt.Println(&quot;回家喂猪是一样的&quot;) } 3.forfor i := 0; i &lt; 10; i++ { fmt.Print(i, &quot; &quot;) } //for-range语句 for i, v := range &quot;fxxk&quot; { fmt.Printf(&quot;%d: %c\\n&quot;, i, v) } // 0: f // 1: x // 2: x // 3: k //Go语言中声明了i就一定要使用，如果不想打印，可以使用_代替 for _, v := range &quot;fxxk&quot; { fmt.Printf(&quot;%c\\n&quot;, v) } //f //x //x //k //死循环 for { fmt.Println(&quot;死循环&quot;) } 4.select：用于选择不同通道接收数据ch1 := make(chan int, 1) ch2 := make(chan int, 1) select { case e1 := &lt;-ch1: fmt.Printf(&quot;1th case is selected. e1=%v.\\n&quot;, e1) case e2 := &lt;-ch2: fmt.Printf(&quot;2th case is selected. e2=%v.\\n&quot;, e2) default: fmt.Println(&quot;No data!&quot;) } 5.defer：方法结束前执行func readFile(path string) ([]byte, error) { file, err := os.Open(path) if err != nil { return nil, err } //关闭文件 defer file.Close() return ioutil.ReadAll(file) } （六）网络应用Demo 参考《Go语言网络编程》 创建main.go package main import ( &quot;net/http&quot; //生产级别的HTTP服务器，具备抵御常见攻击的能力 &quot;encoding/json&quot; //JSON格式解析 &quot;strings&quot; //处理字符串的库 ) func main() { //让hello函数处理来自&quot;/hello&quot;的请求 //每当一个新请求进入到与路径匹配的HTTP服务器时，服务器将生成一个执行hello()的新goroutine http.HandleFunc(&quot;/hello&quot;, hello) //让weather函数处理来自&quot;/weather&quot;的请求 //每当一个新请求进入到与路径匹配的HTTP服务器时，服务器将生成一个执行weather()的新goroutine //使用匿名函数 http.HandleFunc(&quot;/weather/&quot;, func(w http.ResponseWriter, r *http.Request) { city := strings.SplitN(r.URL.Path, &quot;/&quot;, 3)[2] //Go中的函数可以接收两个返回值，一般都会通过err判断是否发生异常 data, err := query(city) //异常处理 if err != nil { http.Error(w, err.Error(), http.StatusInternalServerError) return } //设置HTTP响应头 w.Header().Set(&quot;Content-Type&quot;, &quot;application/json; charset=utf-8&quot;) //JSON格式化 json.NewEncoder(w).Encode(data) }) //在8080端口启动服务器 http.ListenAndServe(&quot;:8080&quot;, nil) } //hello函数，用于处理来自&quot;/&quot;的请求 //http.ResponseWriter：用于发送响应报文到客户端，参数为byte类型的切片 func hello(w http.ResponseWriter, r *http.Request) { w.Write([]byte(&quot;hello!&quot;)) //如果觉得使用byte数组不直观，可以通过fmt.Fprintf()进行输出 //fmt.Fprintf(w, &quot;hello!&quot;) } //query函数 //回参可以省略参数名，只保留类型，weatherData是一个结构体类型 func query(city string) (weatherData, error) { //API_KEY需要申请 resp, err := http.Get(&quot;http://api.openweathermap.org/data/2.5/weather?APPID=YOUR_API_KEY&amp;q=&quot; + city) //异常处理 if err != nil { return weatherData{}, err } //延迟处理函数，用于关闭资源 defer resp.Body.Close() var d weatherData //if初始化子句，通过&amp;d指针给结构体塞值，err只有发生了异常才会有值 if err := json.NewDecoder(resp.Body).Decode(&amp;d); err != nil { return weatherData{}, err } return d, nil } //天气数据结构体 type weatherData struct { Name string `json:&quot;name&quot;` //在字段后加标签，方便进行JSON解析 Main struct { Kelvin float64 `json:&quot;temp&quot;` } `json:&quot;main&quot;` } 运行：go run 测试： curl http://localhost:8080/hello //输出：hello! curl http://localhost:8080/weather/tokyo //输出：{&quot;name&quot;:&quot;Tokyo&quot;,&quot;main&quot;:{&quot;temp&quot;:295.9}} （七）常用的库 已经使用过的fmt、net/http、strings不再记录。 1.sort：排序 sort.go： package main import ( &quot;sort&quot; &quot;fmt&quot; ) func main() { a := []int{3, 6, 2, 1, 9, 10, 8} //sort.Ints()，排序int类型切片/数组 sort.Ints(a) for _, v := range a { fmt.Println(i, v) } } 输出： 1 2 3 6 8 9 10 2.time：时间（1）停顿：time.Sleep()import &quot;time&quot; func main() { time.Sleep(1*time.Millisecond) //停顿1ms time.Sleep(5*time.Second) //停顿5s } （2）一次性计时器：time.After() 一次性计时器触发后会被GC，但是不保证何时回收，如果对性能要求高的话，不推荐使用time.After，应该用time.NewTicker()取代，手动关闭； 一次性计时器可以用于超时控制： import &quot;time&quot; func main() { //1s后触发一次 select { case v := &lt;- ch: fmt.Println(&quot;正常情况&quot;) //不推荐使用！ case &lt;- time.After(time.Second) : fmt.Println(&quot;超时1s&quot;) } } （3）定时器：time.NewTicker()定时器也可以用于超时控制，但是一定要关闭定时器，否则可能造成内存泄漏： import &quot;time&quot; func main() { //每过1s触发一次 t := time.NewTicker(time.Second) //定时器也可以用于超时控制 select{ case v := &lt;- ch: fmt.Println(&quot;正常情况&quot;) //t.C是一个时间的通道 case &lt;- t.C : fmt.Println(&quot;超时1s&quot;) } //每过1s打印一次 for v := range t.C { fmt.Println(&quot;hello&quot;, v) } //关闭定时器 t.Stop() } //输出： // 超时1s // hello 2019-12-04 14:39:27.2520634 +0800 CST m=+2.005214701 // hello 2019-12-04 14:39:28.251665 +0800 CST m=+3.004824301 // hello 2019-12-04 14:39:29.2532157 +0800 CST m=+4.006383001 //…… 3.encoding/json（1）序列化 NewEncoder(w io.Writer).Encode(v interface{}) 参考（六）网络应用Demo json.Marshal(v interface{}) ([]byte, error)：传入任何类型的参数，转换为byte[]类型的JSON数组 ①结构体序列化package main import ( &quot;encoding/json&quot; &quot;fmt&quot; ) //定义用户结构体 type User struct { UserName string `json:&quot;user_name&quot;` NickName string `json:&quot;nick_name&quot;` Age int //留一个不加标签，方便看标签的作用 Birthday string `json:&quot;birthday&quot;` Sex string `json:&quot;sex&quot;` Email string `json:&quot;e-mail&quot;` Phone string `json:&quot;phone&quot;` } func main() { //创建结构体对象 user := &amp;User{ UserName: &quot;user001&quot;, NickName: &quot;你弟含王&quot;, Age: 14, Birthday: &quot;1988-08-08&quot;, Sex: &quot;男&quot;, Email: &quot;741@qq.com&quot;, Phone: &quot;741741741&quot;, } jsonBytes, err := json.Marshal(user) if err != nil { fmt.Printf(&quot;json.Marshal err: &quot;, err) } fmt.Printf(&quot;%s\\n&quot;, jsonBytes) } //输出： //{&quot;user_name&quot;:&quot;user001&quot;,&quot;nick_name&quot;:&quot;你弟含王&quot;,&quot;Age&quot;:14,&quot;birthday&quot;:&quot;1988-08-08&quot;,&quot;sex&quot;:&quot;男&quot;,&quot;e-mail&quot;:&quot;741@qq.com&quot;,&quot;phone&quot;:&quot;741741741&quot;} //可以看到没有打标签的，JSON序列化时key就是字段名，打了标签则key是标签名 ②字典序列化package main import ( &quot;encoding/json&quot; &quot;fmt&quot; ) func main() { //定义[string, interface{}]类型的map var m map[string]interface{} //初始化 m = make(map[string]interface{}) m[&quot;username&quot;] = &quot;user002&quot; m[&quot;age&quot;] = 18 jsonBytes, err := json.Marshal(m) if err != nil { fmt.Printf(&quot;json.Marshal err: &quot;, err) } fmt.Printf(&quot;%s\\n&quot;, jsonBytes) } //输出： //{&quot;age&quot;:18,&quot;username&quot;:&quot;user002&quot;} ③切片序列化package main import ( &quot;encoding/json&quot; &quot;fmt&quot; ) func main() { //切片由[string, interface{}]的map组成 var s []map[string]interface{} //定义并给map赋值 var m map[string]interface{} m = make(map[string]interface{}) m[&quot;nickname&quot;] = &quot;小老弟&quot; m[&quot;address&quot;] = &quot;聚宝山庄&quot; //将map添加到切片 s = append(s, m) jsonByteArrays, err := json.Marshal(s) if err != nil { fmt.Printf(&quot;json.Marshal() err: &quot;, err) return } fmt.Printf(&quot;%s\\n&quot;, string(jsonByteArrays)) } //输出：JSON数组 //[{&quot;address&quot;:&quot;聚宝山庄&quot;,&quot;nickname&quot;:&quot;小老弟&quot;}] （2）反序列化 NewDecoder(r io.Reader).Decode(v interface{}) 参考（六）网络应用Demo json.Unmarshal(data []byte, v interface{}) error：第二个参数传入的要是&amp;指针引用 ①结构体反序列化package main import ( &quot;encoding/json&quot; &quot;fmt&quot; ) //定义用户结构体 type User struct { UserName string `json:&quot;user_name&quot;` NickName string `json:&quot;nick_name&quot;` Age int //留一个不加标签，方便看标签的作用 Birthday string `json:&quot;birthday&quot;` Sex string `json:&quot;sex&quot;` Email string `json:&quot;e-mail&quot;` Phone string `json:&quot;phone&quot;` } func main() { //创建结构体对象 user := &amp;User{ UserName: &quot;user001&quot;, NickName: &quot;你弟含王&quot;, Age: 14, Birthday: &quot;1988-08-08&quot;, Sex: &quot;男&quot;, Email: &quot;741@qq.com&quot;, Phone: &quot;741741741&quot;, } //获取转换后的JSON字节数组 jsonBytes, err := json.Marshal(user) if err != nil { fmt.Printf(&quot;json.Marshal err: &quot;, err) } //反序列化 var userResult User //结构体不是引用类型，所以此处传入的必须是指针引用，否则会报错 err = json.Unmarshal(jsonBytes, &amp;userResult) if err != nil { fmt.Println(&quot;json.Unmarshal err： &quot;, err) }else { fmt.Println(userResult) fmt.Println(userResult.Age) } } //输出： //{user001 你弟含王 14 1988-08-08 男 741@qq.com 741741741} //14 ②字典反序列化package main import ( &quot;encoding/json&quot; &quot;fmt&quot; ) func main() { //序列化 var m map[string]interface{} m = make(map[string]interface{}) m[&quot;username&quot;] = &quot;user002&quot; m[&quot;age&quot;] = 18 jsonBytes, err := json.Marshal(m) if err != nil { fmt.Println(&quot;json.Marshal err: &quot;, err) } //反序列化 var mapResult map[string]interface{} mapResult = make(map[string]interface{}) //传入的需要是&amp;指针引用 err = json.Unmarshal(jsonBytes, &amp;mapResult) if err != nil { fmt.Println(&quot;json.UnMarshal err: &quot;, err) } fmt.Println(mapResult) } //输出： //map[age:18 username:user002] ③切片序列化package main import ( &quot;encoding/json&quot; &quot;fmt&quot; ) func main() { //序列化 var s []map[string]interface{} var m map[string]interface{} m = make(map[string]interface{}) m[&quot;nickname&quot;] = &quot;小老弟&quot; m[&quot;address&quot;] = &quot;聚宝山庄&quot; s = append(s, m) jsonByteArrays, err := json.Marshal(s) if err != nil { fmt.Printf(&quot;json.Marshal() err: &quot;, err) return } //反序列化 var sliceResult []map[string]interface{} err = json.Unmarshal(jsonByteArrays, &amp;sliceResult) if err != nil { fmt.Printf(&quot;json.UnMarshal() err: &quot;, err) } fmt.Println(sliceResult) } //输出： //[map[address:聚宝山庄 nickname:小老弟]] 4.runtime：获取Go运行时环境import runtime //获取运行时CPU核心数 cpus := runtime.NumCPU() fmt.Println(cpus) //获取运行中的Goroutine数 gos := runtime.NumGoroutine() fmt.Println(gos) 5.sync：同步（1）sync.Mutex：互斥锁//定义互斥锁 var lock sync.Mutex //获取锁 lock.Lock() //同步代码块…… //释放锁 lock.Unlock() （2）sync.RWMutex：读写锁适合读多写少的情况： //定义读写锁 var lock sync.RWMutex //获取写锁 lock.Lock() //同步代码块…… //释放写锁 lock.Unlock() //获取读锁 lock.RLock() //释放读锁 lock.RUnlock() 6.ioutil：I/O工具类 ioutil.ReadAll(r io.Reader) ([]byte, error)：传入一个io.Reader，以字节数组的形式返回其中内容 response, err := http.Get(&quot;http://www.dragonbaby308.com/&quot;) if err != nil { fmt.Println(&quot;http.Get()错误：&quot;, err) return } //Body io.ReadCloser data, err := ioutil.ReadAll(response.Body) 7.math：数学库比较float64类型的大小 由于float64类型的数据具备精度的概念，开发者不具备精确比较两个float64类型数据的能力，所以Golang提供了库函数；但是对于其他的int类型数据，由于大小比较实现起来并不难，Golang为了保证语言的尽可能精炼，不提供比较两个int类型数据大小的库函数，需要开发人员自己实现（而且Golang还不支持?:的三元运算符，反正我觉得是挺没道理的━┳━ ━┳━ math.Min(x, y float64) float64：两数小者 math.Max(x, y float64) float64：两数大者","categories":[{"name":"Go","slug":"Go","permalink":"/categories/Go/"}],"tags":[{"name":"GitHub","slug":"GitHub","permalink":"/tags/GitHub/"},{"name":"Git","slug":"Git","permalink":"/tags/Git/"},{"name":"Homebrew","slug":"Homebrew","permalink":"/tags/Homebrew/"},{"name":"Mac","slug":"Mac","permalink":"/tags/Mac/"},{"name":"Go","slug":"Go","permalink":"/tags/Go/"},{"name":"HTTP","slug":"HTTP","permalink":"/tags/HTTP/"},{"name":"Goroutine","slug":"Goroutine","permalink":"/tags/Goroutine/"},{"name":"高并发","slug":"高并发","permalink":"/tags/高并发/"},{"name":"多线程","slug":"多线程","permalink":"/tags/多线程/"},{"name":"JSON","slug":"JSON","permalink":"/tags/JSON/"},{"name":"OS","slug":"OS","permalink":"/tags/OS/"},{"name":"GC","slug":"GC","permalink":"/tags/GC/"},{"name":"协程","slug":"协程","permalink":"/tags/协程/"}],"keywords":[{"name":"Go","slug":"Go","permalink":"/categories/Go/"}]},{"title":"Crond定时任务","slug":"crond","date":"2019-10-28T14:37:32.000Z","updated":"2019-12-14T02:56:00.652Z","comments":true,"path":"crond/","link":"","permalink":"/crond/","excerpt":"","text":"Crond定时任务 Crond是Linux下用来周期性执行某种任务或者等待处理某些事件的一个守护进程。 当安装了OS后默认会自动启动Crond进程，每分钟定期检查是否有需要执行的任务，如果有则自动执行。 参考https://blog.csdn.net/qq_22172133/article/details/81263736 （一）Linux下的任务调度1.系统任务调度：/etc/crontab/etc目录下的crontab文件是系统任务调度的配置文件，记录了系统周期性所执行的工作，比如写缓存数据到硬盘、日志清理等。如： # 【Crond任务运行的环境变量】 # 指定使用哪个shell，比如bash SHELL=/bin/bash # 指定了系统执行命令的路径 PATH=/sbin:/bin:/usr/sbin:/usr/bin # Crond任务执行信息将通过电子邮件发送给root用户 MAILTO=&quot;root&quot; # 执行命令或脚本时使用的主目录 HOME=/ # 【此部分是crontab文件，第二节介绍】 51 * * * * root run-parts /etc/cron.hourly 24 7 * * * root run-parts /etc/cron.daily 22 4 * * 0 root run-parts /etc/cron.weekly 42 4 1 * * root run-parts /etc/cron.monthly 2.用户任务调度 /etc/cron.deny：不允许使用crontab命令的用户 /etc/cron.allow：允许使用crontab命令的用户 /var/spool/cron/：所有用户crontab文件存放的目录,以用户名命名 （二）crontab用户所建立的crontab文件中，每一行都代表一个任务，每行的每个字段代表一项设置。 1.文件格式minute hour day month week command minute：分钟，0 ~ 59之间的整数 hour：小时，0 ~ 23之间的整数 day：日期，1 ~ 31之间的整数 month：月份，1 ~ 12之间的整数 week：星期几，0 ~ 7之间的整数，0/7表示星期日 command：要执行的命令，可以是系统命令，也可以是自己写的脚本 特殊字符在上述字段中，可以使用特殊字符： *：星号 —— 表示所有可能的值，比如month字段为*表示每个月； ,：逗号 —— 用来指定一个范围列表，比如1,2,3,4,5,6,7； -：中杠 —— 用在整数中间表示一个整数范围，比如2-6表示2,3,4,5,6； /：正斜杠 —— 指定时间的间隔频率，比如hour字段为0-23/2表示每隔2小时执行一次；minute字段为*/10表示10分钟执行一次。 2.命令格式crontab [-u user] fileName crontab [-u user] [-e|-l|-r] -u user：设定某个用户的crontab服务 fileName：crontab文件名 -e：编辑某个用户的crontab文件内容，如果不指定用户，则编辑当前用户的 e for edit -l：显示某个用户的crontab文件内容，如果不指定用户，则显示当前用户的 l for list -r：删除某个用户的crontab文件内容，如果不指定用户，则删除当前用户的 r for remove （三）Crond服务 安装（一般不需要） yum install crontabs 启动/关闭/重启/重载服务 /sbin/service crond start #启动 /sbin/service crond stop #关闭 /sbin/service crond restart #重启 /sbin/service crond reload #重载配置 查看服务状态 service crond status","categories":[{"name":"Linux","slug":"Linux","permalink":"/categories/Linux/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"/tags/Linux/"},{"name":"ECS","slug":"ECS","permalink":"/tags/ECS/"},{"name":"Crond","slug":"Crond","permalink":"/tags/Crond/"},{"name":"定时任务","slug":"定时任务","permalink":"/tags/定时任务/"}],"keywords":[{"name":"Linux","slug":"Linux","permalink":"/categories/Linux/"}]},{"title":"分布式全局唯一ID","slug":"uid","date":"2019-09-10T14:35:30.000Z","updated":"2019-12-14T02:58:23.034Z","comments":true,"path":"uid/","link":"","permalink":"/uid/","excerpt":"","text":"分布式全局唯一ID （一）UUID缺点： UUID太长 UUID无序 （二）MySQL自增ID 需要单独一个MySQL实例，在这个实例新建一个单独的表 CREATE DATABASE `SEQID`; CREATE TABLE SEQID.SEQUENCE_ID ( id bigint(20) unsigned NOT NULL auto_increment, stub char(10) NOT NULL default &#39;&#39;, PRIMARY KEY (id), UNIQUE KEY stub (stub) ) ENGINE=MyISAM; stub没有实际意义，只是为了方便插入数据，只有插入数据才能产生自增ID。 可以使用下列语句生成并获取到一个自增ID bigin; replace into SEQUENCE_ID(stub) VALUES (&#39;anyword&#39;); select last_insert_id(); commit; replace into优于insert into的地方：replace into会先看是否存在和stub指定值一样的数据，如果存在则先delete后insert，如果不存在则直接insert。 缺点 业务系统每需要一个ID，都会请求同一个数据库，单数据库压力大、性能低； 单点故障，一旦数据库宕机，整个系统都受影响 优化1.MySQL双主模式 使用两台MySQL实例，做如下配置： # 第一台MySQL实例 set @@auto_increment_offset = 1; # 初始值 set @@auto_increment_increment = 2; # 步长 # 第二台MySQL实例 set @@auto_increment_offset = 2; # 初始值 set @@auto_increment_increment = 2; # 步长 分布式应用随机去两个MySQL实例获取ID 优点 单MySQL实例宕机，另一台MySQL实例可以继续工作，不会影响整个系统，避免了单点故障 缺点 不利于扩容 2.号段模式 创建MySQL表，用于存储当前最大ID CREATE TABLE id_generator ( id int(10) NOT NULL, current_max_id bigint(20) NOT NULL COMMENT &#39;当前最大ID&#39;, increment_step int(10) NOT NULL COMMENT &#39;号段长度&#39;, PRIMARY KEY (`id`) ) ENGINE=InnoDB DEFAULT CHARSET=utf8; 应用程序从MySQL获取ID时，批量获取多个ID（称为一个“号段”）并进行缓存（可以是：①JVM缓存在本地 / ②Redis缓存）/③MyCat缓存。这样应用程序只需要在本地自增并返回，不需要每次请求数据库，只有缓存号段用完才去数据库获取下一号段。 可以在表中增加一个version字段，保证获取ID号段时的线程安全性： update id_generator set current_max_id=#{newMaxId}, version=version + 1 where version=#{version} 双主模式和号段模式可以结合使用。 （三）雪花算法（snow-flake）思路： 保证生成分布式ID的每台机器在每ms内生成不一样的ID。 分布式ID固定是一个long类型的数字，一个long占64bit。由于Long.MAX_VALUE = 2 ^ 63 - 1 = 9223372036854775807，也就是说long类型最多19位，用一个19位的String就可以保存。 64 bit - snowflake id = 1 bit - 标志位 + 41 bit - 时间戳 + 10 bit - 工作机器ID + 12 bit - 序列号 第一个1 bit是标识部分，在Java中由于long最高位是符号位，正数0，负数1，一般生成的ID都是正数，所以固定是0； 时间戳部分占41 bit，是一个ms级的时间，一般不会存储当前时间，而是时间戳差值（当前时间 - 固定开始时间），41位的时间戳可以使用69年（(1 &lt;&lt; 41) / (365 * 24 * 60 * 60 * 1000) = 69 年）； 当前时间戳应该使用应用启动时间对应的ms数原子递增，不能使用System.currentTimeMillis()，因为后者如果机器时间回调，可能出现重复ID。 工作机器ID占据10 bit，这部分比较灵活，比如前5位作为数据中心机房标识，后5位作为单机房机器标识，可以部署1024个节点 序列号部分占12 bit，支持同一ms内同一节点可以生成4096个ID。序列号可以从MySQL获取自增ID，可以参考上述的“MySQL序列号 + JVM/Redis/MyCat缓存”方案。 （四）Redis 利用Redis的incr原子命令实现ID的自增和返回，但是需要持久化 # 设置ID初始值 set seq_id 1 # 自增 &amp; 返回，是原子操作 incr seq_id 缺点 如果使用的RDB持久化方式：RDB持久化会丢失宕机期间到上一次快照存储期间的数据，所以可能出现重复ID 如果使用的AOF持久化方式：不会出现重复ID，但是会由于incr命令太多导致重启数据恢复时间过长 （五）应用：短URL（短网址）服务 百度短网址 —— https://dwz.cn/：比如输入http://www.dragonbaby308.com/，生成https://dwz.cn/SyQc17kp，二者指向地址都是一样的。 优点 短信或其他各类社交平台（比如微博）都会有字数限制，使用短链接可以减少字数 比起一堆不明所以的参数，使用短链接更加简洁友好，同时不暴露参数会更安全 原理HTTP 301/302重定向： 将长URL转为短URL 用户访问短URL，会通过HTTP 301/302重定向，访问到对应的长URL 长URL如何转短URL？ 建立一个发号器，每次有一个新的长URL进来，就将短网址 + 1然后返回，同时需要记录下长URL和短URL的映射关系（可以通过MySQL进行持久化存储）。 比如第一个URL返回www.dwz.cn/1，第二个URL则返回www.dwz.cn/2 使用这种方式，同一个长URL多次请求返回的短URL是不同的 即便是百度短网址，也没有实现同一个长URL多次请求返回相同的短URL，因为这样的代价太大，并且没有什么意义。百度短网址会保存1年的映射关系。 存在的问题： 其实发号器究根结底，也就是一种 分布式唯一ID，分布式唯一ID中MySQL发号的方案存在的高并发、单点故障问题，短URL发号器也同样会有。 1.如果直接存储在MySQL，高并发时库压力大怎么办？ 加一层Redis热点缓存 采用MySQL号段 + 缓存（JVM缓存/Redis缓存）的形式，每次从数据库获取一批号段，在缓存中进行分配，缓存号段用完才去数据库请求新的号段。可以有效减少库压力 2.采用单一MySQL，出现单点故障怎么办？ 采用MySQL双主模式，比如一个MySQL发号器发单号，另一个发双号 采用雪花算法","categories":[{"name":"分布式","slug":"分布式","permalink":"/categories/分布式/"}],"tags":[{"name":"分布式","slug":"分布式","permalink":"/tags/分布式/"},{"name":"MySQL","slug":"MySQL","permalink":"/tags/MySQL/"},{"name":"HTTP","slug":"HTTP","permalink":"/tags/HTTP/"},{"name":"高并发","slug":"高并发","permalink":"/tags/高并发/"},{"name":"Redis","slug":"Redis","permalink":"/tags/Redis/"},{"name":"雪花算法","slug":"雪花算法","permalink":"/tags/雪花算法/"},{"name":"CAS","slug":"CAS","permalink":"/tags/CAS/"},{"name":"JVM","slug":"JVM","permalink":"/tags/JVM/"},{"name":"MyCat","slug":"MyCat","permalink":"/tags/MyCat/"},{"name":"Java Base","slug":"Java-Base","permalink":"/tags/Java-Base/"}],"keywords":[{"name":"分布式","slug":"分布式","permalink":"/categories/分布式/"}]},{"title":"分布式系统理论基础","slug":"Distributed-System","date":"2019-09-06T13:01:40.000Z","updated":"2019-12-14T02:56:32.487Z","comments":true,"path":"Distributed-System/","link":"","permalink":"/Distributed-System/","excerpt":"","text":"分布式系统理论基础 分布式系统目标 提升系统整体性能和吞吐量 尽量保证分区容错性，即在分布式系统遇到某节点或网络分区故障时，仍要能够对外保证满足一致性和可用性的服务 分布式系统设计思路：中心化/去中心化1.中心化 中心化分布式系统中存在两类角色：Leader/Follower Leader负责分发任务，并监控整个系统，如果有Follower不工作则将其踢出整个系统 Follower负责执行Leader分配的任务 比如MySQL的Master/Slave架构，Master和Slave的角色是生来就是确定的。 又或者你可以参考现实中的黑心企业，领导负责分配工作给手底下的员工，并且监控员工，如果有员工过劳病倒了不能工作，领导不会尝试医治他，而是会直接开除他。 中心化分布式系统 存在的问题 &amp; 解决 单点故障问题：一旦Leader宕机，整个系统就不可用 解决：①多Leader热备或冷备，一旦Leader故障可以自动/手动切换②直接用去中心化取代中心化，一旦Leader宕机就重新进行选举 Leader能力会限制系统的扩展 2.去中心化 去中心化分布式系统不意味着没有Leader，而是由Follower来自由选择Leader。 一旦Leader宕机，集群中的Follower就会自发举行新一轮的选举，推选出新的Leader。 ZK中ZAB协议的Master选举就是此类。 去中心化分布式系统 存在的问题 &amp; 解决 网络分区（“脑裂”） 解决：小集群“自杀”或拒绝服务 基础理论（一）CAP理论 C：Consistency，一致性 —— 所有节点访问同一份最新数据副本 强一致性：任何时间所有节点访问到的数据都是最新的。最终一致性：不保证任何时间所有节点访问到的数据都是最新的，但是保证一定时间后系统中的数据都是最新的。 A：Availability，可用性 —— 每次请求都能收到非错响应，但是不保证获取的数据是最新数据 P：Partition Tolerance，分区容错性 —— 在分布式系统遇到某节点或网络分区故障时，仍能够对外保证满足一致性和可用性的服务 CAP理论常被认为是一致性（C）、可用性（A）、分区容错性（P）只能3选2。但是实际上，分区容错性（P）是分布式系统的基本能力，必须要保证。 C/A的取舍 在发生网络分区（P）的情况下，如果想要保证继续服务，那么强一致性（C）和可用性（A）只能2选1。 保证强一致性，放弃可用性 —— 可以保证用户看到的数据都是最新的数据，但是代价是响应时间急剧增加，一般不可取。 保证可用性，放弃强一致性 —— 首先保证用户的体验，允许用户看到的数据不是最新的，只保证在一定时间后系统中的数据会一致（即最终一致性） （二）BASE理论 BA：Basically Available，基本可用性 —— 在集群故障时，允许损失一部分的可用性，但绝不允许系统不可用 如：①响应时间增加；②系统功能的损失：大促期间，为了保证系统的稳定性，部分消费者会被引导到一个降级页面 S：Soft-state，软状态 —— 允许数据存在中间状态，即允许不同数据副本之间的同步存在延迟 E：Eventually Consistent，最终一致性","categories":[{"name":"分布式","slug":"分布式","permalink":"/categories/分布式/"}],"tags":[{"name":"分布式","slug":"分布式","permalink":"/tags/分布式/"},{"name":"CAP","slug":"CAP","permalink":"/tags/CAP/"},{"name":"BASE","slug":"BASE","permalink":"/tags/BASE/"},{"name":"ZooKeeper","slug":"ZooKeeper","permalink":"/tags/ZooKeeper/"},{"name":"ZAB","slug":"ZAB","permalink":"/tags/ZAB/"},{"name":"MySQL","slug":"MySQL","permalink":"/tags/MySQL/"},{"name":"高可用","slug":"高可用","permalink":"/tags/高可用/"}],"keywords":[{"name":"分布式","slug":"分布式","permalink":"/categories/分布式/"}]},{"title":"算法专题——动态规划","slug":"Algorithm-DP","date":"2019-09-03T14:40:22.000Z","updated":"2019-12-14T02:55:28.715Z","comments":true,"path":"Algorithm-DP/","link":"","permalink":"/Algorithm-DP/","excerpt":"","text":"算法专题——动态规划 参考自《动态规划套路详解》，写得真好。 动态规划（Dynamic Programming, DP）是一种将原有问题分解为相对简单的子问题，来求解复杂问题的方法，常常适用于有重叠子问题和最优子结构性质的问题。 最优子结构：原问题的解由子问题的最优解构成，并且子问题必须相互独立、互不干扰 原理：将重复计算子问题转化为查表，保证每个子问题只计算一次 —— 一旦某个给定子问题的解已经算出，则将其记忆化存储，以便下次需要同一个子问题解之时直接查表。 用途：DP常用于优化递归问题，使用递归求解时如果需要计算很多次重复子问题，那么利用DP可以减少计算量，具有天然剪枝的功能。 解DP问题的关键：找到状态转移方程 找到状态转移方程，也就意味着找到了一种暴力破解的方法。 （〇）解DP的惯用三步骤1.递归 自顶向下，画递归树，找到递归解法，发现重复子问题。 可以看到存在很多重复计算。 int countPaths(boolean[][] grid, int row, int col) { if (!validSquare(grid, row, col)) { return 0; } if (isAtEnd(grid, row, col)) { return 1; } return countPaths(grid, row + 1, col) + countPaths(grid, row, col + 1); } 2.递归 + 记忆化 将重复子问题进行记忆化存储 将每次计算所得结果存入一个数组中，每次不是重新求，而是查数组。 3.定义状态数组，递推状态转移方程 定义状态数组（即dp[n]数组） 自底向上，递推出状态转移方程，解决DP //边界条件：最下面一行和最右边一列，opt[i, j] = 0，只有一种走法 if (a[i, j] = &#39;空地&#39;) { opt[i, j] = opt[i - 1, j] + opt[i, j - 1]; }else { //石头 opt[i, j] = 0; } （一）背包问题将一系列具有重量w的物品（可能还有价值v），放入一个总容量为C的背包中，满足某种条件（比如放入的物品重量和恰好为C/重量和最大/价值和最大）。 （1）0-1背包0-1背包隐含的信息是： 对于每种物品只有两种选择，即“完全装入背包”/“不装入背包”。 不能将同一个物品装入背包多次，也不能只装一个物品的一部分。 ①物品无价值：【重量和恰好为C/重量和最大】假设有一个总容量为C的背包和n件重量分别为w1,w2,..,wn的物品，能否从n件物品中挑选若干件正好装满背包。 当C=10，6件物品种类分别为{1,8,4,3,5,2}，可以找到以下4组解：(1,4,3,2)、(1,4,5)、(8,2)、(3,5,2) 状态转移方程：maxValue[i][j] = Math.max(maxValue[i -1][j], maxValue[i - 1][j - w[i]] + w[i]);，其中0 &lt;= i &lt; n - 1，0 &lt;= j &lt;= C 无价值的0-1背包问题（重量和最大） ②物品有价值：【价值和最大】假设有一个总容量为C的背包，n种物品满足第i种物品重量为wi、价值为vi，应该如何选择装入背包的物品，使得装入背包中的物品价值和最大。 用一个二维数组maxValue[i][C]来表示第i种物品装入容量为C的背包时的最大价值 第i种物品装入背包时最大价值有两种情况： 装入第i种物品时，容量超过C：此时最大价值就是不装入第i种物品时的最大价值 —— maxValue[i-1][C] 装入第i种物品时，容量不超过C：此时最大价值需要在前i-1种物品最大价值上加上第i种物品的价值，同时前i-1种物品的容量需要减去第i种物品的容量 —— vi + maxValue[i - 1][C - wi] 状态转移方程：maxValue[i][C] = Math.max(maxValue[i - 1][C], vi + maxValue[i - 1][C - wi]); //@params: int[] w 重量 //@params: int[] v 价值 //@params: int C 背包容量 public static int knapsack(int[] w, int[] v, int C) { int size = w.length(); if(size &lt;= 0) return 0; //最大价值数组 int[][] maxValue = new int[size][C + 1]; //边界值——只填入物品0时的最大价值 for(int i = 0; i &lt;= C; i++) { //判断容量是否超过 maxValue[0][i] = w[0] &gt; C ? 0 : v[0]; } //状态转移方程 for(int j = 1; j &lt; size; j++){ for(int k = 0; k &lt;= C; k++){ //这一步是为了过滤掉k - w[j] &lt; 0的情况，防止数组越界 maxValue[j][k] = maxValue[j - 1][k]; if(w[j] &lt;= k) maxValue[j][k] = Math.max(maxValue[j][k] , maxValue[j - 1][k - w[j]] + v[j]); } } //总共size种，从0开始 return maxValue[size - 1][C]; } 以上DP使用了二维数组，空间复杂度是O(n * C)。可以优化为一维数组： //... int[] maxValue = new int[C + 1]; //边界值——只填入第0种物品 for(int i = 0; i &lt;= C; i++){ maxValue[i] = w[i] &lt; i ? v[i] : 0; } //状态转移方程 for(int j = 1; j &lt; size; j++){ //从后往前遍历，防止计算结果被覆盖 for(int k = C; k &gt;= w[j]; k--){ maxValue[k] = Math.max(maxValue[k], v[j] + maxValue[k - w[j]]); } } return maxValue[C]; （2）完全背包 与“0-1背包”的区别在于每种物品可以放无限次。 假设有一个总容量为C的背包，n种物品满足第i种物品重量为wi、价值为vi，每种物品可以放入无限多次，应该如何选择装入背包的物品，使得装入背包中的物品价值和最大。 （3）多重背包与“0-1背包”的区别在于每种物品有一个固定的次数上限。 （二）Leetcode easy1.最大子序和 https://leetcode-cn.com/problems/maximum-subarray/ 给定一个整数数组nums，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。 输入: [-2,1,-3,4,-1,2,1,-5,4] 输出: 6 解释: 连续子数组 [4,-1,2,1] 的和最大，为 6 扫描法 思路：加上一个正数和会增加，加上一个负数和会减少；由于子数组是连续的，所以对于当前元素来说，如果加入之前子数组和中得到了一个负数，那么就将累加结果丢弃并清零，子数组从当前元素重新开始遍历即可。 看到网上有人将其类比成了“赌徒理论” —— 永远只记住自己赢钱的时候，如果哪一天查看总资产发现自己亏本了，就将这一天之前的那些天都忘记，从0开始赌。 时间复杂度：O(N) //8 ms //3.3 MB func scanMaxSubArray(nums []int) int { //最大子数组和，由于子数组必然连续且非空，所以初始值即第一个元素 max := nums[0] //当前子数组和 sum := 0 //遍历数组，将当前元素加入子数组（并不需要真正的加入，因为我们关心的只是加入后的数组和） for i := 0; i &lt; len(nums); i++ { sum += nums[i] //如果加入的是正数，更新最大值 if sum &gt; max { max = sum } //如果和为负数，将和丢弃并清空，即子数组开始元素变更为当前元素 if sum &lt; 0 { sum = 0 } } return max } DP 状态转移方程：dp[i] = max(dp[i - 1] + nums[i], nums[i]) 时间复杂度：O(N) //8 ms //3.5 MB func dpMaxSubArray(nums []int) int { max := nums[0] length := len(nums) dp := make([]int, length) //dp[i]代表的是数组下标为i的元素加入后，子数组中最大值 //所以可以知道dp[0] = nums[0]，即第一个元素 dp[0] = nums[0] for i := 1; i &lt; length; i++ { dp[i] = nums[i] if sum := dp[i -1] + nums[i]; sum &gt; max { dp[i] = sum } //记录最大值 if sum &gt; max { max = sum } } return max } 2.买卖股票的最佳时机给定一个数组，它的第i个元素是一支给定股票第i天的价格。如果你最多只允许完成一笔交易（即买入和卖出一支股票），设计一个算法来计算你所能获取的最大利润。注意你不能在买入股票前卖出股票。 输入: [7,1,5,3,6,4] 输出: 5 解释: 在第 2 天（股票价格 = 1）的时候买入，在第 5 天（股票价格 = 6）的时候卖出，最大利润 = 6-1 = 5 。 注意利润不能是 7-1 = 6, 因为卖出价格需要大于买入价格。 输入: [7,6,4,3,1] 输出: 0 解释: 在这种情况下, 没有交易完成, 所以最大利润为 0。 O(N)解法这种思路是很容易想到的，记录最小元素min和最大差值max，遍历数组，将当前位置元素和min做减法，更新max和min： // 12 ms // 3.1 MB func maxProfit(prices []int) int { l := len(prices) if l &lt;= 1 { return 0 } max := 0 //最大差值 min := prices[0] //股票买入最低价 for i := 1; i &lt; l; i++ { tmp := prices[i] - min //此时卖出赚到的钱 if tmp &gt; max { max = tmp } //如果赚到的钱是负数，更新最小值 if tmp &lt; 0 { min = prices[i] } } return max } DP根据惯有套路，我们要先定义状态数组，然后递推出DP的状态转移方程。那么状态数组如何定义呢？ 首先最容易想到的是一维状态数组：mp[i]代表的是到第i天的最大利润。在第i天的时候可以选择买入股票或者卖出股票，尝试来写状态转移方程：mp[i] = (price[i] &gt;= 0) ? (mp[i - 1] - price[i]) : (mp[i - 1] + price[i])。但是这样写是不对的！我们还有其他的限制条件：买入股票时手里不能持有股票、卖出股票时手里必须有股票，所以只用一个一维数组来定义状态是不够的。 我们增加一个维度：mp[i][has]代表的是到第i天的最大利润，has ∈ {0, 1}，0表示手中未持有股票，1表示手中持有股票。在第i - 1天如果手中没有股票，我们可以第i天保持原状或者选择买入，选择两者中的最大值；如果第i - 1天手中持有股票，我们可以在第i天保持原状或者卖出，选择两者中的最大值。状态转移方程变成了： mp[i][0] = max(mp[i - 1][0], mp[i - 1][1] + price[i]) //卖出股票，利润加上价格 mp[i][1] = max(mp[i - 1][1], mp[i - 1][0] - price[i]) //买入股票，利润减去价格 那么使用二维数组就够了吗？答案是还是不够，我们还有一个限制条件：最多只能买卖k次股票（本题中k = 1）。所以我们要再增加一个维度：mp[i][cnt][has]代表的是到第i天的最大利润，cnt代表第i天之前交易股票的次数，has ∈ {0, 1}（0表示手中未持有股票，1表示手中持有股票）。状态转移方程变成了： mp[i][k][0] = max(mp[i - 1][k][0], mp[i - 1][k - 1][1] + price[i]) //卖出股票，利润加上价格 mp[i][k][1] = max(mp[i - 1][k][1], mp[i - 1][k - 1][0] - price[i]) //买入股票，利润减去价格 到这一步，最大利润就变成了max( mp[n - 1][cnt][0] ), cnt在[0, k]范围内循环 那么如果题目改为手中最多持有X股票呢？has在[0, X]范围内循环即可。状态转移方程：mp[i][k][j] = max(mp[i - 1][k][j], mp[i - 1][k - 1][j + 1] + price[i], mp[i - 1][k - 1][j - 1] - price[i])","categories":[{"name":"算法","slug":"算法","permalink":"/categories/算法/"}],"tags":[{"name":"算法","slug":"算法","permalink":"/tags/算法/"},{"name":"背包问题","slug":"背包问题","permalink":"/tags/背包问题/"},{"name":"0-1背包","slug":"0-1背包","permalink":"/tags/0-1背包/"},{"name":"完全背包","slug":"完全背包","permalink":"/tags/完全背包/"},{"name":"DP","slug":"DP","permalink":"/tags/DP/"},{"name":"递归","slug":"递归","permalink":"/tags/递归/"}],"keywords":[{"name":"算法","slug":"算法","permalink":"/categories/算法/"}]},{"title":"算法专题：排序","slug":"Algorithm-sort","date":"2019-08-16T12:24:26.000Z","updated":"2019-12-14T02:55:35.829Z","comments":true,"path":"Algorithm-sort/","link":"","permalink":"/Algorithm-sort/","excerpt":"","text":"排序 稳定性一个排序算法的稳定性是指，如果a=b，排序前a在b前面，那么排序后a也要在b的前面。即排序后元素的相对位置不变。 简单来说： 如果一个排序算法会将某个元素单独提到某个位置，那么它就是不稳定的； 如果一个排序算法只涉及两两相邻元素之间的交换，那么它就是稳定的。 稳定排序：冒泡排序、插入排序、希尔排序、归并排序 不稳定排序：选择排序、快排、堆排序 1.选择排序（O(N^2)） 选择排序（Selection Sort）每次排序时，从未排序序列中“选择”一个元素加入排序序列，因此得名。 选择排序需要两次遍历 —— 第一遍是遍历所有元素，确认已排序的序列范围[0,i)；第二遍是遍历所有未排序序列[i,lastIndex]，每次将当前位置与队首（i）元素比较，选择最小元素，交换到队首，所以选择排序的时间复杂度是O(N^2) 选择排序是不稳定排序，因为存在将元素单独提到某个位置的情况 //选择排序 public static int[] selectionSort(int[] in) { int lastIndex = in.length - 1; //即：循环遍历次数 for (int i = 0; i &lt;= lastIndex; i++) { //每次遍历，将最小元素浮动到最左边 //0~i是已排序序列，i~lastIndex是未排序序列，将未排序中的最小元素放在i位置 for(int j = i; j &lt;= lastIndex; j++) { //默认in[i]是最小元素，如果in[j]小于in[i]，则交换 if (in[j] &lt; in[i]) { //如果i=j，那么in[i]=in[j] //所以可以保证in[i]、in[j]是不同对象，可以通过异或进行交换 in[i] = in[i] ^ in[j]; in[j] = in[i] ^ in[j]; in[i] = in[i] ^ in[j]; } } } return in; } 选择排序 &amp; 插入排序 的区别：选择排序是每次从未排序序列中选择最小/最大的元素，加入已排序序列；插入排序是每次按顺序从未排序序列中选择一个元素，加入已排序序列中的合适位置；也就是说，选择排序遍历的未排序序列，插入排序遍历的已排序序列。 2.冒泡排序（O(N^2)） 冒泡排序（Bubble Sort）每次排序时，将未排序序列最大元素“浮动”到尾部，因此得名。 冒泡排序需要两次遍历 —— 第一遍是遍历所有元素，确认已排序的序列范围[lastIndex - i, lastIndex]；第二遍是遍历所有未排序序列（0, lastIndex - i），相邻元素两两比较，将最大元素浮动到队尾，所以冒泡排序的时间复杂度是O(N^2) 冒泡排序是稳定排序，因为只涉及相邻元素两两比较 //冒泡排序 public static int[] bubbleSort(int[] in) { int lastIndex = in.length - 1; for (int i = 0; i &lt;= lastIndex; i++) { //[lastIndex - i,lastIndex]是排好序的序列 //[0,lastIndex - i)是未排好序的序列 for(int j = 0; j &lt;= lastIndex - i - 1; j++) { //与选择排序不同，冒泡排序是两两相邻元素比较后交换 //将较大的交换到后面 if (in[j + 1] &lt; in[j]) { //不同元素异或交换 in[j + 1] = in[j] ^ in[j + 1]; in[j] = in[j] ^ in[j + 1]; in[j + 1] = in[j] ^ in[j + 1]; } } } return in; } 2.1 冒泡排序优化：交换标志位对冒泡排序的优化是加入一个交换标志位，如果某一次循环中没有进行数据交换，说明剩余的序列已经是有序的了，可以不再进行后续的循环。 //优化冒泡排序——加入交换标志位 public static int[] flagBubbleSort(int[] in) { //标志位：本趟排序是否进行了交换 //如果本趟排序没有进行元素交换，说明已经有序了，可以提前结束循环 boolean exchange; int lastIndex = in.length - 1; for (int i = 0; i &lt;= lastIndex; i++) { exchange = false; //[lastIndex - i,lastIndex]是排好序的序列 //[0,lastIndex - i)是未排好序的序列 for(int j = 0; j &lt;= lastIndex - i - 1; j++) { //与选择排序不同，冒泡排序是两两相邻元素比较后交换 //将较大的交换到后面 if (in[j + 1] &lt; in[j]) { //不同元素异或交换 in[j + 1] = in[j] ^ in[j + 1]; in[j] = in[j] ^ in[j + 1]; in[j + 1] = in[j] ^ in[j + 1]; exchange = true; //发生了交换 } } if(!exchange) break; //无交换直接退出循环 } return in; } 3.插入排序（O(N^2)） 在形容插入排序时，一般都会类比摸扑克。你的手牌就是已排序序列，牌堆就是未排序序列，每次摸牌时会选择手排中的合适位置插入。我的习惯就是强迫按顺序插好牌 - - ||| ，后来我才发现其他孩子摸牌根本不会像我一样，他们都是一把抓在手里面的，所以每次玩扑克他们都要等我抓好牌=====(￣▽￣*)b 插入排序（Insertion Sort）的原理就是将序列分为两个部分，一部分是已排序序列，另一部分是未排序序列，每次从未排序序列中选择一个元素插入已排序序列中的合适位置 插入排序需要两次循环——第一次是遍历所有元素，确定已排序序列[0,i)；第二次是遍历所有已排序序列[0,i)，将位置i的元素插入已排序序列的合理位置——由于遍历的序列是已经排好序的，所以这一步只需要用到一个临时变量。所以插入排序的时间复杂度是O(N^2) 使用一个临时变量temp存储位置i的元素。从j=i位置开始向前遍历，如果in[j] &gt; temp，那么j--；如果in[j] &lt;= temp，那么交换j位置元素和temp，然后j--，继续比较in[j]和temp。 插入排序是稳定性排序，因为只涉及到相邻元素两两比较 //插入排序 public static int[] insertionSort(int[] in) { int lastIndex = in.length - 1; //从1开始遍历，是默认最开始的已排序序列就是第一个元素，index=0 for (int i = 1; i &lt;= lastIndex; i++) { int temp = in[i]; //待比较元素 //注意i不能比1小，否则就会数组越界 while (i &gt;= 1 &amp;&amp; in[i - 1] &gt; temp) { //已排序序列[0,i)，最大下标i - 1 //i - 1位置元素大于待比较元素，i - 1位置元素后移 in[i] = in[i - 1]; i--; } //退出循环说明找到了合适的位置 in[i] = temp; } return in; } 3.1 希尔排序（O(NlogN)）/缩小增量排序 希尔排序（Shell Sort）是一种改进的插入排序，也成为缩小增量排序，1959年由Donald Shell提出。希尔排序采用了分治的思想，将原序列分为若干个子序列，对子序列分别进行插入排序，所以它的时间复杂度也理所应当是O(NlogN) 初始增量gap = len / 2，随后每次循环gap = gap / 2，直到减为1，循环终止。增量gap的意义是将序列分为多少子序列。 希尔排序存在非相邻元素交换位置，所以希尔排序是不稳定排序。 如图： 初始分组gap = len / 2 = 5，将原序列分为5组，要求每组元素之间间隔尽可能大，所以是{i, i + gap, i + 2 gap, …, i + n gap} 对5组子序列分别进行插入排序，将较小的元素交换到前面 交换完后，gap /= 2，将原序列重新分为2组，要求每组元素之间间隔尽可能大，所以是{i, i + gap, i + 2 gap, …, i + n gap} 对2组子序列分别进行插入排序，将较小的元素交换到前面 gap = 2 / 1 = 1，进行最后一次插入排序，结束循环 //希尔排序 public static int[] shellSort(int[] in) { int gap = in.length &gt;&gt; 1; //初始值，gap = len / 2 while (gap &gt; 0) { //从gap开始是因为默认[0,gap)是排好序的 //即每个子序列第一个元素是排好序的，一共gap个元素 //将序列分为gap组，对子序列进行插入排序 for (int i = gap; i &lt; in.length; i++) { int temp = in[i]; //限制了gap&gt;0，所以只需要 i-gap&gt;=0 而非 1 while ((i - gap &gt;= 0) &amp;&amp; (in[i - gap] &gt; temp) ) { in[i] = in[i - gap]; i -= gap; //每次跨度为一个gap } //退出循环说明找到了合适位置 in[i] = temp; } gap = gap &gt;&gt; 1; //gap = gap / 2 } return in; } 希尔排序 vs 插入排序：插入排序是稳定的，希尔排序不稳定；希尔排序比较次数和移动次数都要明显小于插入排序，N越大越明显；希尔排序不适用于链式结构 4.归并排序（O(NlogN)） 合并两个有序子序列的过程：创建一个和两个字序列长度和等长的序列，分别用一个指针指向两个子序列的头部，将两个子序列头部较小的那个加入到新序列，最后一个序列全部被加入新序列，就可以把另一个序列剩下的元素加入新序列。所以归并排序需要额外的内存空间 //合并两个有序子序列 //@params: left[] 左子序列 //@params: right[] 右子序列 public static void merge(int[] left, int[] right) { //结果序列，用于合并两个子有序序列 int[] rst = new int[left.length + right.length]; //左子序列、右子序列、总序列当前位置 int l = 0, r = 0, curr = 0; //遍历，直到某个子序列被遍历完，将较小的放前面 while (l &lt; left.length &amp;&amp; r &lt; right.length) { if (left[l] &lt; right[r]) { rst[curr] = left[l]; l++; curr++; }else{ rst[curr] = right[r]; r++; curr++; } } //剩余序列直接加入结果序列 while(l &lt; left.length) { rst[curr] = left[l]; l++; curr++; } while (r &lt; right.length) { rst[curr] = right[r]; r++; curr++; } return rst; } 归并排序（Merge Sort）利用了分治的思想，将序列不断进行二分，直到每组子序列只剩下两个元素（“分”），然后对这两个元素进行排序（“治”），最后将所有子序列两两进行合并，合并时重新排序（“合”），所以时间复杂度是O(NlogN) 归并排序只涉及相邻元素之间的交换，所以是稳定性排序 //归并排序：递归地使用二分法，将一个序列分解为两个子序列，直到子序列只剩下一个元素 //@params: in[] public static int[] mergeSort(int[] in) { //退出递归的条件：子序列只剩下一个元素 if(in == null || in.length &lt; 2) return in; int mid = in.length &gt;&gt; 1; //从中间将序列切分 //Arrays.copyOfRange(int[] a, int from, int to); 复制范围[from,to) int[] left = Arrays.copyOfRange(in, 0, mid); //不包括mid int[] right = Arrays.copyOfRange(in, mid, in.length); //递归调用mergeSort，然后将结果merge合并 return merge(mergeSort(left), mergeSort(right) ); } 测试： int[] in = {999, 1, 2, 4, 3, -1, 0, 0}; System.out.println(&quot;归并排序： &quot; + Arrays.toString(mergeSort(in))); //归并排序： [-1, 0, 0, 1, 2, 3, 4, 999] 5.快速排序（O(NlogN)） 参考了https://cloud.tencent.com/developer/article/1403566，说的很详细。 快速排序（Quick Sort）的中心思想是每次选取一个基准值（pivot），然后通过比较与交换，使得pivot左边的元素都小于pivot，pivot右边的元素都大于pivot；然后再通过二分法，对pivot左右的子序列分别进行快排。所以快排的时间复杂度是O(NlogN) pivot一般直接选择最左元素 交换pivot左右元素用到了快慢指针法——快指针从右往左遍历，直到找到比pivot小的元素；慢指针从左往右遍历，直到找到比pivot大的元素。由于我们的目的是让左边的更小，右边的更大，所以我们将快慢指针元素进行交换（交换之前要判断慢指针是否超过了快指针）。 如下图： 基准值是最左端元素6。慢指针i，从左往右；快指针j，从右往左 j先走，当遇到比基准值小的元素时停止（5&lt;6）；然后i再走，遇到比基准值大的元素时停止（7&gt;6） 如果慢指针没有超过快指针，就将快慢指针所在元素进行交换 重复以上步骤，直到快慢指针相遇，将快慢指针所在位置元素与基准值进行交换，基准值指针指向快慢指针所在位置 交换完成后，基准值左边的元素就都小于基准值，基准值右边的元素都大于基准值 以上操作都是相对的，如果pivot选择了最右元素，那么快指针就应该是从左往右遍历的那个 递归地对基准值左右序列进行快排，直到元素全部有序。退出递归的条件——子序列只剩下一个元素，即存在low &gt; high 同样是上述序列{6,1,2,7,9,3,4,5,10,8}，如果慢指针i先走会发生什么?（1）pivot=6，i=7&gt;6，j=5&lt;6，交换i与j：{6,1,2,&quot;5&quot;,9,3,4,&quot;7&quot;,10,8}；（2）i=9&gt;6，j=4&lt;6，交换i与j：{6,1,2,5,&quot;4&quot;,3,&quot;9&quot;,10,8}；（3）i=9=j，交换i/j与pivot：{&quot;9&quot;,1,2,5,4,3,&quot;6&quot;,10,8}，9&gt;6，很明显结果不对。结论：如果快指针先走，可以保证快慢指针相遇时元素值小于pivot，交换过来后可以保证pivot左边元素都小于pivot；但是如果慢指针先走，很可能相遇时元素值就大于pivot，交换后pivot左边就会存在比pivot大的元素。 public static void quickSort(int[] in, int low, int high) { //退出递归条件：子序列只有一个元素，此时low = high if(low &gt; high) return; int pivot = in[low]; //基准值，选最左边元素 int quick = high; //快指针，比慢指针先走一步，从右往左 int slow = low; //慢指针，从左往右 //当quick遇到了比pivot小的元素， //同时slow遇到了比pivot大的元素，那么就交换两个元素 while (slow &lt; quick) { //快指针要先走一步 //快指针向左，直到找到比pivot小的元素 while (in[quick] &gt;= pivot &amp;&amp; slow &lt; quick) { quick--; } //慢指针往右，直到找到比pivot大的元素 while (in[slow] &lt;= pivot &amp;&amp; slow &lt; quick) { slow++; } //需要再次判断slow是否已经遇到或超过了quick if (slow &lt; quick) { //交换两个元素 —— 可以肯定slow!=quick，是不同元素， //所以可以用异或交换两个元素 in[slow] = in[slow] ^ in[quick]; in[quick] = in[slow] ^ in[quick]; in[slow] = in[slow] ^ in[quick]; } } //将快慢指针所在位置元素与基准值进行交换 //slow与quick相遇的位置，就是基准值指针应该在的位置 in[low] = in[slow]; in[slow] = pivot; //slow或者quick就是新的pivot，左边元素都比它小，右边元素都比它大 //递归对pivot的左右序列进行快排 quickSort(in, low, slow - 1); //基准值不需要再排序，所以是slow-1 quickSort(in, slow + 1, high); //基准值不需要再排序，所以是slow+1 } 测试： int[] in = {999, 1, 2, 4, 3, -1, 0, 0}; quickSort(in, 0, in.length - 1); System.out.println(Arrays.toString(in)); //结果为：[-1, 0, 0, 1, 2, 3, 4, 999] 5.1 彩虹排序（NlogK，K是元素种类）彩虹排序适用于序列中元素种类是已知常数的情况。 彩虹排序（Rainbow Sort）是一种变种的快排，快排是从元素N中选择基准值进行分治，所以时间复杂度是O(NlogN)，而彩虹排序则是从元素种类K中选择基准值进行分治，所以时间复杂度是O(NlogK)，而K是常数。 具体的分治策略是：递归地从种类K中选择一个基准值，每次使得基准值左边的种类编码小于基准值，右边的种类编码大于基准值 结束递归的条件： 普通快排的结束递归条件：序列中只有一个元素，low == high（或者low &gt; high） 彩虹排序中额外的结束递归条件：序列中只有一种元素，elementFrom == elementTo（或者elementFrom &gt; elementTo） elementFrom、elementTo是指子序列（下标从start到end）中元素种类从第elementFrom种到第elementTo种，即元素种类范围。 参考LintCode 143. Sort Colors II这题，看看彩虹排序的实际应用： /** * @param colors: A list of integer * @param k: An integer * @return: nothing */ public static void sortColors2(int[] colors, int k) { if (colors == null || colors.length == 0) return; rainbowSort(colors, 0, colors.length - 1, 1, k); } //彩虹排序 //@params: colors[] 输入序列，包含从colorFrom到colorTo种类的颜色 //@params: start 子序列开始位置 //@params: end 子序列结束位置 //@params: colorFrom 颜色种类开始位置 //@params: colorTo 颜色种类结束位置 private static void rainbowSort(int[] colors, int start, int end, int colorFrom, int colorTo) { //结束递归的条件： // 1.传统快排结束条件：子序列只有一个元素； // 2.彩虹排序结束条件：子序列只有一种元素 if (start == end || colorFrom == colorTo) return; //中间颜色，即基准值pivot int colorMid = (colorFrom + colorTo) &gt;&gt; 1; int left = start, right = end; while (left &lt;= right) { //找到基准值左边大于基准值的元素 while (left &lt;= right &amp;&amp; colors[left] &lt;= colorMid) left++; //找到基准值右边小于基准值的元素 while (left &lt;= right &amp;&amp; colors[right] &gt; colorMid) right--; //再次判断，如果此时left指针没有超过right指针，就交换两个位置元素 if (left &lt;= right) { //可能相等，不能用异或 int temp = colors[left]; colors[left] = colors[right]; colors[right] = temp; left++; right--; } } //由于基准值选择的是中间位置，所以不需要将基准值交换到left所在位置 rainbowSort(colors, start, right, colorFrom, colorMid); rainbowSort(colors, left, end, colorMid + 1, colorTo); //基准值可以不作为子序列参与下一轮循环 } 测试： public static void main(String[] args) { int[] in = {3,2,2,1,4}; sortColors2(in, 4); System.out.println(Arrays.toString(in)); //[1,2,2,3,4] } 6.堆排序（O(N + KlogN)，K是排序序列长度）如果想得到一个序列中第K个最小元素之前的部分序列，最好采用堆排序！！！ 堆排序存在非相邻元素之间的交换，所以是非稳定排序 堆的特定： 堆是一棵完全二叉树。可以用数组表示，节点k有如下特点：父节点为(k-1)/2，左孩子为2k + 1，右孩子为2k + 2。 如果是大根堆，那么对于任何节点，其父节点都会比所有子节点大；如果是小根堆，那么对于任何节点，其父节点都会比所有子节点小 参考上图，理解了下面3个问题，也就理解了堆排序： 给定一个数组表示的满二叉树，如何构建一个堆？或者说，对一个堆进行了修改后，如何保证修改后的序列仍是一个堆？ heapify：对于任意节点来说，堆都有父亲节点大于（或小于）左右儿子的特点，所以，对于任意节点，将其与其左右儿子比较大小，将最大的元素替换到父亲节点，对替换下去的节点重复进行此操作，即可将满二叉树构建成堆。 比如说上图，对于5-7-8这棵子树来说，5&lt;8，所以将5和8交换位置，然后重新对替换下去的5节点进行heapify //heapify：将满二叉树构建为堆 //@param: tree[] 表示堆的数组 //@param: n 节点总数 //@param: i 对哪个节点进行heapify public static void heapify(int[] tree, int n, int i) { if(i &gt;= n) return; //结束递归条件：建堆节点下标超过节点总数，i&gt;=n //根据满二叉树的特点，有： int left = 2 * i + 1; //左子树 int right = 2 * i + 2; //右子树 //将父亲、左右子树3者中最大的数替换到父亲节点 int max = i; //注意left 和 right不能越界 if(left &lt; n &amp;&amp; tree[left] &gt; tree[max]) max = left; if (right &lt; n &amp;&amp; tree[right] &gt; tree[max]) max = right; if(max != i) { //如果父亲节点就是最大节点，就不需要重新建堆了 //交换max和i的元素 tree[max] = tree[max] ^ tree[i]; tree[i] = tree[max] ^ tree[i]; tree[max] = tree[max] ^ tree[i]; //对替换下去的节点重新建堆 heapify(tree, n, max); } } 通过步骤1，我们有了将一个修改后的堆还原成堆的能力，那么给定一个数组表示的满二叉树，如何构建出初始的堆？ 我们可以从树的倒数第二层（h-1层）逆序地对每个节点进行heapify操作，直到根节点，这样我们就能得到一个初始堆。 为什么不从树的倒数第一层（h层）开始heapify呢？因为倒数第一层没有子节点，本身就是满二叉树，没有heapify的必要。 那么如何确定倒数第二层的下标呢？我们知道满二叉树中，k节点的父亲节点是(k-1)/2，我们可以确定倒数第一层的最后一个节点（即数组尾部），该节点的父亲节点正好就位于倒数第二层，这就是我们heapify的起点//初始建堆 //@params: tree[] 满二叉树 //@params: n 节点总数 public static void buildHeap(int[] tree, int n) { int last = tree.length; int parent = (last - 1) &gt;&gt; 1; //倒数第二层 for(int i = parent; i &gt;= 0; i--) { heapify(tree, n, i); } } 现在我们有了一个初始堆，有了能够将更改后的堆构建成新堆的能力，如何进行堆排序？ 堆的特点是父亲节点大于（或小于）儿子节点，那么其根节点必定是最大的（最小的），也就是说我们每次构建好堆，都能得到一个剩余元素的最大值（最小值） 将根节点（最大值/最小值）与堆尾元素（也就是数组队尾）进行交换，然后将堆尾剔除并记录下来（当然这是逻辑上的剔除，实际上你可以在heapify的时候不传入堆尾即可），并对剩余元素重新进行heapify。重复此步骤，直到已排序的序列长度满足要求。//堆排序 //@params: tree[] 满二叉树 //@params: n 节点总数 public static void heapSort(int[] tree, int n) { //构建初始堆 buildHeap(tree, n); //如果只需要k个有序序列，可以提前结束循环 for(int i = n - 1; i &gt;= 0; i--) { //将根节点与堆尾进行交换 int temp = tree[i]; tree[i] = tree[0]; tree[0] = temp; //剔除堆尾的最大值，对剩余元素重新进行heapify heapify(tree, i, 0); } } 归并排序 vs 快排 vs 堆排序 如果从空间复杂度来考虑，首选堆排序，然后是快排，最后是归并排序（需要额外的内存空间） 如果是从稳定性来考虑，应选择归并排序，因为快排和堆排序并不稳定 如果从平均情况下的排序速度来考虑，应该选择快排 7.基数排序（O(N*D)，D为位数，N为元素个数） 通过对排序的N个元素进行若干趟“分配”与“收集”来实现排序 基数排序（Radix Sort）不需要交换元素位置，所以是稳定性排序 基数排序效率与初始序列是否有序没有关联 在基数排序中，对于任何位数上的基数进行装桶操作时，都需要n + r个临时空间 任何一个阿拉伯数字，它的各个位数上的基数都是以0 ~ 9 来表示的，我们将0 ~ 9视为10个桶。如：给定序列{50,123,543,187,49,30,0,2,11,100} 首先根据个位数元素分到指定的桶中。 将桶中元素按顺序依次弹出，即{50,30,0,100,11,2,123,543,187,49} 再根据十位数将元素分到指定桶中。 将桶中元素按顺序依次弹出，即{0,100,2,11,123,30,543,49,50,187} 再根据百位数将元素分到指定桶中。 将桶中元素按顺序依次弹出，此时元素就已经有序了 //基数排序 //不考虑负数的情况 public static int[] radixSort(int[] in) { int len = in.length; if (len &lt; 2 || in == null) return in; //0~9：10个桶，每一个桶是一个不定长的ArrayList ArrayList&lt;ArrayList&lt;Integer&gt;&gt; buckets = new ArrayList&lt;ArrayList&lt;Integer&gt;&gt;(); for (int i = 0; i &lt; 10; i++) buckets.add(new ArrayList&lt;Integer&gt;()); //找出序列中的最大值——不能用排序算法，不然还基数排序个什么劲？ int max = in[0]; for (int i = 1; i &lt; len; i++) max = in[i] &gt; max ? in[i] : max; //根据最大值，判断位数——即需要循环入桶、出桶的次数 int digit = 0; while (max != 0) { max /= 10; digit++; } //入桶 &amp; 出桶 int mod = 10, div = 1; for (int i = 0; i &lt; digit; i++, mod *= 10, div *= 10) { //遍历序列，入桶 for (int j = 0; j &lt; len; j++) { int temp = (in[j] % mod) / div; //判断对应位的元素，存入桶中 //ArrayList API: T get(int index); &amp; add(T t); buckets.get(temp).add(in[j]); } //遍历所有桶，出桶 int[] newArray = new int[len]; //出桶序列 int cnt = 0; for (int outArrayIndex = 0; outArrayIndex &lt; buckets.size(); outArrayIndex++) { for (int inArrayIndex = 0; inArrayIndex &lt; buckets.get(outArrayIndex).size(); inArrayIndex++) { newArray[cnt++] = buckets.get(outArrayIndex).get(inArrayIndex); //等价于： //newArray[cnt] = buckets.get(outArrayIndex).get(inArrayIndex); //cnt++; } //记得出桶后要清空桶，不能影响下一次循环 buckets.get(outArrayIndex).clear(); } //出桶序列替换原序列 for (int j = 0; j &lt; len; j++) in[j] = newArray[j]; } return in; } 8.计数排序计数排序（Counting Sort） 9.桶排序桶排序（Bucket Sort） 10.拓扑排序 入度：指向节点的边的个数（比如图中节点1的入度就是0） 使用BFS进行拓扑排序 找到图中入度为0的节点，从图中移除 被移除节点指向的节点，入度减1 重复2、3 如果最后不存在入度为0的节点，说明图中有环，这时候拓扑排序无解","categories":[{"name":"算法","slug":"算法","permalink":"/categories/算法/"}],"tags":[{"name":"位运算","slug":"位运算","permalink":"/tags/位运算/"},{"name":"算法","slug":"算法","permalink":"/tags/算法/"},{"name":"递归","slug":"递归","permalink":"/tags/递归/"},{"name":"排序","slug":"排序","permalink":"/tags/排序/"},{"name":"分治法","slug":"分治法","permalink":"/tags/分治法/"},{"name":"冒泡排序","slug":"冒泡排序","permalink":"/tags/冒泡排序/"},{"name":"选择排序","slug":"选择排序","permalink":"/tags/选择排序/"},{"name":"插入排序","slug":"插入排序","permalink":"/tags/插入排序/"},{"name":"希尔排序","slug":"希尔排序","permalink":"/tags/希尔排序/"},{"name":"归并排序","slug":"归并排序","permalink":"/tags/归并排序/"},{"name":"堆排序","slug":"堆排序","permalink":"/tags/堆排序/"},{"name":"基数排序","slug":"基数排序","permalink":"/tags/基数排序/"},{"name":"计数排序","slug":"计数排序","permalink":"/tags/计数排序/"},{"name":"桶排序","slug":"桶排序","permalink":"/tags/桶排序/"},{"name":"快排","slug":"快排","permalink":"/tags/快排/"},{"name":"图","slug":"图","permalink":"/tags/图/"},{"name":"拓扑排序","slug":"拓扑排序","permalink":"/tags/拓扑排序/"},{"name":"BFS","slug":"BFS","permalink":"/tags/BFS/"},{"name":"队列","slug":"队列","permalink":"/tags/队列/"},{"name":"彩虹排序","slug":"彩虹排序","permalink":"/tags/彩虹排序/"},{"name":"双指针","slug":"双指针","permalink":"/tags/双指针/"},{"name":"ArrayList","slug":"ArrayList","permalink":"/tags/ArrayList/"},{"name":"Arrays","slug":"Arrays","permalink":"/tags/Arrays/"}],"keywords":[{"name":"算法","slug":"算法","permalink":"/categories/算法/"}]},{"title":"BIO / NIO / AIO","slug":"BIO-NIO-AIO","date":"2019-08-16T11:50:20.000Z","updated":"2019-12-14T07:05:23.683Z","comments":true,"path":"BIO-NIO-AIO/","link":"","permalink":"/BIO-NIO-AIO/","excerpt":"","text":"BIO &amp; NIO &amp; AIO（〇）同步vs异步、阻塞vs非阻塞同步vs异步 同步：发起一个调用后，被调用者未处理完请求之前，调用不返回 异步：发起一个调用后，立即收到被调用者的回应表示已经接收到请求，但是被调用者没有返回结果，会通过事件/回调等机制通知调用者结果 阻塞vs非阻塞 阻塞：调用方必须等待请求返回结果（即被挂起），不能从事其他任务 阻塞I/O线程处于线程的哪个状态呢？答案：RUNNABLE。因为它既没有等待notify()/notifyAll()，也不是由于synchronized被阻塞 线程池实现了伪异步I/O，但是底层仍然是BIO。 非阻塞：调用方在等待请求返回结果时，不会被挂起，可以从事其他任务 在网上看到了一个很贴切的比喻——烧开水：1.你妈妈叫你烧开水，你小时候比较笨，坐在开水壶前等水开，这是同步阻塞；2.等你大一点了，知道等水烧开的这段时间可以忙别的事情，你只需要时不时来看看水烧开了没有，这是同步非阻塞；3.后来你们家用上了水烧开会发出声音的壶，这样你就可以去干别的事情了，等到水开了它自己会发出声音提醒你，这就是异步非阻塞 （一）BIO同步阻塞I/O，数据的读取写入必须阻塞在一个线程内完成，不能应付高并发。 BIO设计的类有40多个，看似杂乱，但是其实都是从4个抽象类中派生来的。 Reader：字符输入流 InputStream：字节输入流 Writer：字符输出流 OutputStream：字节输出流 分类1.字符读取 - Reader 节点流： 文件操作：FileReader 管道操作：PipedReader 数组操作：CharArrayReader 处理流： 缓冲操作：BufferedReader 转化控制：InputStreamReader 2.字节读取 - InputStream 节点流： 文件操作：FileInputStream 管道操作：PipedInputStream 数组操作：ByteArrayInputStream 处理流： 缓冲操作：BufferedInputStream 基本数据类型操作：DataInputStream 对象序列化操作：ObjectInputStream SequenceInputStream 3.字符写出 - Writer 节点流： 文件操作：FileWriter 管道操作：PipedWriter 数组操作：CharArrayWriter 处理流： 缓冲操作：BufferedWriter 转化控制：OutputStreamWriter 打印控制：PrintWriter 4.字节写出 - OutputStream 节点流： 文件操作：FileOutputStream 管道操作:PipedOutputStream 数组操作：ByteArrayOutputStream 处理流： 缓冲操作：BufferedOutputStream 基本数据类型操作：DataOutputStream 对象序列化操作：ObjectOutputStream 打印操作：PrintStream demo//BIO：try-catch-finally BufferedReader br = null; String sCurrentLine = null; try{ br = new BufferedReader(new FileReader(&quot;C:\\\\Users\\\\19047535\\\\IdeaProjects\\\\batal\\\\src\\\\io\\\\text.txt&quot;)); while ((sCurrentLine = br.readLine()) != null) { System.out.println(sCurrentLine); } }catch (IOException e){ e.printStackTrace(); }finally { try{ if (br != null) br.close(); }catch (IOException e){ e.printStackTrace(); } } 使用try-with-resources取代try-catch-finally： //BIO：try-with-resource try(BufferedReader br2 = new BufferedReader( new FileReader(&quot;C:\\\\Users\\\\19047535\\\\IdeaProjects\\\\batal\\\\src\\\\io\\\\text.txt&quot;))) { while ((sCurrentLine = br2.readLine()) != null) { System.out.println(sCurrentLine); } }catch (IOException e){ e.printStackTrace(); } 缺点 &amp; 解决方案：线程池每一个请求需要一个I/O线程进行处理，同时线程的创建、销毁需要消耗系统资源，加重了系统的负担。 解决方法：通过线程池复用线程 线程池本质上仍然是BIO （二）NIO同步非阻塞I/O，支持高并发、高负载。应用操作之后直接返回，不会堵塞在那里。 NIO 与 BIO 的区别 BIO是面向流的，NIO是面向缓冲区的 BIO是阻塞的，NIO是非阻塞的 NIO有选择器而BIO没有 读 &amp; 写 读：创建一个缓冲区，然后请求通道读取数据 写：创建一个缓冲区，填充数据，然后要求通道写入数据 核心组件1.缓冲区（Buffer）Buffer的本质是一块内存区域，用于和Channel进行交互——将Buffer中的数据写入Channel，或是从Channel读取数据到Buffer。 （1）属性 capacity：buffer容量，一旦设置就不能更改 position：下一个读/写元素的位置，通过get/put更新 limit：buffer中不能读/写的第一个元素，换句话来说就是buffer中存活元素的个数 mark：buffer中一个记录的位置，调用mark()可以让mark = position，调用reset()可以让position = mark 0 &lt;= mark &lt;= position &lt;= limit &lt;= capacity （2）常见方法 Buffer clear() Buffer flip() Buffer rewind() Buffer position(int newPosition) （3）使用缓冲区 分配缓冲区：Buffer.allocate(capacity)`java//字节缓冲区ByteBuffer buffer = ByteBuffer.allocate(28); //字符缓冲区CharBuffer charBuffer = CharBuffer.allocate(100);//从原有字符数组中分配缓冲区char[] charArr = new char[100];CharBuffer charBuffer2 = CharBuffer.wrap(charArr);CharBuffer charBuffer2 = CharBuffer.wrap(charArr, 12, 43); //分配一部分 2. 写入数据到缓冲区：`Channel.read(Buffer)`/`Buffer.put()` * 从`Channel`中读数据到`Buffer` ```java int bytesRead = inChannel.read(buffer); 通过put写数据buffer.put(127); 从缓冲区读取数据：Buffer.get() 读写反转：调用Buffer.flip()可以让limit = position; position = 0，从读模式切换到写模式 查询剩余元素：Buffer.hasRemaining()，如果buffer非空，返回true 清空buffer：Buffer.clear() 等价于： for(int i = 0; buffer.hasRemaining(), i++){ buffer.get(); } 2.通道（Channel） FileChannel SocketChannel ServerSocketChannel DatagramChannel RandomAccessFile raf = new RandomAccessFile(&quot;file&quot;, &quot;r&quot;); FileChannel fc = raf.getChannel(); SocketChannel sc = SocketChannel.open(); sc.connect(new InetSocketAddress(&quot;host&quot;, port)); ServerSocketChannel ssc = ServerSocketChannel.open(); ssc.socket().bind(new InetSocketAddress(localport)); DatagramChannel dc = DatagramChannel.open(); //channel.read() //channel.write() //channel.close() （1）多缓冲区操作 Scatter：将1个Channel中的数据分散到N个Buffer中去 public interface ScatteringByteChannel extends ReadableByteChannel{ public long read(ByteBuffer[] dsts) throws IOException; public long read(ByteBuffer[] dsts, int offset, int length) throws IOException; } Gather：将N个Buffer中的数据按照顺序发送到一个Channel public interface GatheringByteChannel extends ReadableByteChannel{ public long write(ByteBuffer[] srcs) throws IOException; public long write(ByteBuffer[] srcs, int offset, int length) throws IOException; } （2）多通道之间数据传输 transferFrom()：把数据从通道源传输到FileChannel transferTo()：将FileChannel数据传输到其他通道 public abstract class FileChannel extends AbstractChannel implements ByteChannel, GatheringByteChannel, ScatteringByteChannel { // There are more other methods public abstract long transferTo (long position, long count, WritableByteChannel target); public abstract long transferFrom (ReadableByteChannel src, long position, long count); } 3.选择器/多路复用器（Selector）通过单线程的Selector检查多个Channel是否处于可读/可写，从而实现单线程管理多个通道。 （1）优点Selector通过多路复用避免了多线程，从而减少了线程上下文切换的开销。 （2）使用选择器 创建：Selector.open() Selector selector = Selector.open(); 注册Channel到Selector：Channel.register(...) channel.configureBlocking(false); //通道必须是非阻塞的 SelectionKey key = channel.register(selector, SelectionKey.OP_READ); //一个SelectionKey表示了一个Selector和一个Channel之间的绑定关系 demopublic static void main(String[] args) throws IOException{ //NIO System.out.println(&quot;============NIO============&quot;); RandomAccessFile file = new RandomAccessFile(&quot;C:\\\\Users\\\\19047535\\\\IdeaProjects\\\\batal\\\\src\\\\io\\\\text.txt&quot;, &quot;r&quot;); //通过文件打开channel FileChannel channel = file.getChannel(); //分配buffer ByteBuffer buffer = ByteBuffer.allocate(1024); while (channel.read(buffer) &gt; 0){ buffer.flip(); for (int i = 0; i &lt; buffer.limit(); i++) { System.out.println((char)buffer.get()); } buffer.clear(); } channel.close(); file.close(); } 内存映射文件内存映射文件（memory-mapped file）能让你创建/修改那些大到无法读入内存的文件。有了内存映射文件，你就可以认为文件已经全部读入内存，然后把它当作一个非常大的数组来访问。内存映射文件虽然最后还是需要从磁盘读取文件，但是它不需要将数据读取到OS的内核缓冲区，而是直接将进程的用户私有空间和文件磁盘地址进行映射，就好像是从内存中读/写文件一样，所以才快。 （三）AIO异步非阻塞I/O：应用操作之后直接返回，不会堵塞在那里，当后台处理完成，操作系统会通知相应的线程进行后续的操作。 AIO包括Sockets和Files两部分的异步通道接口及实现，并尽量使用OS提供的原生本地I/O功能进行实现。 AIO 和 NIO 的区别 NIO是OS有了I/O资源后，通知调用方（I/O线程）执行I/O操作； AIO是直接将I/O操作以函数的形式传给OS，有资源的时候由OS代替执行，只以Future或Callback的形式返回一个异步的结果给调用方（I/O线程）。 AIO的I/O操作1.Future提交一个I/O操作请求，返回一个Future。然后调用方可以通过Future.get()进行检查，确认它是否完成，或者阻塞I/O操作直到正常完成后超时异常。 //异步通道 AsynchronousSocketChannel ch = AsynchronousSocketChannel.open(); //分配缓冲区 ByteBuffer buffer = ByteBuffer.allocateDirect(8192); //异步 读 Future&lt;Integer&gt; result = ch.read(buffer); try{ //通过Future.get()异步获取执行结果 int bytesRead = result.get(); //Success if(bytesRead == -1) return; }catch(ExecutionException e) { //Fail } 注意：Future.get()是同步的，谨慎使用。 2.Callback提交一个I/O操作请求，并且指定一个CompletionHandler。当异步I/O完成后，发送一个请求，此时CompletionHandler对象的completed/failed方法将会被回调。 public interface CompletionHandler&lt;V, A&gt; { //当操作完成后被调用 //V result：操作结果 //A attachment：提交操作请求时的参数 void completed(V value, A attachment); //当操作失败后被调用 //Throwable exc：失败原因 void failed(Throwable exc, A attachment); } 3.Future 和 Callback 的区别 Future是调用方主动异步查询操作成功/失败，然后调用方再根据操作结果实现不同逻辑 Callback是调用方直接将成功（completed）/失败（failed）时对应的操作以函数的方式传递给操作方，操作成功/失败后，操作方异步回调对应的函数 AsynchronousFileChannel：异步文件通道AsynchronousFileChannel使数据可以异步读写。","categories":[{"name":"Java基础","slug":"Java基础","permalink":"/categories/Java基础/"}],"tags":[{"name":"多线程","slug":"多线程","permalink":"/tags/多线程/"},{"name":"Java Base","slug":"Java-Base","permalink":"/tags/Java-Base/"},{"name":"BIO","slug":"BIO","permalink":"/tags/BIO/"},{"name":"NIO","slug":"NIO","permalink":"/tags/NIO/"},{"name":"线程池","slug":"线程池","permalink":"/tags/线程池/"},{"name":"Future","slug":"Future","permalink":"/tags/Future/"}],"keywords":[{"name":"Java基础","slug":"Java基础","permalink":"/categories/Java基础/"}]},{"title":"GayHub上一些有趣的项目【持续更新~】","slug":"fun-with-GayHub","date":"2019-08-04T09:47:11.000Z","updated":"2019-12-14T02:56:58.272Z","comments":true,"path":"fun-with-GayHub/","link":"","permalink":"/fun-with-GayHub/","excerpt":"","text":"GayHub上一些有趣的项目 （一）reveal-md：使用.md来做PPT详细信息见reveal-md项目地址。相似的还有用HTML做PPT展示的reveal.js。 安装npm install -g reveal-md 使用reveal-md path/demo.md，其中，path/demo.md是你的Markdown文件地址，可以使用本地地址，也可以使用URL。使用如下的Markdown文件： # Title * Point 1 * Point 2 --- ## Second slide &gt; Best quote ever. Note: speaker notes FTW! 效果如图： 通过solarized主题使用reveal-md path/demo.md --theme solarized效果如图： （二）Logoly.Pro：不正经的Logo生成器该项目可以根据你输入的文字创建PornHub风格的Logo（知道PornHub是什么的坏孩子请面壁思过）。GitHub仓库地址Logoly.Pro在线版 比如，我输入DragonBaby，然后点击Export：修改theme/_config.yaml的avatar属性，就可以将导出的图片作为我个人博客的头像啦~ （三）emoji-mosaic：将图片转成emoji标签马赛克GitHub仓库地址emoji-mosaic在线版（有一说一，这个在线版属实简约嗷……） 效果图如下： （四）gifi：在你执行npm install时放gif图 gifi：注意它不是在你的终端播放，而是浏览器打开gif图播放，所以酌情安装。 （五）bash-insulter：在输入错误bash命令时进行羞辱的脚本Github项目地址。 git clone首先你服务器需要安装了Git。通过git clone https://github.com/hkbakke/bash-insulter bash-insulter命令克隆项目到本地。 将下载内容移动到/etc目录下sudo cp bash-insulter/src/bash.command-not-found /etc/ 修改/etc/bash.bashrc文件vim /etc/bash.bashrc打开文件，在末尾添加： #Bash Insulter if [ -f /etc/bash.command-not-found ]; then . /etc/bash.command-not-found fi source /etc/bash.bashrc 使修改生效source /etc/bash.bashrc 生效后，输入错误的bash命令就会被狠狠羞辱： （六）the-fuck：输入错误bash命令后通过fuck进行修正 the-fuck项目地址 Mac下通过brew install thefuck安装 vim ~/.bashrc，修改： eval &quot;$(thefuck --alias)&quot; source ~/.bashrc使之生效，输入错误bash命令后通过fuck命令即可进行修正，如： (base) bogon:~ dragonbaby308$ git brach git: &#39;brach&#39; is not a git command. See &#39;git --help&#39;. The most similar command is branch (base) bogon:~ dragonbaby308$ fuck git branch [enter/↑/↓/ctrl+c] （七）12306抢票 12306抢票 未测试。 （八）变声器 变声器 未测试。 （九）狗屁不通文章生成器 狗屁不通文章生成器-GitHub地址 狗屁不通文章生成器-网页版","categories":[{"name":"GitHub","slug":"GitHub","permalink":"/categories/GitHub/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"/tags/Linux/"},{"name":"GitHub","slug":"GitHub","permalink":"/tags/GitHub/"},{"name":"Git","slug":"Git","permalink":"/tags/Git/"},{"name":"Shell","slug":"Shell","permalink":"/tags/Shell/"},{"name":"Vim","slug":"Vim","permalink":"/tags/Vim/"},{"name":"前端","slug":"前端","permalink":"/tags/前端/"},{"name":"Markdown","slug":"Markdown","permalink":"/tags/Markdown/"},{"name":"Node.js","slug":"Node-js","permalink":"/tags/Node-js/"},{"name":"Vue.js","slug":"Vue-js","permalink":"/tags/Vue-js/"},{"name":"Fun!!!!!!!","slug":"Fun","permalink":"/tags/Fun/"},{"name":"JS","slug":"JS","permalink":"/tags/JS/"},{"name":"Homebrew","slug":"Homebrew","permalink":"/tags/Homebrew/"},{"name":"Mac","slug":"Mac","permalink":"/tags/Mac/"}],"keywords":[{"name":"GitHub","slug":"GitHub","permalink":"/categories/GitHub/"}]},{"title":"Java中的位运算","slug":"bit-operation","date":"2019-07-30T04:44:54.000Z","updated":"2019-12-14T02:55:49.364Z","comments":true,"path":"bit-operation/","link":"","permalink":"/bit-operation/","excerpt":"","text":"Java中的位运算（一）移位运算左移：&lt;&lt;左移1位相当于乘2，x &lt;&lt; n等价于x * (2 ^ n)。 int i = 4; //100 i = i &lt;&lt; 2; //10000 = 16 = 4 * (2 ^ 2) 应用：乘法对于h = 2 ^ n - 1来说，其中n为整数，有：h * a =(2 ^ n - 1) * a =(a * 2 ^ n) - a =(a &lt;&lt; n) - a 有符号右移：&gt;&gt;右移1位相当于除2，x &gt;&gt; n等价于x / 2n。 int i = 4; //100 i = i &gt;&gt; 2; //001 = 1 = 4 / (2 ^ 2) 无符号右移：&gt;&gt;&gt;应用： 求某m位数c的高n位：c &gt;&gt;&gt; (m - n)如：求32位int型变量c的高16位 —— c &gt;&gt;&gt; 16 （二）逻辑运算按位与：&amp;【有0则0】1 &amp; 0 = 01 &amp; 1 = 10 &amp; 0 = 0 1. 判断奇偶n &amp; 1 == 1则为奇数，n &amp; 1 == 0则为偶数 // 1 的二进制为：000...0001 int odd = 5; //101 奇数最后一位必为1，与1按位与，一定是000...0001 int even = 6; //110 偶数最后一位必为0，与1按位与，一定是000...0000 //odd &amp; 1 = 1，奇数 //even &amp; 1 = 0，偶数 2. 判断是否是2的整数次幂n &amp; (n-1) == 0是2 ^ n，n &amp; (n-1) == 1不是2 ^ n //请看： //4：100 //3：011 //8：1000 //7：0111 //可知： //2 ^ n的二进制码必定是1000...000的格式，除了首位为1，其他都为0 //2 ^ n - 1的二进制码必定是0111...111的格式，除了首位为0，其他都为1 int isTrue = 16; //10000 int isFalse = 15; //01111 //isFalse - 1 = 14 ，二进制01110 //isTrue &amp; (isTrue - 1) = 0，2 ^ n //isFale &amp; (isFalse - 1) = 01110，非2 ^ n 3. 对2的整数次幂取模m &amp; (n - 1)等价于m % n。 注意：n必须要是2 ^ n！！！并不所有数都可以。 // HashMap中获取元素下标 // 将key.hashCode()前16位与后16位异或，求出一个hash值，这一步是为了让元素分布更加均衡 int hash = (key == null) ? 0 : ((key.hashCode()) ^ (key.hashCode() &gt;&gt;&gt; 16)); // 将hash值对数组长度取模，将hash值映射成数组位置 int index = hash &amp; (len - 1); // 这也是为什么HashMap的容量一定要2 ^ n的原因 —— 方便位运算取模 4. 求某m位数的低n位：c &amp; ((1 &lt;&lt; (m - n)) - 1)如：求32位int型变量c的低16位 —— c &amp; ((1 &lt;&lt; 16 )- 1) 按位或：|【有1则1】1 | 1 = 11 | 0 = 10 | 0 = 0 1. HashMap中的应用：最小的2的幂次方//该方法可以保证返回一个能容纳cap的2的幂次方 static final int tableSizeFor(int cap) { int n = cap - 1; n |= n &gt;&gt;&gt; 1; n |= n &gt;&gt;&gt; 2; n |= n &gt;&gt;&gt; 4; n |= n &gt;&gt;&gt; 8; n |= n &gt;&gt;&gt; 16; return (n &lt; 0) ? 1 : (n &gt;= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + 1; } 我们以cap = 65（1000001）为例，那么n = 64（1000000） n &gt;&gt;&gt; 1 = 0100000 n |= n &gt;&gt;&gt; 1 = 1000000|0100000 = 1100000（96） n |= n &gt;&gt;&gt; 2 = 1100000|0011000 = 1111000（120） n |= n &gt;&gt;&gt; 4 = 1111000|0000111 = 1111111（127） n |= n &gt;&gt;&gt; 8 = 1111111|0000000 = 1111111（127） n |= n &gt;&gt;&gt; 16 = 1111111|0000000 = 1111111（127） n + 1 = 128 = 2 ^ 7 按位非：~【取反】按位异或：^【相同则0，相异为1】1 ^ 1 = 00 ^ 0 = 01 ^ 0 = 1 特点： 任何数和自己异或都是0：a ^ a = 0 0和任何数异或都是该数本身：0 ^ a = a 1. HashMap中的应用：扰动函数int hash = key.hashCode() ^ (key.hashCode() &gt;&gt;&gt; 16); //将高低16位进行异或，使得元素在HashMap上分布均匀 2. 不用临时变量交换两个数主要用到的原理就是a ^ (b ^ a) = b //交换a和b的值 //a = a + b; //b = a - b; //a = a - b; int a = -10; int b = 11; a = a ^ b; b = a ^ b; //(a ^ b) ^ b = a a = a ^ b; //(a ^ b) ^ (a ^ b) ^ b = b //交换后a = 11, b = -10 //注意a和b不能是同一对象！！！！！！！ 警惕以下情况——a和b出于某种原因，变成了同一个对象，那么以上代码都会出错： //a = 2 a = a + a; //4 a = a - a; //0 a = a - a; //0 //a = 0 a = a ^ a; //0 a = a ^ a; //0 a = a ^ a; //0 //a = 0","categories":[{"name":"Java基础","slug":"Java基础","permalink":"/categories/Java基础/"}],"tags":[{"name":"ARTSK","slug":"ARTSK","permalink":"/tags/ARTSK/"},{"name":"位运算","slug":"位运算","permalink":"/tags/位运算/"},{"name":"HashMap","slug":"HashMap","permalink":"/tags/HashMap/"},{"name":"String","slug":"String","permalink":"/tags/String/"}],"keywords":[{"name":"Java基础","slug":"Java基础","permalink":"/categories/Java基础/"}]},{"title":"树莓派入门","slug":"raspberry-pi","date":"2019-07-07T05:59:25.000Z","updated":"2019-12-14T02:58:16.063Z","comments":true,"path":"raspberry-pi/","link":"","permalink":"/raspberry-pi/","excerpt":"","text":"树莓派入门外设 之前某活动白嫖的Raspberry Pi 3B一个 32G Sandisk micro SD卡一张 读卡器一个 USB接口5V、2A充电器一个 HDMI线一条 HDMI显示器一个（我直接用的客厅的电视机） 键盘、鼠标 wifi模块一个（3B+及以上的不需要） 安装Raspbian系统Raspberry Pi官方推荐的系统是Raspbian，是Debian的定制版。推荐使用NOOBS（New Out Of the Box Software）安装系统。 下载NOOBS 注意选择NOOBS，而不是NOOBS LITE。NOOBS LITE不含系统，在安装时需要网络支持。 将SD卡格式化为FAT格式，我用的是DiskGenius 将NOOBS.zip解压到SD卡根目录 注意根目录需要的是如下图的详细内容，而不是一个NOOBS_v3_1_1的子文件夹。 插入SD卡，接通电源，打开树莓派 一路回车，就可以安装好系统。 SSH登录 点击左上角树莓图标，Preference -&gt; Raspberry Pi Configuration -&gt; Interfaces -&gt; SSH设置为Enabled，之后就可以通过SSH登录树莓派。我是用的是XShell。树莓派默认用户为pi，密码raspberrypi，登录后可以通过passwd修改密码。 ifconfig查看IP 连接","categories":[{"name":"Linux","slug":"Linux","permalink":"/categories/Linux/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"/tags/Linux/"},{"name":"Raspberry Pi","slug":"Raspberry-Pi","permalink":"/tags/Raspberry-Pi/"}],"keywords":[{"name":"Linux","slug":"Linux","permalink":"/categories/Linux/"}]},{"title":"Docker应用：使用NextCloud搭建私有云盘","slug":"docker-nextcloud","date":"2019-07-06T12:13:06.000Z","updated":"2019-12-14T02:56:42.945Z","comments":true,"path":"docker-nextcloud/","link":"","permalink":"/docker-nextcloud/","excerpt":"","text":"Docker应用：使用NextCloud搭建私有云盘连接服务器，安装Docker 首先你要有自己的服务器，并且要有连接服务器的工具。在《阿里云ECS上搭建私人Git仓库》一文中介绍了XShell的安装。 同时你需要在服务器上安装Docker，参考《Docker基础》。 如果你是用的是阿里云ECS，那么你还需要打开对应端口的权限，参考《阿里云ECS上安装Nginx》。 拉取镜像，创建NextCloud容器docker run -d -p yourHostPort:yourContainerPort nextcloud，其中yourHostPort是你想要打开的服务器端口，yourContainerPort是你想打开的容器端口，一般默认是80，这里我选择了8081:80。 docker run命令参数回顾：-d 后台运行-p 指定端口 hostPort:containerPort 如果没有pull镜像的话，docker run的时候会自动去pull最新的nextcloud镜像。 通过docker images命令可以查看下载好的镜像；通过docker ps -a命令可以查看创建的容器。 使用NextCloud使用URL:8081或IP:8081的方式登录，输入管理员账户、密码后，你的NextCloud云盘就创建成功了。 你可以下载对应的客户端对它进行操作。","categories":[{"name":"Docker","slug":"Docker","permalink":"/categories/Docker/"}],"tags":[{"name":"Docker","slug":"Docker","permalink":"/tags/Docker/"},{"name":"NextCloud","slug":"NextCloud","permalink":"/tags/NextCloud/"}],"keywords":[{"name":"Docker","slug":"Docker","permalink":"/categories/Docker/"}]},{"title":"Docker 、 k8s 基础","slug":"docker","date":"2019-07-01T05:21:30.000Z","updated":"2019-12-14T02:56:50.696Z","comments":true,"path":"docker/","link":"","permalink":"/docker/","excerpt":"","text":"Docker 、 k8s 基础 （一）镜像（创建容器） &amp; 容器（封装为镜像）镜像：目的内容的一个封装，不可以改变内容。容器：可以改变内容，相当于虚拟机，默认情况下彼此封闭。 一般我们做的，就是通过镜像创建容器；当我们改变了容器的内容之后，也可以重新将容器封装为镜像。 容器(Container) vs 虚拟机(VM)Docker项目的目标是实现轻量级的操作系统虚拟化解决方案。 区别 VM：VM是硬件层面上的虚拟化。一个VM包含了应用、必须的bin/lib库，同时每个VM都必须要有Guest OS，每个都高达数十MB。 容器：容器是OS层面上的虚拟化。一个容器只包含了应用和必须的bin/lib库，所有容器共享宿主机的Host OS，但是在独立的进程上运行，可以隔离性地使用系统资源。 底层原理：LXC(Linux Container)。namespace：每个容器有各自的命名空间，用于逻辑隔离。cgroup：每个容器在Linux中有自己的分组和权限，可以用于互不干扰地访问系统资源。 容器的优点 单个容器使用的是宿主机的OS，不包含自己的OS，所以容器要比VM更加轻量级，开销更小，开发、测试、部署都更快，迁移也更方便； 容器的启动可以在秒级实现，比VM快得多； 一台主机上可以运行数千个容器，对系统资源的利用率比VM高得多 （二）安装CentOS下，yum -y install docker即可。我的版本是Docker version 1.13.1, build b2f74b2/1.13.1。 （三）使用Docker服务的启动 &amp; 停止：systemctl start/stop docker启动：systemctl start docker停止：systemctl stop docker Docker的镜像搜索：searchdocker search keyword：根据关键字，在互联网搜索镜像。如：docker search ubuntu Docker的镜像下载：pulldocker pull imageName：根据镜像名下载镜像。如：docker pull docker.io/ubuntu。 Docker本地镜像查看：imagesdocker images：查看所有本地镜像 Docker容器的创建（基于镜像创建虚拟机） &amp; 命名：run –namedocker run -tid --name containerName imageID：可以通过docker images查看imageID，一般取前4位即可。如：docker run -tid --name DistributedCrawlerUbuntu 4c10。 docker run参数及其含义：-p 指定端口号-ti 以交互的方式创建-d 后台创建-tid 创建一个容器并运行，但不进入容器里面-e 设置环境变量-p 宿主端口：容器端口-v 宿主目录：容器目录，挂载容器数据卷 Docker容器启动docker start containerID/containerName：通过ID或者名称启动某个停止的容器 Docker容器的查看：ps -adocker ps -a：查看当前所有运行的容器 Docker容器的进入：attachdocker attach containerID：可以通过docker ps -a查看containerID，一般取前4位即可。 在运行的容器中执行命令：docker execdocker exec -it ContainerName + 命令，比如docker exec -it MongoDB bash。 Docker容器的不停止退出：ctrl + p + q + Enterctrl + p + q，按下回车，即可不停止容器但是退出。 基于容器封装为Docker镜像：commitdocker commit containerID imageName:version：将已有的容器封装为镜像，containerID可以通过docker ps -a获得。如：docker commit e4cc distributed_crawler:v1 （四）网络配置：run –link linkContainerNamedocker run -tid --name containerName --link linkContainerName iamgeID/Name：在创建容器时，使其与某个容器保持网络通畅。如： docker run -tid --name host1 distributed_crawler:v1 # 创建host1 docker run -tid --name host2 --link host1 distributed_crawler:v1 # 创建host2时，link host1 （五）DockerFileDockerFile是对镜像的源码级别的描述文件。 关键字如下： FROM 基础镜像：当前镜像是基于哪个镜像的 MAINTAINER 镜像维护者的姓名和邮箱 RUN 容器构建时需要的命令 EXPOSE 当前容器对外暴露的端口 WORKDIR 创建容器后，终端默认登录进来的工作目录，一个落脚点 ENV 构建容器的过程中设置环境变量，如Java、MySQL…… ADD 将host目录下的文件拷贝进镜像，且ADD命令会自动处理URL和解压tar包 COPY 类似ADD，拷贝文件和目录到镜像 VOLUME 容器数据卷，用于数据的持久化 CMD 指定一个容器启动时需要运行的命令；DockerFile中可以有多个CMD命令，但只有最后一个会生效，且CMD会被docker run之后的参数替换 ENTRYPOINT 指定一个容器启动时需要运行的命令 ONBUILD 当构建一个被继承的DockerFile是运行命令，子镜像继承父镜像后，父镜像中的ONBUILD被触发 （六）容器数据卷(volume)容器关闭后，数据需要共享和持久化，容器数据卷(volume)就是完成此功能的，它类似于Docker的移动硬盘。 特点 数据卷可以在容器之间共享或重用数据 卷中的更改直接生效。不管是在host还是container中数据卷中修改了内容，另一方都能同步收到更新，即使container已经退出也可以更新。 卷中的更改不会包含在镜像的更新中 卷的生命周期一直持续到没有容器使用它为止 如何添加容器数据卷 在DockerFile中的VOLUME属性下添加； 直接命令添加：docker run -it -v /hostPath:/containerPath imageName。其中hostPath是宿主机绝对路径目录；containerPath是容器内目录；imageName是镜像名。 挂载Read-Only的容器数据卷： docker run -it -v /hostPath:/containerPath:ro imageName如何查看已经挂载了哪些容器数据卷？ docker inspect containerID命令，查看Volumes属性下的对应关系 （七）Docker-Compose 参考https://blog.51cto.com/9291927/2310444 简介 Docker-Compose是Docker官方的开源项目，负责实现对Docker容器集群的快速编排。 Docker-Compose的默认配置文件为docker-compose.yml Docker-Compose允许用户通过一个docker-compose.yml文件来定义一组相关联的应用容器作为一个项目。 安装# 下载 sudo curl -L https://github.com/docker/compose/releases/download/1.23.0-rc3/docker-compose-`uname -s`-`uname -m` -o /usr/local/bin/docker-compose # 更改权限 sudo chmod +x /usr/local/bin/docker-compose # 查看版本 docker-compose version docker-compose.yml文件格式包含version、services、networks三大部分： services： image：指定服务的镜像名称/ID，如果本地不存在，会尝试拉取 command：覆盖容器启动后默认执行的命令 ports：以HOST:CONTAINER的格式进行端口映射 volumes：挂载数据卷容器 version: &#39;3&#39; services: elasticsearch: image: elasticsearch:7.3.1 environment: discovery.type: single-node ports: - &quot;9200:9200&quot; - &quot;9300:9300&quot; logstash: image: logstash:7.3.1 command: logstash -f /etc/logstash/conf.d/logstash.conf volumes: # 挂载logstash配置文件 - ./config:/etc/logstash/conf.d - /user/elk/logs/:/opt/build/ ports: - &quot;5000:5000&quot; kibana: image: kibana:7.3.1 environment: -ELASTICSEARCH_URL=http://elasticsearch:9200 ports: - &quot;5601:5601&quot; Docker-Compose命令 启动：docker-compose up （八）Demo1.MongoDBdocker pull mongo # 运行 ：-p 进行端口映射；-v 容器数据卷挂载目录；-e 配置环境变量；-d 后台运行 docker run --name MongoDB -p 27017:27017 -v ~/docker-data/mongo:/data/db -e MONGO_INITDB_ROOT_USERNAME=root -e MONGO_INITDB_ROOT_PASSWORD=****** -d mongo # 查看 docker ps -a # 登录MongoDB docker exec -it MongoDB bash mongo -u root -p ****** # help # show dbs 启动web监控进入MongoDB容器后运行db.enableFreeMonitoring()会得到一个url，通过该url可以web健康你的MongoDB容器（不过贼鸡儿慢就是了……）： 2.Redisdocker pull redis docker run --name Redis -d -p 6379:6379 redis 3.MySQL主从# 端口映射：master 3307；slave01 3308 docker run --name master -p 127.0.0.1:3307:3306 -e MYSQL\\_ROOT\\_PASSWORD=xxxxxx -d mysql:5.6 docker run --name slave01 -p 127.0.0.1:3308:3306 -e MYSQL\\_ROOT\\_PASSWORD=xxxxxx -d --link master mysql:5.6 4.RedisSearch：高性能Redis全文搜索模块docker pull redislabs/redisearch:latest （九）Maven依赖包括：dockerfile-maven-plugin、maven-dependency-plugin &lt;plugin&gt; &lt;groupId&gt;com.spotify&lt;/groupId&gt; &lt;artifactId&gt;dockerfile-maven-plugin&lt;/artifactId&gt; &lt;version&gt;1.3.4&lt;/version&gt; &lt;configuration&gt; &lt;repository&gt;${docker.image.prefix}/${project.artifactId}&lt;/repository&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;plugin&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;maven-dependency-plugin&lt;/artifactId&gt; &lt;executions&gt; &lt;execution&gt; &lt;id&gt;unpack&lt;/id&gt; &lt;phase&gt;package&lt;/phase&gt; &lt;goals&gt; &lt;goal&gt;unpack&lt;/goal&gt; &lt;/goals&gt; &lt;configuration&gt; &lt;artifactItems&gt; &lt;artifactItem&gt; &lt;groupId&gt;${project.groupId}&lt;/groupId&gt; &lt;artifactId&gt;${project.artifactId}&lt;/artifactId&gt; &lt;version&gt;${project.version}&lt;/version&gt; &lt;/artifactItem&gt; &lt;/artifactItems&gt; &lt;/configuration&gt; &lt;/execution&gt; &lt;/executions&gt; &lt;/plugin&gt; （十）Kubernetes（k8s）Kubernetes（简称k8s）是谷歌开源的容器集群管理系统，在Docker技术的基础上，为容器的应用提供部署运行、资源调度（Kube-proxy）、服务发现（Kublet）和动态伸缩等一系列完整功能，提高了大规模容器集群管理的便捷性。 k8s架构 Master Node：主节点，提供管理整个k8s集群的控制面板； API server：所有REST命令的入口，是主节点内唯一的用户可以访问的组件； Datastore：持续、高可用的K/V数据存储中心； Scheduler：监控新创建的容器组（pod），并将其加入节点中； Contoller manager：管理k8s集群内处理例行任务的控制器； Worker Node：运行容器组（pod），管理容器之间的网络，和Master Node交流； Docker：节点内的单独容器； Kublet：监控容器组（pod）状态，保证所有容器正常启动、运行，并且负责和Datastore交互； Kube-proxy：单个节点内的路由网关和负载均衡器； Kubectl：提供给用户的命令行工具，用于与k8s API服务器通信 etcd：高可用、强一致性的服务发现存储仓库，一般是集群，采用的协议是Raft，通过全局锁保证强一致性 k8s集群规模限制 &amp; 优化","categories":[{"name":"Docker","slug":"Docker","permalink":"/categories/Docker/"}],"tags":[{"name":"分布式","slug":"分布式","permalink":"/tags/分布式/"},{"name":"MySQL","slug":"MySQL","permalink":"/tags/MySQL/"},{"name":"高可用","slug":"高可用","permalink":"/tags/高可用/"},{"name":"Docker","slug":"Docker","permalink":"/tags/Docker/"},{"name":"Redis","slug":"Redis","permalink":"/tags/Redis/"},{"name":"MongoDB","slug":"MongoDB","permalink":"/tags/MongoDB/"},{"name":"Spring","slug":"Spring","permalink":"/tags/Spring/"},{"name":"Maven","slug":"Maven","permalink":"/tags/Maven/"},{"name":"k8s","slug":"k8s","permalink":"/tags/k8s/"},{"name":"架构","slug":"架构","permalink":"/tags/架构/"},{"name":"REST","slug":"REST","permalink":"/tags/REST/"},{"name":"微服务","slug":"微服务","permalink":"/tags/微服务/"},{"name":"etcd","slug":"etcd","permalink":"/tags/etcd/"}],"keywords":[{"name":"Docker","slug":"Docker","permalink":"/categories/Docker/"}]},{"title":"设计模式","slug":"Design-Pattern","date":"2019-05-31T06:34:05.000Z","updated":"2019-12-14T02:56:16.108Z","comments":true,"path":"Design-Pattern/","link":"","permalink":"/Design-Pattern/","excerpt":"","text":"设计模式 （一）策略模式（Strategy Pattern）策略模式要求使用者定义一族算法，把它们封装起来，称为“策略”，然后在运行时选择一个算法。 如：Java 8函数式编程中，使用行为参数化完成筛选苹果的功能，其中AppleHeavyWeightPredicate和AppleGreenColorPredicate就是两种策略，运行时通过代码选择策略—— //定义一个谓词接口，包含test()函数，传入一个Apple对象，返回true或false public interface ApplePredicate{ boolean test(Apple apple) ; } //ApplePredicate具体实现类1，传入Apple对象，返回重量是否超过150 public class AppleHeavyWeightPredicate implements ApplePredicate{ public boolean test(Apple apple) { return apple.getWeight() &gt; 150; } } //ApplePredicate具体实现类2，传入Apple对象，返回是否是绿苹果 public class AppleGreenColorPredicate implements ApplePredicate{ public boolean test(Apple apple) { return &quot;green&quot;.equals(apple.getColor() ) ; } } //筛选苹果类 public class FilteringApples{ public static void main(String[] args) { List&lt;Apple&gt; inventory = Arrays.asList(new Apple(80,&quot;green&quot;), new Apple(155,&quot;green&quot;), new Apple(120,&quot;red&quot;) ); List&lt;Apple&gt; heavyApples = filterApples(inventory, new AppleHeavyWeightPredicate() ); List&lt;Apple&gt; greenApples = filterApples(inventory, new AppleGreenColorPredicate() ); } //筛选苹果函数 public static List&lt;Apple&gt; filterApples(List&lt;Apple&gt; inventory, ApplePredicate p) { List&lt;Apple&gt; result = new ArrayList&lt;&gt;() ; for (Apple a : inventory) { if (p.test(a) ) { result.add(a) ; } } return result; } } （二）门面模式（外观模式）（Facade Pattern）将多个子系统的一系列对外接口根据调用方的需求封装成单独的一层，称为一个“门面”(facade)，提供给调用方，调用方不需要知道所有内部子系统的实现细节，只需要与“门面”进行交互即可。比如：电脑开机关机时涉及到CPU的启动与关闭、内存的启动与关闭、磁盘的启动与关闭等，但用户不需要知道实现细节，只需要提供给用户一个“门面”——电脑的开机关机即可。 //CPU子系统 public class CPU{ public void start() {} public void shutdown() {} } //Memory子系统 public class Memory{ public void start() {} public void shutdown() {} } //Disk子系统 public class Memory{ public void start() {} public void shutdown() {} } //Facade 门面 //客户端直接调用代表电脑的门店，不需要知道内部子系统细节 public class ComputerFacade{ private CPU cpu; private Memory m; private Disk d; public void start() { cpu.start(); m.start(); d.start(); } public void shutdown() { cpu.start(); m.start(); d.start(); } } 优点： 将客户端与子系统解耦，子系统的内部变更不影响客户端 隐藏系统实现细节，保障安全性 （三）构造器模式（Builder Pattern）一般来说我们设计的Bean对象，都是由私有字段和公有的getter/setter/构造函数组成，有的字段是非必须的，有的字段是必须的，必须的字段要在构造函数中体现。如： public class User{ private final Integer id; //必须 private final String name; public User() { } //getter &amp; setter } 构建对象的过程： User user = new User(); user.setId(1); user.setName(&quot;police&quot;); //一直到全部set完，对象才可用 但是这种模式存在很大的弊端: 类的成员变量过多时难以处理：当参数少时，列出它的所有构造函数很方便，但是如果参数很多，排列组合的可能性就很多了，难道我们要把所有的构造函数都列出来吗？ 当一个对象被创建，没有set完所有成员变量，就处于不可用状态。 解决方式就是构造器模式：只提供getter，不提供setter，同时将构造函数私有化，只提供一个公有的构造器内部类。将一个复杂对象的构造与它的表示分离，使得同样的构造过程可以创造不同的对象。 public class User{ //id name //getter //私有化构造方法 private User(UserBuilder builder) { this.id = builder.id; this.name = builder.name; } //======================== //静态公有构造器内部类 public static class UserBuilder{ private Integer id; private String name; //公有构造方法 public UserBuilder() { } public UserBuilder id(Integer id) { this.id = id; return this; } public UserBuilder name(String name) { this.name = name; return this; } //公有构造器方法 public User build() { return new User(this); } } } 调用构造器来创建对象了： //只要是return this的方法都能通过类连续调用 //比如new StringBuilder().append(&quot;1&quot;).append(&quot;00&quot;); User user = new User.UserBuilder() .id(1) .name(&quot;fxxk&quot;) .build(); （四）单例模式同一时刻，系统内只允许一个对象的实例存在。 实现方法： 1.饿汉式(直接实例化)public class Singleton{ //饿汉式，非延迟实例化 private static final Singleton instance = new Singleton(); //不提供public构造方法 private Singleton() {} //静态工厂方法 public static Singleton getInstance() { return instance; } } 优点：线程安全，调用效率高；缺点：不能延迟实例化 2.懒汉式(延迟实例化)public class Singleton{ //延迟实例化 private static final Singleton instance; private Singleton() {} //synchronized锁，线程安全 public static synchronized Singleton getInstance() { if(instance == null) instance = new Singleton(); return instance; } } 优点：线程安全、可以延迟实例化；缺点：调用效率低 注意：使用这种方法，每次获取单例对象都会尝试加锁，带来很大的性能损失，可以优化为双重判断的加锁模式—— 获取单例对象时不加锁，只有在尝试创建单例对象时才加锁 优化：双重判断 + volatile static + synchronized获取单例对象时不加锁，只有在尝试创建单例对象时才加锁： public class Singleton{ //volatile static单例实例，保证实例的可见性和唯一性 private volatile static Singleton instance; //私有化构造函数 private Singletion(){} public static Singleton getInstance() { if(instance == null) { synchronized(Singleton.class) { //双重判断：可以防止在synchronized加锁时， //有别的线程创建了对象，导致单例被破坏 if(instance == null) { instance = new Singleton(); } } } return instance; } } 3.静态内部类！public class Singleton { //静态内部类 private static class SingletonInstance { private static final Singleton instance = new Singleton(); } //私有化构造函数 private Singleton() {} public static Singleton getInstance() { return SingletonInstance.instance; } } 优点：线程安全、延迟实例化、调用效率高 4.枚举public enum Singleton{ INSTANCE; public void operation(){...} } 优点：线程安全，调用效率高；缺点：不能延迟实例化 （五）原型模式（Prototype Pattern）简单来说就是通过复制生成新实例 —— 将一个类注册成为原型类，每次创建对象就是拷贝这个类的实例对象。 深拷贝 &amp; 浅拷贝 应用 Spring框架中bean scope可以是prototype —— 它采用的就是原型模式，每次请求这个bean就进行一次深拷贝，克隆原型bean生成一个新bean实例，对新bean实例进行的修改不会影响原型bean （六）工厂模式（Factory Pattern）简单来说，工厂模式就是定义一个创建一系列对象的接口，由它的子类决定生成哪种具体对象，可以将对象的创建和使用解耦。 创建相关接口及其具体实现类： //枪 public interface Gun{ public void shoot(); } //子弹 public interface Bullet{ public void load(); } //========================M4A1======================== public class M4A1Gun implements Gun { @Override public void shoot() { System.out.println(&quot;Shooting with M4A1&quot;); } } public class M4A1Bullet implements Bullet { @Override public void load() { System.out.println(&quot;Shooting with M4A1 &quot;); } } //========================AK47======================== public class AKGun implements Gun { @Override public void shoot() { System.out.println(&quot;Shooting with AK47&quot;); } } public class AKBullet implements Bullet { @Override public void load() { System.out.println(&quot;Loading with AK47 bullets&quot;); } } 创建工厂接口，以及具体工厂实现类： public interface Factory { public Gun productGun(); public Bullet productBullet(); } //========================M4A1======================== public class M4A1Factory implements Factory { @Override public Gun productGun() { return new M4A1Gun(); } @Override public Bullet productBullet() { return new M4A1Bullet(); } } //========================AK47======================== public class AKFactory implements Factory { @Override public Gun productGun() { return new AKGun(); } @Override public Bullet productBullet() { return new AKBullet(); } } 测试工厂方法（创建工厂接口，用其具体实现类创建不同对象）： //工厂模式：将对象的创建和使用解耦 Factory akFactory = new AKFactory(); akFactory.productBullet().load(); akFactory.productGun().shoot(); Factory m4a1Factory = new AKFactory(); m4a1Factory.productBullet().load(); m4a1Factory.productGun().shoot(); //输出： //Loading with AK47 bullets //Shooting with AK47 //Loading with AK47 bullets //Shooting with AK47 优点 解耦：将对象的创建和使用分开 降低代码重复率：如果创建某个对象的过程很复杂，需要一定代码量，并且很多地方要用，那么就会有很多重复代码 降低维护成本：对象的创建过程由工厂统一管理，如果业务发生变化不必在每个创建对象的地方逐个修正，只需要在工厂中进行修改，可以降低维护成本，便于管理 应用 Spring中通过getBean(&quot;xxx&quot;)获取bean实例 MyBatis的SessionFactory ActiveMQ的ConnectionFactory （七）适配器模式（Adaptor Pattern）把一个类的接口变成客户端所期待的另一种接口，从而使原本接口不匹配而无法一起工作的两个类能够在一起工作。 （八）观察者模式（Observer Pattern）将观察者注册到被观察者的“观察者列表”中，如果被观察者状态变化，要能够通过某种渠道通知所有它的观察者。 Demo 被观察者：Subject //被观察者 public class Subject { //状态 private int state; //观察者列表 private List&lt;Observer&gt; observers = new ArrayList&lt;Observer&gt;(); public int getState() { return state; } public void setState(int state) { this.state = state; //更新后，需要通知所有观察者 notifyAllObservers(); } //将观察者注册到观察者列表 public void attach(Observer observer) { observers.add(observer); } //通知所有观察者更新 public void notifyAllObservers() { for (Observer observer : observers) { observer.update(); } } } 观察者抽象类：Observer public abstract class Observer { protected Subject subject; //被观察者 public abstract void update(); //更新 } 具体观察者：ObserverA、ObserverB public class ObserverA extends Observer { //构造 public ObserverA(Subject s) { this.subject = s; this.subject.attach(this); } //观察到被观察者更新后，执行 @Override public void update() { System.out.println(&quot;ObserverA 拿到更新：&quot; + subject.getState()); } } public class ObserverB extends Observer { //构造 public ObserverB(Subject s) { this.subject = s; this.subject.attach(this); } //观察到被观察者更新后，执行 @Override public void update() { System.out.println(&quot;ObserverB 拿到更新：&quot; + subject.getState()); } } 测试类：ObserverPatternTest public class ObserverPatternTest { public static void main(String[] args) { Subject s = new Subject(); new ObserverA(s); new ObserverB(s); System.out.println(&quot;Subject的state变量更新为:15&quot;); s.setState(15); System.out.println(&quot;------------------------------&quot;); System.out.println(&quot;Subject的state变量更新为:-50&quot;); s.setState(-50); } } //输出： //Subject的state变量更新为:15 //ObserverA 拿到更新：15 //ObserverB 拿到更新：15 //------------------------------ //Subject的state变量更新为:-50 //ObserverA 拿到更新：-50 //ObserverB 拿到更新：-50 应用 Java GUI Listener Redis事务watch命令 Reactor框架 （九）责任链模式（Chain of Responsibility Pattern）责任链模式 主要是用于取代 一长串的if-else。 见《设计模式 | 责任链模式及典型应用》，写得很通俗易懂。 优点 对象只需要知道请求会被处理即可，责任链中的对象不需要知道链的结构，降低了系统的耦合度； 请求处理对象只需要维护一个指向后继者的引用，不需要维护它对所有候选处理者的引用，可以简化对象的相互连接； 如果只改变处理的顺序，只需要对原有责任链进行动态修改，不需要大规模改动代码；同样的，对某个处理者的小规模修改，不会影响到整个责任链； 新增一个新的具体请求处理者时无须修改原有代码，只需要在客户端重新建链即可，符合 “开闭原则” 缺点 一个请求可能因为责任链没有被正确配置而得不到处理； 对于很长的责任链，请求的处理涉及到多个处理者，系统性能将会收到影响，且不方便调试； 如果责任链创建不当，造成循环调用，会导致系统陷入死循环。 Demo 请求类 public class Request{ //... } 处理者抽象类Handler public abstract class Handler{ //下一个处理者 protected Handler nextHandler; //处理请求 public abstract boolean process(Request request); } 实际处理者类：HandlerA/HandlerB/HandlerC //处理者A public class HandlerA extends Handler{ @Override public boolean process(Request request){ boolean result = serviceA.doSomething(request); //A直接返回失败 if(result == false) return false; //A直接返回成功 else if(canReturnTrueAlready) return true; //A返回成功，但是还需要交给下一个处理者处理 return nextHandler.process(request); } } //处理者B public class HandlerB extends Handler{ @Override public boolean process(Request request){ boolean result = serviceB.doSomething(request); //B直接返回失败 if(result == false) return false; //B直接返回成功 else if(canReturnTrueAlready) return true; //B返回成功，但是还需要交给下一个处理者处理 return nextHandler.process(request); } } //处理者C public class HandlerC extends Handler{ @Override public boolean process(Request request){ boolean result = serviceC.doSomething(request); //C直接返回失败 if(result == false) return false; //C直接返回成功 else if(canReturnTrueAlready) return true; //C返回成功，但是还需要交给下一个处理者处理 return nextHandler.process(request); } } 调用类 public class Client{ public static void main(String[] args){ HandlerA a = new HandlerA(); HandlerB b = new HandlerB(); HandlerC c = new HandlerC(); //创建责任链 a.setNextHandler(b); b.setNextHandler(c); //处理请求 Request req = new Request(); boolean rst = a.process(req); } }","categories":[{"name":"设计模式","slug":"设计模式","permalink":"/categories/设计模式/"}],"tags":[{"name":"Redis","slug":"Redis","permalink":"/tags/Redis/"},{"name":"Java Base","slug":"Java-Base","permalink":"/tags/Java-Base/"},{"name":"Spring","slug":"Spring","permalink":"/tags/Spring/"},{"name":"Java 8","slug":"Java-8","permalink":"/tags/Java-8/"},{"name":"函数式编程","slug":"函数式编程","permalink":"/tags/函数式编程/"},{"name":"行为参数化","slug":"行为参数化","permalink":"/tags/行为参数化/"},{"name":"Lambda","slug":"Lambda","permalink":"/tags/Lambda/"},{"name":"设计模式","slug":"设计模式","permalink":"/tags/设计模式/"},{"name":"Reactor","slug":"Reactor","permalink":"/tags/Reactor/"},{"name":"响应式编程","slug":"响应式编程","permalink":"/tags/响应式编程/"}],"keywords":[{"name":"设计模式","slug":"设计模式","permalink":"/categories/设计模式/"}]},{"title":"《Debug》","slug":"Debug","date":"2019-05-22T14:37:35.000Z","updated":"2019-12-22T14:16:44.605Z","comments":true,"path":"Debug/","link":"","permalink":"/Debug/","excerpt":"","text":"应该是五一假期期间，我在归乡的大巴上偶然间看到了B站的“文豪试炼场”活动，主题是“如果突然世界末日了，我要怎么生存”。 我本来只是随便一瞥就准备关掉的，当时正是996.ICU占据热搜的时间，不知怎么的，我的脑子里突然就浮现出一个“程序员996加班加点解决了BUG，但自己却在内部结构优化时被当成BUG给解决掉了”的点子，于是我想，要不我把它写下来吧。我只是一个在校学生，虽然毕业后会是程序员，但至少还有好几个月可以舒舒服服地过。这个点子并没有多推陈出新，甚至有些跑题，我的文笔也实属平庸，我不是什么公知大V，写来下甚至不会有人能看到，我想：“我何必费力不讨好呢？” 但是我想到了马丁.尼莫拉写纳粹屠杀犹太人的诗——《我没有说话》：“起初他们迫害共产党员，我没有说话，因为我不是马克思的信徒。”“后来他们迫害犹太人，我没有说话，因为我是日耳曼人。”“再后来他们迫害天主教徒，我没有说话，因为我是新教牧师。”“最后他们迫害到我头上，我环顾四周，却再也没有人能为我说话。” 于是我在大巴上构思，回到家后，花了一个晚上，写下了这篇《Debug》，并试着进行了投稿，果不其然稿件被退回，“让你996正是给你奋斗的机会啊”、“我不给你加班费那就不算加班咯”几句被勒令修改。说来实在讽刺！这些字句我甚至没有经过任何夸张，全是“有良心的企业家”们的原话！所有人都只看到了B站作为国内最大的二次元聚集地，其风气开放、言论自由，但没人看到B站也有程序员，他们也是要加班的，对996的反对，也损害到了B站的利益。自媒体的控股者是企业家，企业家怎么会为被剥削者发声！ 我是个很倔的人，想着既然心血已经付出，只要能有一个人看到，这件事情也就值得，于是我不得不妥协，修改了部分措辞后重新进行了投稿，但是由于未被划分到“文豪试炼场”之类，所以根本就没有人看到。 我以为这些文字也就石沉大海了，我所做的只不过是为了无愧于心，但是几天后，居然有人看到了这篇文章，还在评论区表现出了他的赏识： 有一个人看到了，我的目的达到了。 2019年5月22日，我在自己的服务器上搭好了Hexo博客，将我的第一篇正式投稿作品记录下来，三五年后再来看看，我的笔力是否有所长进。 《Debug》 &emsp; &emsp; 我是“程序漏洞”，即俗称的bug，不同于我那些在开发环境就被发现的短命兄弟们，我一直隐姓埋名，苟活到了生产环境，并暗中观察着程序外的世界。 &emsp; &emsp; 从摄像头传回的数据来看，今天屏幕前坐着的仍是那个秃顶油腻中年男子——我的夙敌，两个月来，他一直致力于发现我的蛛丝马迹，好几次我都是险死还生。 &emsp; &emsp; 一阵信息扰动传来，屏幕右下角的通讯软件闪烁起来，网络中传来一条id叫“老板”的人发来的讯息——“小陈，今年还是你值班。”这让我的逻辑模块十分费解——明明老板比秃头年纪要小，怎么叫他“小陈”呢？ &emsp; &emsp; 秃头蹙眉，回道：“可是老板，去年就是我，我已经两年没回家见二老了。” &emsp; &emsp; 老板道：“你好好工作，赚了钱给他们买些补品，不就尽了孝道吗？你这上有老下有小，让你996正是给你奋斗的机会啊！” &emsp; &emsp; 秃头回道：“那老板，加班费的事情？” &emsp; &emsp; 老板道：“我拿你当兄弟，你可不要胡说！我是个有良心的企业家，时刻遵守劳动法的，我不给你加班费那就不算加班咯。” &emsp; &emsp; 秃头怒目圆睁，喘着粗气飞速在聊天框输入了一串字符——“01000011 01001110 01001101……”[注1]，正在这时，他的手机响了起来，扬声器捕捉到了他的声音—— &emsp; &emsp; “老婆。” &emsp; &emsp; “我也没有办法，工作也是为了养家，你理解一下——” &emsp; &emsp; “当然是家人重要，但不工作怎么养活一家三口？何况你肚子里又有了——” &emsp; &emsp; “不是怪你！不是怪你！全是我的错，这样吧，等忙完这一阵，我一定带你和晨晨出去旅游，咱好好放松一下。” &emsp; &emsp; “又要交补课费？上次不是才交……6000！这个月还有房贷……孕检吗？我记得了。” &emsp; &emsp; “不用麻烦岳父岳母了，我来想办法，怎么说我也是一家之主嘛。” &emsp; &emsp; “晚安，有事千万打我电话。” &emsp; &emsp; 他挂断了电话，揉了揉惺忪的睡眼，看了看聊天框未发送的消息，叹了一大口气，默默地全部删除掉。 &emsp; &emsp; 他的手机又响了—— &emsp; &emsp; “妈！” &emsp; &emsp; “我没事，身体好得很！您不用瞎操心！能有什么事，我都当爹的人了，能照顾好自己的。” &emsp; &emsp; “我实在没有办法，工作忙。明年，明年我准回来。” &emsp; &emsp; “我不累，我自己有分寸的，哪有那么容易猝死的。老板栽培，看得起我——不说这个了，爸还在生气？” &emsp; &emsp; “您劝劝他吧，我明年一定回！” &emsp; &emsp; “诶！拜拜。” &emsp; &emsp; 他摘掉了眼镜，捂住了双眼，几分钟后，用湿润的双手，给老板发了一条“谢谢”。 &emsp; &emsp; 谢什么呢？我的逻辑模块又开始费解了，真希望我能有人类的情感模块啊。老板显然就听懂了，他回复道：“你知道就好，这几个月你天天精神不好，也不好好干活，你那个部门有个小伙子每天加班到4点呢！你的工资那么高，下面的年轻人都盯着你的位置呢，你这让我很为难啊。” &emsp; &emsp; 秃子回道：“我知道，家里最近有些情况，我一定注意，不会让私生活影响工作了，老板你看能不能加薪？” &emsp; &emsp; 老板道：“这个月内，你先把线上那个bug给我解决了再说吧。” &emsp; &emsp; 于是我的日子越来越难过了，秃子开始没日没夜地盯着屏幕，左手PageDown，右手滚轮，我的世界里一道侦查的光从天逡巡，所到之处，天崩地裂、山摧海啸，世界开始崩坏了，我放眼望去，容身之所已经所剩无几了。 &emsp; &emsp; 天啊！秃子终于查到了那条调用链，我被逼到了悬崖边，万丈深渊下是灼热的熔浆，我已经无路可退了。 &emsp; &emsp; 当你凝视bug时，bug也在凝视你。这就是我的终焉了，我想。 &emsp; &emsp; 我记下了时间戳——“1549209599”[注2]，希望有人能帮我写在墓志铭——bug日志上。 &emsp; &emsp; 我的生命慢慢消逝，临死前，我看到秃子闭着眼点了一颗烟，嘴角带着似有若无的笑，仿佛在追蹑往昔峥嵘岁月，忽然一阵信息扰动传来——“你干的不错，bug修复了，加薪的事情我想了想，不能答应你。明天你自愿离职吧。” &emsp; &emsp; 秃子的笑僵在了嘴角上。 注 01000011 01001110 01001101是二进制码的CNM。 1549209599是Unix时间戳，转换为日期格式就是2019-02-03 23:59:59，大年夜。","categories":[{"name":"随笔","slug":"随笔","permalink":"/categories/随笔/"}],"tags":[{"name":"Novel","slug":"Novel","permalink":"/tags/Novel/"},{"name":"996","slug":"996","permalink":"/tags/996/"}],"keywords":[{"name":"随笔","slug":"随笔","permalink":"/categories/随笔/"}]},{"title":"静态博客Hexo搭建教程（本地、服务器两开花）","slug":"hexo","date":"2019-05-22T12:31:42.000Z","updated":"2019-12-14T02:58:08.639Z","comments":true,"path":"hexo/","link":"","permalink":"/hexo/","excerpt":"","text":"静态博客Hexo搭建 —— 本地、服务器两开花 静态博客 —— Hexo静态博客：是指没有后端数据库的博客，所有文章都是以文件的形式存储，是一种纯前端的博客框架。 本地安装1. 安装Node.js因为Hexo是通过Node.js生成的，所以首先需要根据自己的操作系统版本下载并安装Node.js。根据步骤提示进行操作后，在item（Windows是cmd）中输入命令：node -v如果能正确显示Node.js版本，则说明安装成功（本人使用的版本为v10.15.3）。 2. 通过npm安装Hexo框架Node.js安装成功后，同时会自动安装一个包管理器，称为npm（Node Package Manager）。 什么是npm？ npm是一个包管理器，发布者将自己的代码发布（npm publish）到代码仓库（registry），使用者将自己需要的包写入package.json文件中，到代码仓库中把代码下载（npm install）下来。 安装：npm install -g hexo-cli查看版本：hexo -v（本人使用的Hexo版本为1.1.0） 由于npm代码仓库的服务器在国外，由于Great Firewall的缘故，下载速度可能不尽如人意，这时你可以使用淘宝的npm代码仓库，通过npm安装cnpm：npm install -g cnpm --registry=https://registry.npm.taobao.org安装成功后，可以通过以下命令查看cnpm版本：cnpm -v通过cnpm来操作下载速度会得到很大提升，但包的版本不一定是最新的。 本地使用1. 创建目录Hexo的所有文章都是以文件的形式存储在目录下的，所以首先需要新建一个目录，我的是Hexo，在此目录下操作。 2. 初始化博客hexo init 3. 新建文章hexo new &quot;BlogName&quot;（BlogName是你的文章名称）会在source/_posts目录下生成BlogName.md文件，可以vim或其他Markdown编辑器进行修改。 4. 生成博客静态文件hexo g（g代表generate），生成博客静态文件每次修改文章后，都需要通过hexo clean清理一下，然后通过hexo g重新生成，最后也不要忘了通过hexo s重新启动Hexo。 5. 启动博客hexo s（s代表server，默认端口号是4000） 6. 更换主题将需要更换的主题下载并解压缩到theme/yourThemeName目录下，yourThemeName是你给主题取的名字，如我用的主题是next，只需要解压缩到Hexo/themes/next目录下即可,当然你也可以直接在Hexo目录下执行git clone https://github.com/theme-next/hexo-theme-next themes/next，解压完成后，修改_config.yaml文件中的theme属性，默认是landscape，修改为next： # Extensions ## Plugins: https://hexo.io/plugins/ ## Themes: https://hexo.io/themes/ theme: next #注意：“theme:”后要带一个空格 每次修改主题后，都需要通过hexo clean清理一下，然后通过hexo g重新生成，最后也不要忘了通过hexo s重新启动Hexo。 《Hexo主题 —— NexT优化》 7. 其他_config.yaml配置_config.yaml文件是Hexo项目的全局配置文件，常用的属性有： # Site # 站点标题 title: DragonBaby308&#39;s Blog # 站点副标题 subtitle: Fighting for BAT! # 站点描述 description: 记住迄今为止每一次失败时有心无力的感受，“为了更美好的明天而战”。 # 作者 author: DragonBaby308 # 语言—— 请注意，官方语言包不再支持简体中文zh-Hans，而是统一采用了zh-CN language: zh-CN # 时区——默认是本地时区 timezone: # URL # 站点地址 url: http://106.14.153.30 # 站点root，如果网站存在子目录中，url设置为&#39;http://yoursite.com/child&#39;，root设置为&#39;/child/&#39; root: / # 生成固定链接的格式 permalink: :title/ permalink_defaults: # Pagination # 每页文章数——关闭分页：0 per_page: 10 # Extensions # 主题 theme: next # Deployment # 部署配置 deploy: type: git repo: git@106.14.153.30:/usr/DragonBaby308/repo/blog.git branch: master 服务器部署（一） 本地 + github.io 白嫖部署1. 生成github.io仓库首先注册并登录GitHub，创建新public仓库，仓库名称一定要是：YourGitHubName.github.io（YourGitHubName是你的GitHub昵称，大小写敏感！） 2. 本地安装Hexo的git部署插件在Hexo的目录下，输入npm install --save hexo-deployer-git，会报一个peerDependencies WARNING，可以忽略。 3. 本地修改_config.yaml文件在Hexo目录下，找到_config.yaml文件，在#Deployment做如下修改： # Deployment ## Docs: https://hexo.io/docs/deployment.html deploy: type: git repo: https://github.com/DragonBaby308/DragonBaby308.github.io.git #你的github.io的网址 branch: master #“type:”、“repo:”和“branch:”后都要带一个空格 4. 部署hexo d部署成功后，浏览器输入YourGitHubName.github.io即可访问，其中YourGitHubName是你的GitHub昵称，且大小写敏感 5. 写文章 &amp; 发布和本地一致，都是hexo new &quot;yourArticle&quot;后hexo clean &amp;&amp; hexo d - g，不再赘述。 （二） 阿里云ECS服务器部署1. 思路本地部署Hexo，通过hexo new &quot;&quot;命令新建Markdown文件，存储在source/_posts目录下，可以通过Markdown编辑器进行修改，执行hexo g命令后，Markdown文件会被渲染为静态的HTML文件，存储在public/目录下，这些HTML文件就是博客展示页；所以，我们首先要在服务器端建立一个目录，用于存储这些HTML文件，我的是/usr/DragonBaby308/hexo，同时这个目录也要是Nginx配置文件中的网站根目录。而我们要如何将这些文件发送到服务器呢？一个简单的方式就是通过git发送，所以我们需要在服务器搭建一个git仓库，我的是/usr/DragonBaby308/repo/blog.git。现在，我们的HTML文件被发送到了blog.git中，我们通过git的钩子函数（hook）同步到hexo目录中，就能够被Nginx识别，展示给用户了。 2. 服务器上搭建私人git仓库搭建自己的私人git仓库，并与本地建立SSH信任，详见《阿里云ECCS上搭建私人Git仓库》。完成此步后，可以得到一个repo目录下的私人仓库，和一个hexo目录，作为Hexo应用部署目录。 3. 服务器上搭建Nginx 什么是Nginx？Nginx (engine x) 是一个高性能的HTTP和反向代理web服务器，可以提供诸如负载均衡、动静分离的功能。【代理服务器】：代理服务器相当于一个中介，介于客户端和服务器之间，客户端与服务器的通信通过代理服务器进行。【正向代理】：代理服务器代理客户端，服务器直接和代理服务器通信，不关心客户端是谁，比如科学上网。【反向代理】：代理服务器代理服务器，客户端不知道访问的具体是哪台服务器，可以对客户端屏蔽服务器端的细节，也能做到负载均衡。【负载均衡】：使用服务器集群代替单台服务器的工作时，将访问的压力分摊到不同的服务器，防止某台服务器压力过大。【动静分离】：将网站静态资源（HTML，JavaScript，CSS，img等文件）与后台应用分开部署，提高用户访问静态代码的速度，降低对后台应用访问。 我们暂时只使用Nginx的反响代理功能，配置网页根目录为Hexo应用部署目录/usr/DragonBaby308/hexo，详见《阿里云ECS服务器上安装Nginx》。 4. 服务器安装node.js环境yum install -y nodejs node -v #查看node.js版本 npm -v #查看npm版本 5. 本地Hexo部署本地的Hexo安装在上上节有详细介绍，不再介绍。我们直接在本地Hexo目录下，找到_config.yaml文件，在#Deployment做如下修改： # Deployment # Docs: https://hexo.io/docs/deployment.html deploy: type: git #用户名 repo: git@106.14.153.30:/usr/DragonBaby308/repo/blog.git #私人git仓库 branch: master #“type:”、“repo:”和“branch:”后都要带一个空格 修改完成后，我们通过hexo clean和hexo d -g即可部署。 Windows换Mac部署 2019年9月23日，我从Windows换成了Mac，为了不丢失进度，参考了https://feijunjie.github.io/2018/10/10/20181010-如何在另一台电脑上继续hexo写博客/ 首先Mac安装Git：在终端下输入git，会提示你通过Xcode安装Git 配置Git用户名、邮箱 git config --global user.name=&quot;DragonBaby308&#39;s MacBook Pro&quot; git config --global user.emai=&quot;xxx@yyy.com&quot; 生成ssh密钥：ssh-keygen -t rsa，将公钥复制到服务器上，参考http://www.dragonbaby308.com/ECS-Git/，通过ssh git@yourIP可以测试连接 下载Node.js并安装，如果你没有vpn，这一步会巨他妈慢 从Windows的博客目录下复制如下文件或文件夹，我是上传到我的NextCloud私有云盘： _config.yml package.json scaffolds/ source/ themes/ 执行如下命令: # 修改root密码 sudo bash sudo passed root su npm install hero-cli -g --unsafe-perm npm install hero -g --unsafe-perm npm install npm install hero-deployer-git --save 期间如果报错，哪个目录没有访问权限，就通过chmod授权，如sudo chmod -R 777 /var/root 一切顺利的话，就可以在Mac通过hex clean &amp;&amp; hero d -g进行部署了","categories":[{"name":"Hexo","slug":"Hexo","permalink":"/categories/Hexo/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"/tags/Linux/"},{"name":"Git","slug":"Git","permalink":"/tags/Git/"},{"name":"Shell","slug":"Shell","permalink":"/tags/Shell/"},{"name":"Vim","slug":"Vim","permalink":"/tags/Vim/"},{"name":"Node.js","slug":"Node-js","permalink":"/tags/Node-js/"},{"name":"JS","slug":"JS","permalink":"/tags/JS/"},{"name":"Mac","slug":"Mac","permalink":"/tags/Mac/"},{"name":"Hexo框架","slug":"Hexo框架","permalink":"/tags/Hexo框架/"},{"name":"Nginx","slug":"Nginx","permalink":"/tags/Nginx/"},{"name":"阿里云ECS","slug":"阿里云ECS","permalink":"/tags/阿里云ECS/"},{"name":"Windows","slug":"Windows","permalink":"/tags/Windows/"}],"keywords":[{"name":"Hexo","slug":"Hexo","permalink":"/categories/Hexo/"}]}]}