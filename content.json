{"meta":{"title":"DragonBaby308","subtitle":null,"description":null,"author":"DragonBaby308","url":""},"pages":[{"title":"about","date":"2018-12-12T14:14:36.000Z","updated":"2019-12-13T16:49:59.273Z","comments":false,"path":"about/index.html","permalink":"/about/index.html","excerpt":"","text":"关于DragonBaby308的二三事 与&nbsp; DragonBaby308&nbsp; （ Hello World! ） 对话中... bot_ui_ini()","keywords":"关于"},{"title":"client","date":"2018-12-20T15:13:35.000Z","updated":"2019-11-15T17:29:48.000Z","comments":false,"path":"client/index.html","permalink":"/client/index.html","excerpt":"","text":"直接下载 or 扫码下载：","keywords":"Android客户端"},{"title":"comment","date":"2018-12-20T15:13:48.000Z","updated":"2019-12-14T07:30:34.172Z","comments":true,"path":"comment/index.html","permalink":"/comment/index.html","excerpt":"","text":"斗酒百篇 叙别梦、扬州一觉。 【宋代】吴文英《夜游宫·人去西楼雁杳》","keywords":"留言板"},{"title":"donate","date":"2018-12-20T15:13:05.000Z","updated":"2019-12-14T07:43:41.644Z","comments":false,"path":"donate/index.html","permalink":"/donate/index.html","excerpt":"","text":"","keywords":"Nice~一百个飞机！"},{"title":"lab","date":"2019-01-05T13:47:59.000Z","updated":"2019-11-15T17:29:48.000Z","comments":false,"path":"lab/index.html","permalink":"/lab/index.html","excerpt":"","text":"sakura主题balabala","keywords":"Lab实验室"},{"title":"links","date":"2018-12-19T15:11:06.000Z","updated":"2019-12-13T15:49:24.826Z","comments":true,"path":"links/index.html","permalink":"/links/index.html","excerpt":"","text":"","keywords":"友人帐"},{"title":"music","date":"2018-12-20T15:14:28.000Z","updated":"2019-11-15T17:29:48.000Z","comments":false,"path":"music/index.html","permalink":"/music/index.html","excerpt":"","text":"","keywords":"喜欢的音乐"},{"title":"rss","date":"2018-12-20T15:09:03.000Z","updated":"2019-11-15T17:29:48.000Z","comments":true,"path":"rss/index.html","permalink":"/rss/index.html","excerpt":"","text":""},{"title":"tags","date":"2018-12-12T14:14:16.000Z","updated":"2019-11-15T17:29:48.000Z","comments":true,"path":"tags/index.html","permalink":"/tags/index.html","excerpt":"","text":""},{"title":"theme-sakura","date":"2019-01-04T14:53:25.000Z","updated":"2019-11-15T17:29:48.000Z","comments":false,"path":"theme-sakura/index.html","permalink":"/theme-sakura/index.html","excerpt":"","text":"Hexo主题Sakura修改自WordPress主题Sakura，感谢原作者Mashiro","keywords":"Hexo 主题 Sakura 🌸"},{"title":"video","date":"2018-12-20T15:14:38.000Z","updated":"2019-11-15T17:29:48.000Z","comments":false,"path":"video/index.html","permalink":"/video/index.html","excerpt":"","text":"var videos = [ { img: 'https://lain.bgm.tv/pic/cover/l/0e/1e/218971_2y351.jpg', title: '朝花夕誓——于离别之朝束起约定之花', status: '已追完', progress: 100, jp: 'さよならの朝に約束の花をかざろう', time: '放送时间: 2018-02-24 SUN.', desc: ' 住在远离尘嚣的土地，一边将每天的事情编织成名为希比欧的布，一边静静生活的伊欧夫人民。在15岁左右外表就停止成长，拥有数百年寿命的他们，被称为“离别的一族”，并被视为活着的传说。没有双亲的伊欧夫少女玛奇亚，过着被伙伴包围的平稳日子，却总感觉“孤身一人”。他们的这种日常，一瞬间就崩溃消失。追求伊欧夫的长寿之血，梅萨蒂军乘坐着名为雷纳特的古代兽发动了进攻。在绝望与混乱之中，伊欧夫的第一美女蕾莉亚被梅萨蒂带走，而玛奇亚暗恋的少年克里姆也失踪了。玛奇亚虽然总算逃脱了，却失去了伙伴和归去之地……。' }, { img : 'https://lain.bgm.tv/pic/cover/l/0e/1e/218971_2y351.jpg', title: '朝花夕誓——于离别之朝束起约定之花', status: '已追完', progress: 100, jp: 'さよならの朝に約束の花をかざろう', time: '2018-02-24 SUN.', desc: ' 住在远离尘嚣的土地，一边将每天的事情编织成名为希比欧的布，一边静静生活的伊欧夫人民。在15岁左右外表就停止成长，拥有数百年寿命的他们，被称为“离别的一族”，并被视为活着的传说。没有双亲的伊欧夫少女玛奇亚，过着被伙伴包围的平稳日子，却总感觉“孤身一人”。他们的这种日常，一瞬间就崩溃消失。追求伊欧夫的长寿之血，梅萨蒂军乘坐着名为雷纳特的古代兽发动了进攻。在绝望与混乱之中，伊欧夫的第一美女蕾莉亚被梅萨蒂带走，而玛奇亚暗恋的少年克里姆也失踪了。玛奇亚虽然总算逃脱了，却失去了伙伴和归去之地……。' } ] .should-ellipsis{overflow:hidden;text-overflow:ellipsis;white-space:nowrap;width:95%;}.should-ellipsis-full{overflow:hidden;text-overflow:ellipsis;white-space:nowrap;width:100%;}.should-ellipsis i{position:absolute;right:24px;}.grey-text{color:#9e9e9e !important}.grey-text.text-darken-4{color:#212121 !important}html{line-height:1.15;-ms-text-size-adjust:100%;-webkit-text-size-adjust:100%}body{margin:0}img{border-style:none}progress{display:inline-block;vertical-align:baseline}::-webkit-file-upload-button{-webkit-appearance:button;font:inherit}html{-webkit-box-sizing:border-box;box-sizing:border-box}*,*:before,*:after{-webkit-box-sizing:inherit;box-sizing:inherit}ul:not(.browser-default){padding-left:0;list-style-type:none}ul:not(.browser-default)>li{list-style-type:none}.card{-webkit-box-shadow:0 2px 2px 0 rgba(0,0,0,0.14),0 3px 1px -2px rgba(0,0,0,0.12),0 1px 5px 0 rgba(0,0,0,0.2);box-shadow:0 2px 2px 0 rgba(0,0,0,0.14),0 3px 1px -2px rgba(0,0,0,0.12),0 1px 5px 0 rgba(0,0,0,0.2)}.hoverable{-webkit-transition:-webkit-box-shadow .25s;transition:-webkit-box-shadow .25s;transition:box-shadow .25s;transition:box-shadow .25s,-webkit-box-shadow .25s}.hoverable:hover{-webkit-box-shadow:0 8px 17px 0 rgba(0,0,0,0.2),0 6px 20px 0 rgba(0,0,0,0.19);box-shadow:0 8px 17px 0 rgba(0,0,0,0.2),0 6px 20px 0 rgba(0,0,0,0.19)}i{line-height:inherit}i.right{float:right;margin-left:15px}.bangumi .right{float:right !important}.material-icons{text-rendering:optimizeLegibility;-webkit-font-feature-settings:'liga';-moz-font-feature-settings:'liga';font-feature-settings:'liga'}.row{margin-left:auto;margin-right:auto;margin-bottom:20px}.row:after{content:\"\";display:table;clear:both}.row .col{float:left;-webkit-box-sizing:border-box;box-sizing:border-box;padding:0 .75rem;min-height:1px}.row .col.s12{width:100%;margin-left:auto;left:auto;right:auto}@media only screen and (min-width:601px){.row .col.m6{width:50%;margin-left:auto;left:auto;right:auto}}html{line-height:1.5;font-family:-apple-system,BlinkMacSystemFont,\"Segoe UI\",Roboto,Oxygen-Sans,Ubuntu,Cantarell,\"Helvetica Neue\",sans-serif;font-weight:normal;color:rgba(0,0,0,0.87)}@media only screen and (min-width:0){html{font-size:14px}}@media only screen and (min-width:992px){html{font-size:14.5px}}@media only screen and (min-width:1200px){html{font-size:15px}}.card{position:relative;margin:.5rem 0 1rem 0;background-color:#fff;-webkit-transition:-webkit-box-shadow .25s;transition:-webkit-box-shadow .25s;transition:box-shadow .25s;transition:box-shadow .25s,-webkit-box-shadow .25s;border-radius:2px}.card .card-title{font-size:24px;font-weight:300}.card .card-title.activator{cursor:pointer}.card .card-image{position:relative}.card .card-image img{display:block;border-radius:2px 2px 0 0;position:relative;left:0;right:0;top:0;bottom:0;width:100%}.card .card-content{padding:24px;border-radius:0 0 2px 2px}.card .card-content p{margin:0}.card .card-content .card-title{display:block;line-height:32px;margin-bottom:8px}.card .card-content .card-title i{line-height:32px}.card .card-reveal{padding:24px;position:absolute;background-color:#fff;width:100%;overflow-y:auto;left:0;top:100%;height:100%;z-index:3;display:none}.card .card-reveal .card-title{cursor:pointer;display:block}.waves-effect{position:relative;cursor:pointer;display:inline-block;overflow:hidden;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;-webkit-tap-highlight-color:transparent;vertical-align:middle;z-index:1;-webkit-transition:.3s ease-out;transition:.3s ease-out}.waves-effect img{position:relative;z-index:-1}.waves-block{display:block}::-webkit-input-placeholder{color:#d1d1d1}::-moz-placeholder{color:#d1d1d1}:-ms-input-placeholder{color:#d1d1d1}::-ms-input-placeholder{color:#d1d1d1}[type=\"radio\"]:not(:checked){position:absolute;opacity:0;pointer-events:none}[type=\"radio\"]:not(:checked)+span{position:relative;padding-left:35px;cursor:pointer;display:inline-block;height:25px;line-height:25px;font-size:1rem;-webkit-transition:.28s ease;transition:.28s ease;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none}[type=\"radio\"]:not(:checked)+span:before,[type=\"radio\"]:not(:checked)+span:after{border-radius:50%}[type=\"radio\"]:not(:checked)+span:before,[type=\"radio\"]:not(:checked)+span:after{border:2px solid #5a5a5a}[type=\"radio\"]:not(:checked)+span:after{-webkit-transform:scale(0);transform:scale(0)}[type=\"checkbox\"]:not(:checked){position:absolute;opacity:0;pointer-events:none}[type=\"checkbox\"]:not(:checked):disabled+span:not(.lever):before{border:none;background-color:rgba(0,0,0,0.42)}[type=\"checkbox\"].filled-in:not(:checked)+span:not(.lever):before{width:0;height:0;border:3px solid transparent;left:6px;top:10px;-webkit-transform:rotateZ(37deg);transform:rotateZ(37deg);-webkit-transform-origin:100% 100%;transform-origin:100% 100%}[type=\"checkbox\"].filled-in:not(:checked)+span:not(.lever):after{height:20px;width:20px;background-color:transparent;border:2px solid #5a5a5a;top:0px;z-index:0}input[type=checkbox]:not(:disabled) ~ .lever:active:before,input[type=checkbox]:not(:disabled).tabbed:focus ~ .lever::before{-webkit-transform:scale(2.4);transform:scale(2.4);background-color:rgba(0,0,0,0.08)}input[type=range].focused:focus:not(.active)::-webkit-slider-thumb{-webkit-box-shadow:0 0 0 10px rgba(38,166,154,0.26);box-shadow:0 0 0 10px rgba(38,166,154,0.26)}input[type=range].focused:focus:not(.active)::-moz-range-thumb{box-shadow:0 0 0 10px rgba(38,166,154,0.26)}input[type=range].focused:focus:not(.active)::-ms-thumb{box-shadow:0 0 0 10px rgba(38,166,154,0.26)} 番组计划 这里将是永远的回忆 window.onload = function(){ videos.forEach(function(video, i){ $('#rootRow').append(` ${video.title} ${video.jp} ${video.status} ${video.title} ${video.jp} 放送时间: ${video.time} ${video.desc} ${video.status} `) }) }","keywords":"B站"},{"title":"bangumi","date":"2019-02-10T13:32:48.000Z","updated":"2019-12-14T03:00:52.360Z","comments":false,"path":"bangumi/index.html","permalink":"/bangumi/index.html","excerpt":"","text":"","keywords":null}],"posts":[{"title":"使用jsDeliver和GitHub白嫖CDN","slug":"cdn","date":"2019-12-14T02:53:13.000Z","updated":"2019-12-14T02:55:20.185Z","comments":true,"path":"cdn/","link":"","permalink":"/cdn/","excerpt":"","text":"使用jsDeliver和GitHub白嫖CDN查看文档可知，jsDeliver CDN主要使用了GitHub的release版本特性： // load any GitHub release, commit, or branch // note: we recommend using npm for projects that support it https://cdn.jsdelivr.net/gh/user/repo@version/file 新建GitHub public仓库，名称就叫cdn。 在本地电脑克隆远程仓库，将需要的静态资源（比如图片、不超过20M的视频……）加入本地仓库，然后提交到远程仓库。 默认你已经配置好了GitHub的SSH，并且本地Git也已经配置用户和邮箱。参考《Pro Git》 git clone git@github.com:DragonBaby308/cdn.git cd cdn //添加静态资源，建议创建不同目录存储，防止太乱 mkdir js mkdir img mkdir movie git add . git commit -m &quot;release 1.0&quot; git push 在GitHub远程仓库中点击release发布。 通过jsDeliver引用资源 //加载js https://cdn.jsdelivr.net/gh/DragonBaby308/cdn@1.0/js/jquery.js //加载图片 https://cdn.jsdelivr.net/gh/DragonBaby308/cdn@1.0/img/db3.png","categories":[{"name":"GitHub","slug":"GitHub","permalink":"/categories/GitHub/"}],"tags":[{"name":"CDN","slug":"CDN","permalink":"/tags/CDN/"},{"name":"jsDeliver","slug":"jsDeliver","permalink":"/tags/jsDeliver/"},{"name":"GitHub","slug":"GitHub","permalink":"/tags/GitHub/"},{"name":"Git","slug":"Git","permalink":"/tags/Git/"}],"keywords":[{"name":"GitHub","slug":"GitHub","permalink":"/categories/GitHub/"}]},{"title":"Hexo主题 —— Sakura 入门","slug":"hexo-theme-sakura","date":"2019-12-13T09:20:00.000Z","updated":"2019-12-14T07:38:52.433Z","comments":true,"path":"hexo-theme-sakura/","link":"","permalink":"/hexo-theme-sakura/","excerpt":"","text":"Hexo主题 —— Sakura 入门使用NexT主题有一段时间了，做了很多魔改，舍不得放弃。但是看别人的Sakura主题好香，又觉得眼馋 呵，男人o(￣▽￣)o 所以我决定再白嫖一个.github.io的站点，这次使用Sakura主题：https://dragonbaby308.github.io/ （一）安装Hexo与hexo-theme-sakura 参考《静态博客Hexo搭建教程（本地、服务器两开花）》和《唯美主题hexo-sakura使用教程》 mkdir HexoSakura //默认你已经安装好了npm和hexo-cli hexo init 根据作者的建议，直接访问https://github.com/honjun/hexo-theme-sakura获取压缩包，解压到博客根目录（注意，不是主题目录！），替换原有文件，然后运行npm i安装依赖。到这一步，使用hexo clean &amp;&amp; hexo g &amp;&amp; hexo s就已经可以看到站点效果了，不过我们还需要进行一系列自定义的配置。 （二）配置1.站点配置文件_config.yaml（1）简介# Site # 主标题：这个是你鼠标放标签页显示的名称，主页的名称要在主题配置文件中设置 title: DragonBaby308 # 副标题：不展示 subtitle: # 描述：不展示 description: keywords: # 作者名 author: DragonBaby308 # 语言 language: zh-CN # 简体中文 timezone: （2）部署 默认你已经配置好了GitHub的SSH，并且本地Git也已经配置用户和邮箱。参考《Pro Git》 # Deployment ## Docs: https://hexo.io/docs/deployment.html deploy: type: git repo: https://github.com/DragonBaby308/DragonBaby308.github.io.git #你的github.io的网址 branch: master （3）备份 首先需要在你远程GitHub仓库新建一个backup分支。 # backup backup: type: git message: https://DragonBaby308.github.io/ 备份 repository: github: https://github.com/DragonBaby308/DragonBaby308.github.io.git,backup 配置完成后每次通过hexo clean &amp;&amp; hexo b &amp;&amp; hexo d -g就可以完成部署和备份。 2.主题配置文件theme/Sakura/_config.yaml# site name # 站点名前缀，可以省略 prefixName: 想进阿里の # 站点名，显示为：前缀+站点名 siteName: DB3 # favicon and site master avatar # 标签页小图标： favicon: XXXXX # 头像： avatar: XXXXX # 站点URL url: https://DragonBaby308.github.io/ # 描述 description: 2019年只剩下尾巴了，希望2020年春招可以进ATM！ # 站点CDN，可以为空，图片需要填完整路径 cdn: https://cdn.jsdelivr.net/gh/DragonBaby308/cdn@1.0 # 开启pjax pjax: 1 # 公告 notice: 我不玩游戏，我定规则。 # 懒加载的加载中图片 lazyloadImg: https://cdn.jsdelivr.net/gh/honjun/cdn@1.6/img/loader/orange.progress-bar-stripe-loader.svg # 站点菜单配置【暂时保持，以后慢慢改】 menus: 首页: { path: /, fa: fa-fort-awesome faa-shake } 归档: { path: /archives, fa: fa-archive faa-shake, submenus: { 技术: {path: /categories/技术/, fa: fa-code }, 生活: {path: /categories/生活/, fa: fa-file-text-o }, 资源: {path: /categories/资源/, fa: fa-cloud-download }, 随想: {path: /categories/随想/, fa: fa-commenting-o }, 转载: {path: /categories/转载/, fa: fa-book } } } 清单: { path: javascript:;, fa: fa-list-ul faa-vertical, submenus: { 书单: {path: /tags/悦读/, fa: fa-th-list faa-bounce }, 番组: {path: /bangumi/, fa: fa-film faa-vertical }, # 歌单: {path: /music/, fa: fa-headphones }, 图集: {path: /tags/图集/, fa: fa-photo } } } 留言板: { path: /comment/, fa: fa-pencil-square-o faa-tada } 友人帐: { path: /links/, fa: fa-link faa-shake } 赞赏: { path: /donate/, fa: fa-heart faa-pulse } 关于: { path: /, fa: fa-leaf faa-wrench , submenus: { 我: {path: /about/, fa: fa-meetup}, # 主题: {path: /theme-sakura/, fa: iconfont icon-sakura }, # Lab: {path: /lab/, fa: fa-cogs }, } } # 客户端: { path: /client/, fa: fa-android faa-vertical } RSS: { path: /atom.xml, fa: fa-rss faa-pulse } # 背景图片 bg: - XXXXX - XXXXX - XXXXX - https://cdn.jsdelivr.net/gh/yremp/cdn@2.1.5/img/cover/(2).jpg.webp - https://cdn.jsdelivr.net/gh/yremp/cdn@2.1.5/img/cover/(3).jpg.webp - https://cdn.jsdelivr.net/gh/yremp/cdn@2.1.5/img/cover/(4).jpg.webp - https://cdn.jsdelivr.net/gh/yremp/cdn@2.1.5/img/cover/(5).jpg.webp - https://cdn.jsdelivr.net/gh/yremp/cdn@2.1.5/img/cover/(7).jpg.webp # 背景图片样式： # 空：原图 # filter-dim：阴影 # filter-grid：横条 # filter-dot：点点 bgclass: filter-dot # 快速导航面板 # url：链接，如果是本站链接，可以简写 # title：大标题 # desc：描述 # img：背景图 startdash: # - {url: /theme-sakura/, title: Sakura, desc: 本站 hexo 主题, img: /img/startdash/sakura.md.png} - {url: https://space.bilibili.com/24837083, title: Bilibili, desc: 乾杯！！！, img: /img/startdash/bilibili.jpg} # your site build time or founded date # 建站时间 siteBuildingTime: 12/12/2019 # 社交按钮PC端 # url：链接 # qrcode：二维码 # img：图标 social: GitHub: {url: http://github.com/DragonBaby308, img: https://cdn.jsdelivr.net/gh/honjun/cdn@1.6/img/social/github.png} 掘金: {url: https://juejin.im/user/5cef386351882551b47a32f7, img: XXXXX} BiliBili: {url: https://space.bilibili.com/24837083, img: XXXXX} WeChat: {url: /#, qrcode: XXXXX, img: https://cdn.jsdelivr.net/gh/honjun/cdn@1.6/img/social/wechat.png} QQ: {url: /#, qrcode: XXXXX, img: https://cdn.jsdelivr.net/gh/yremp/cdn@2.1.5/img/social/qq.png} # 社交按钮移动端 # url：链接 # fontawesome：图标 # color：颜色 msocial: github: {url: http://github.com/DragonBaby308, fa: fa-github, color: 333} # weibo: {url: http://weibo.com/mashirozx?is_all=1, fa: fa-weibo, color: dd4b39} # qq: {url: https://wpa.qq.com/msgrd?v=3&amp;uin=954655431&amp;site=qq&amp;menu=yes, fa: fa-qq, color: 25c6fe} # 赞赏二维码 donate: alipay: XXXXX wechat: XXXXX # 首页视频 movies: # url前缀 url: https://cdn.jsdelivr.net/gh/DragonBaby308/cdn@1.0/movie/ # 多个视频用逗号隔开，随机获取。支持的格式目前已知MP4,Flv name: fujiko.mp4 # 左下角aplayer播放器配置 # id:歌单ID —— 在歌单的URL中会有体现，自己观察 # server:音乐服务器 —— tencent：QQ音乐 # autoplay：是否自动播放 aplayer: id: 3090329008 server: tecent type: playlist fixed: true mini: false autoplay: false loop: all order: random preload: auto volume: 0.7 mutex: true # Valine评论 # 记得要在LeanCloud -&gt; 设置 -&gt; 安全中心 -&gt; web安全域名 中，将新域名加进去 valine: true v_appId: XXXXX v_appKey: XXXXX 3.分类/标签页配置theme/Sakura/languages/zh-cn.yaml# category # 分类名称：需要和theme/Sakura/_config.yaml的menus属性对应 # 对应链接为：/categories 技术: #中文标题 zh: 野生技术协会 # 英文标题 en: Geek – Only for Love # 封面图片 img: https://cdn.jsdelivr.net/gh/honjun/cdn@1.6/img/banner/coding.jpg 算法: zh: 程序 = 数据结构 + 算法 en: Algorithm img: https://cdn.jsdelivr.net/gh/DragonBaby308/cdn@1.0/img/categories/Algorithm.jpg Java基础: zh: Java是世界上最好的语言！来战！ en: Java img: https://cdn.jsdelivr.net/gh/honjun/cdn@1.6/img/banner/coding.jpg Linux: zh: Talk is cheap, show me the code. en: Linux img: https://cdn.jsdelivr.net/gh/DragonBaby308/cdn@1.0/img/categories/Linux.jpg 随笔: zh: 我有一个埋在心里的梦想，就是成为一个畅销小说家，没有和几个人说过。 en: Code &amp; Poetry. img: https://cdn.jsdelivr.net/gh/DragonBaby308/cdn@1.0/img/categories/Novel.jpg 设计模式: zh: 设计模式 en: Design Pattern img: https://cdn.jsdelivr.net/gh/DragonBaby308/cdn@1.0/img/categories/DesignPattern.jpg 分布式: zh: 分布式 en: Distributed System img: https://cdn.jsdelivr.net/gh/DragonBaby308/cdn@1.0/img/categories/DistributedSystem.jpg Docker: zh: 容器比虚拟机更加轻量级。 —— 沃兹.基硕德 en: Docker img: https://cdn.jsdelivr.net/gh/DragonBaby308/cdn@1.0/img/categories/Docker.jpg Hexo: zh: Hexo是非常好用的静态博客。 —— 海氏.沃兹.基硕德 en: Hexo img: https://cdn.jsdelivr.net/gh/DragonBaby308/cdn@1.0/img/categories/Hexo.jpg GitHub: zh: 全世界最大同性交友平台 —— en: GayHub img: https://cdn.jsdelivr.net/gh/DragonBaby308/cdn@1.0/img/categories/GitHub.jpg Go: zh: Go语言设计得非常人性化，我愿意把它作为第二语言。 en: GoLang img: https://cdn.jsdelivr.net/gh/DragonBaby308/cdn@1.0/img/categories/Go.jpg # tag # 标签名称 # 对应链接为：/tags 悦读: # 封面图片 img: https://cdn.jsdelivr.net/gh/honjun/cdn@1.6/img/banner/reading.jpg 4.单页面封面配置比如“留言板”，修改/source/comment/index.md中的photos属性即可。 5.番组计划页source/bangumi/index.md注释只是为了描述每个属性的作用，自己配置时需要将所有注释删除！ --- layout: bangumi title: bangumi comments: false date: 2019-02-10 21:32:48 keywords: description: bangumis: # 番组图片 - img: https://lain.bgm.tv/pic/cover/l/0e/1e/218971_2y351.jpg # 番组名 title: 朝花夕誓——于离别之朝束起约定之花 # 追番状态 （追番ing/已追完） status: 已追完 # 追番进度 progress: 100 # 番剧日文名称 jp: さよならの朝に約束の花をかざろう # 放送时间 time: 放送时间: 2018-02-24 SUN. # 番剧介绍 desc: 住在远离尘嚣的土地，一边将每天的事情编织成名为希比欧的布，一边静静生活的伊欧夫人民。在15岁左右外表就停止成长，拥有数百年寿命的他们，被称为“离别的一族”，并被视为活着的传说。没有双亲的伊欧夫少女玛奇亚，过着被伙伴包围的平稳日子，却总感觉“孤身一人”。他们的这种日常，一瞬间就崩溃消失。追求伊欧夫的长寿之血，梅萨蒂军乘坐着名为雷纳特的古代兽发动了进攻。在绝望与混乱之中，伊欧夫的第一美女蕾莉亚被梅萨蒂带走，而玛奇亚暗恋的少年克里姆也失踪了。玛奇亚虽然总算逃脱了，却失去了伙伴和归去之地……。 - img: http://lain.bgm.tv/pic/cover/l/e9/15/179949_c2j50.jpg title: 小林家的龙女仆 status: 已追完 progress: 100 jp: 小林さんちのメイドラゴン time: null desc: 在单身的辛苦OL小林身边突然出现的女仆装束的美少女托尔。长着角和尾巴的她的身姿正是所谓的龙娘。在醉酒的小林邀请下说要到家里去的托尔，鬼使神差地开始以小林家女仆的身份工作……！？“女仆”+“龙”=“女仆龙”有着笨手笨脚的可爱之处！龙娘与人类之间基本上很温暖、偶尔有些黑暗的异种族间交流喜剧！！ - img: http://lain.bgm.tv/pic/cover/l/42/54/219164_TLkl2.jpg title: 鲁邦三世 PART5 status: 已追完 progress: 100 jp: ルパン三世 PART5 time: null desc: 鲁邦三世与次元大介身处法国。故事在某处乡间小镇的公寓一室开始。包括毒品枪械等非法物资在内，任何物品都能购买的地下网站，“马可波罗”。为了盗取虚拟货币，鲁邦等人侵入了戒备森严的巨大服务器设施。他们在那里遇到了神秘的天才黑客少女，阿米。鲁邦和阿米一起正面应对马可波罗的陷阱，但由于敌人设置的“鲁邦游戏”，而落得被全世界监视的下场……阿米身上接连揭晓的谜团，以及知晓鲁邦三世过去的男人出现——鲁邦正陷入前所未有的绝境！ --- 5.友链页source/links/index.md注释只是为了描述每个属性的作用，自己配置时需要将所有注释删除！ --- layout: links title: links # 创建日期，可以改下 date: 2018-12-19 23:11:06 # 图片上的标题，自定义修改 keywords: 友人帐 description: # true/false 开启/关闭评论 comments: true # 页面头部图片，自定义修改 photos: https://cdn.jsdelivr.net/gh/honjun/cdn@1.4/img/banner/links.jpg # 友链配置 links: # 类型分组 - group: 个人项目 # 类型简介 desc: 充分说明这家伙是条咸鱼 &lt; (￣︶￣)&gt; items: # 友链链接 - url: https://shino.cc/fgvf # 友链头像 img: https://cloud.moezx.cc/Picture/svg/landscape/fields.svg # 友链站点名 name: Google # 友链介绍 desc: Google 镜像 # 类型分组... - group: 小伙伴们 desc: 欢迎交换友链 ꉂ(ˊᗜˋ) items: - url: https://shino.cc/fgvf img: https://cloud.moezx.cc/Picture/svg/landscape/fields.svg name: Google desc: Google 镜像 --- （三）其他魔改1.startdash名称更改将/themes/Sakura/layout/_partial/startdash.ejs中的&lt;h1 ...&gt;startdash&lt;/h1&gt;改为&lt;h1 ...&gt;快速导航&lt;/h1&gt;。 2.Discovery名称更改将/themes/Sakura/layout/index.ejs中的&lt;h1 ...&gt;Discovery&lt;/h1&gt;改为&lt;h1 ...&gt;正文&lt;/h1&gt;。 3.文章链接更改将_config.yaml中的permalink属性修改为permalink: :title/。 4.新建帖子头部格式修改/scaffolds/post.md，可以将hexo n生成的博客头改为自定义格式： --- title: {{ title }} date: {{ date }} author: DragonBaby308 avatar: &#39;https://cdn.jsdelivr.net/gh/DragonBaby308/cdn@1.2/img/header/avatar.jpg&#39; authorLink: www.dragonbaby308.com authorAbout: 气是清风肉是泥。 authorDesc: 佯狂难免假成真。 categories: xxx comments: true tags: keywords: description: photos: xxx ---","categories":[{"name":"Hexo","slug":"Hexo","permalink":"/categories/Hexo/"}],"tags":[{"name":"CDN","slug":"CDN","permalink":"/tags/CDN/"},{"name":"jsDeliver","slug":"jsDeliver","permalink":"/tags/jsDeliver/"},{"name":"GitHub","slug":"GitHub","permalink":"/tags/GitHub/"},{"name":"Git","slug":"Git","permalink":"/tags/Git/"},{"name":"Hexo框架","slug":"Hexo框架","permalink":"/tags/Hexo框架/"},{"name":"Hexo主题","slug":"Hexo主题","permalink":"/tags/Hexo主题/"}],"keywords":[{"name":"Hexo","slug":"Hexo","permalink":"/categories/Hexo/"}]},{"title":"iTerm2和oh-my-zsh联合打造Mac终端","slug":"oh-my-zsh","date":"2019-12-10T14:21:27.000Z","updated":"2019-12-14T02:58:00.153Z","comments":true,"path":"oh-my-zsh/","link":"","permalink":"/oh-my-zsh/","excerpt":"","text":"iTerm2和oh-my-zsh联合打造Mac终端（一）iTerm21.安装并设置为默认终端 下载并安装iTerm2 将iTerm2设置为默认终端：iTerm2 -&gt; Make iTerm2 Default Term 2.背景图片设置 选择背景图片：iTerm2 -&gt; Preferences -&gt; Profiles -&gt; Window -&gt; Background Image -&gt; Enabled 设置透明度：通过Blending调节壁纸的透明度，透明度越高越透明 效果图： 3.字体设置 通过pip安装PowerLine： # 通过HomeBrew安装python3，获取easy-install brew install python3 # 通过pip获取PowerLine pip install powerline-status --user 在合适位置创建空目录，执行如下命令安装字体库： git clone https://github.com/powerline/fonts.git --depth=1 cd fonts ./install.sh # Powerline fonts installed to /Users/dragonbaby308/Library/Fonts cd /Users/dragonbaby308/Library/Fonts 设置字体：iTerm2 -&gt; Preferences -&gt; Profiles -&gt; Text -&gt; Font -&gt; 选择字体 4.配色设置 在合适位置创建空目录，执行如下命令下载配色： git clone https://github.com/altercation/solarized cd solarized/iterm2-colors-solarized/ # 打开Finder open . 在打开的窗口中，双击Solarized Dark.itermcolors和Solarized Light.itermcolors即可安装明暗两种配色： 设置配色：iTerm2 -&gt; Preferences -&gt; Profiles -&gt; Colors -&gt; Color Presets （二）oh-my-zsh1.安装 Mac默认使用dash作为终端，通过chsh -s /bin/zsh将默认终端修改为zsh 安装oh-my-zsh： sh -c &quot;$(wget https://raw.github.com/robbyrussell/oh-my-zsh/master/tools/install.sh -O -)&quot; 2.主题下载与配置 创建空目录，执行如下命令： git clone https://github.com/fcamblor/oh-my-zsh-agnoster-fcamblor.git cd oh-my-zsh-agnoster-fcamblor/ # 执行该命令会将主题拷贝到oh-my-zsh的themes目录下，当然你也可以手动进行 ./install 修改配置文件：vi ~/.zshrc # 将主题配置为ys ZSH_THEME=&quot;ys&quot; source ~/.zshrc使配置生效 3.插件安装 插件安装 # 语法高亮插件 sudo git clone https://github.com/zsh-users/zsh-syntax-highlighting.git $ZSH_CUSTOM/plugins/zsh-syntax-highlighting # 命令补全插件 sudo git clone https://github.com/zsh-users/zsh-autosuggestions $ZSH_CUSTOM/plugins/zsh-autosuggestions 修改配置文件：vi ~/.zshrc # zsh-syntax-highlighting必须是最后一个！ plugins=(git, zsh-autosuggestions, zsh-syntax-highlighting) source ~/.zshrc使配置生效 如果觉得自动补全颜色与背景色难以区分，可以在iTerm2 -&gt; Preferences -&gt; Profiles -&gt; Colors -&gt; 右侧ANSI Colors -&gt; Bright第一行中配置自动补全的字体颜色。","categories":[{"name":"Linux","slug":"Linux","permalink":"/categories/Linux/"}],"tags":[{"name":"GitHub","slug":"GitHub","permalink":"/tags/GitHub/"},{"name":"Git","slug":"Git","permalink":"/tags/Git/"},{"name":"Linux","slug":"Linux","permalink":"/tags/Linux/"},{"name":"Shell","slug":"Shell","permalink":"/tags/Shell/"},{"name":"Fun!!!!!!!","slug":"Fun","permalink":"/tags/Fun/"},{"name":"Mac","slug":"Mac","permalink":"/tags/Mac/"},{"name":"oh-my-zsh","slug":"oh-my-zsh","permalink":"/tags/oh-my-zsh/"},{"name":"iTerm2","slug":"iTerm2","permalink":"/tags/iTerm2/"},{"name":"python3","slug":"python3","permalink":"/tags/python3/"},{"name":"pip","slug":"pip","permalink":"/tags/pip/"},{"name":"HomeBrew","slug":"HomeBrew","permalink":"/tags/HomeBrew/"}],"keywords":[{"name":"Linux","slug":"Linux","permalink":"/categories/Linux/"}]},{"title":"GitHub小技巧","slug":"github","date":"2019-11-28T16:01:55.000Z","updated":"2019-12-14T02:57:07.226Z","comments":true,"path":"github/","link":"","permalink":"/github/","excerpt":"","text":"GitHub小技巧 （一）快捷键查看：shift + ?在任意界面输入shift + ?，可以显示快捷键。 （二）分享某段代码：#Lstart-Lend如果你想分享你的Github上某段代码，可以在URL后加#L开始行号-L结束行号，如：https://github.com/DragonBaby308/python_diy_crawlers/blob/master/xiumeim_crawler/xiumeim.py#L26-L32。其实也不需要特别去记，点中某行代码前的行号，URL后就会加#L行号，再按住shift，选择结束行号，URL就会加上#L开始行号-L结束行号。 （三）查看自己项目的访问数据：Insights - Traffic在自己的项目下，点击Insights-Traffic，里面有Referring sites（代表大家从什么网页来到你的项目）和Popular content（代表大家经常看你项目的什么文件）。 （四）编辑代码在查看任意文件时，右上角会有一个小铅笔的标识。 点击小铅笔就可以直接编辑文件，编辑完成后，直接在页面上点击Propose File Change，Github就会为你fork这个仓库，创建一个pull request，节省了在本地fork -&gt; pull -&gt; 修改 -&gt; push -&gt; 创建PR的过程。 （五）趋势图——https://octoverse.github.com/Github语言趋势图：https://octoverse.github.com/ （六）精确搜索项目 in:name keyWord：项目名中含有keyWord in:readme keyWord：项目README.md中含有keyWord in:description keyWord：项目描述中含有keyWord stars:&gt;N：星星数量大于N language:Golang：语言限定为Golang语言 pushed:&gt;2019-06-06：最后一次提交时间晚于2019-06-06 比如我想搜索Golang语言微服务项目，最后一次提交时间要晚于2019-06-06，星星数量大于1000个：in:description 微服务 language:go pushed:&gt;2019-06-06 stars:&gt;1000","categories":[{"name":"GitHub","slug":"GitHub","permalink":"/categories/GitHub/"}],"tags":[{"name":"GitHub","slug":"GitHub","permalink":"/tags/GitHub/"},{"name":"Git","slug":"Git","permalink":"/tags/Git/"},{"name":"Go","slug":"Go","permalink":"/tags/Go/"}],"keywords":[{"name":"GitHub","slug":"GitHub","permalink":"/categories/GitHub/"}]},{"title":"Crond定时任务","slug":"crond","date":"2019-10-28T14:37:32.000Z","updated":"2019-12-14T02:56:00.652Z","comments":true,"path":"crond/","link":"","permalink":"/crond/","excerpt":"","text":"Crond定时任务 Crond是Linux下用来周期性执行某种任务或者等待处理某些事件的一个守护进程。 当安装了OS后默认会自动启动Crond进程，每分钟定期检查是否有需要执行的任务，如果有则自动执行。 参考https://blog.csdn.net/qq_22172133/article/details/81263736 （一）Linux下的任务调度1.系统任务调度：/etc/crontab/etc目录下的crontab文件是系统任务调度的配置文件，记录了系统周期性所执行的工作，比如写缓存数据到硬盘、日志清理等。如： # 【Crond任务运行的环境变量】 # 指定使用哪个shell，比如bash SHELL=/bin/bash # 指定了系统执行命令的路径 PATH=/sbin:/bin:/usr/sbin:/usr/bin # Crond任务执行信息将通过电子邮件发送给root用户 MAILTO=&quot;root&quot; # 执行命令或脚本时使用的主目录 HOME=/ # 【此部分是crontab文件，第二节介绍】 51 * * * * root run-parts /etc/cron.hourly 24 7 * * * root run-parts /etc/cron.daily 22 4 * * 0 root run-parts /etc/cron.weekly 42 4 1 * * root run-parts /etc/cron.monthly 2.用户任务调度 /etc/cron.deny：不允许使用crontab命令的用户 /etc/cron.allow：允许使用crontab命令的用户 /var/spool/cron/：所有用户crontab文件存放的目录,以用户名命名 （二）crontab用户所建立的crontab文件中，每一行都代表一个任务，每行的每个字段代表一项设置。 1.文件格式minute hour day month week command minute：分钟，0 ~ 59之间的整数 hour：小时，0 ~ 23之间的整数 day：日期，1 ~ 31之间的整数 month：月份，1 ~ 12之间的整数 week：星期几，0 ~ 7之间的整数，0/7表示星期日 command：要执行的命令，可以是系统命令，也可以是自己写的脚本 特殊字符在上述字段中，可以使用特殊字符： *：星号 —— 表示所有可能的值，比如month字段为*表示每个月； ,：逗号 —— 用来指定一个范围列表，比如1,2,3,4,5,6,7； -：中杠 —— 用在整数中间表示一个整数范围，比如2-6表示2,3,4,5,6； /：正斜杠 —— 指定时间的间隔频率，比如hour字段为0-23/2表示每隔2小时执行一次；minute字段为*/10表示10分钟执行一次。 2.命令格式crontab [-u user] fileName crontab [-u user] [-e|-l|-r] -u user：设定某个用户的crontab服务 fileName：crontab文件名 -e：编辑某个用户的crontab文件内容，如果不指定用户，则编辑当前用户的 e for edit -l：显示某个用户的crontab文件内容，如果不指定用户，则显示当前用户的 l for list -r：删除某个用户的crontab文件内容，如果不指定用户，则删除当前用户的 r for remove （三）Crond服务 安装（一般不需要） yum install crontabs 启动/关闭/重启/重载服务 /sbin/service crond start #启动 /sbin/service crond stop #关闭 /sbin/service crond restart #重启 /sbin/service crond reload #重载配置 查看服务状态 service crond status","categories":[{"name":"Linux","slug":"Linux","permalink":"/categories/Linux/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"/tags/Linux/"},{"name":"ECS","slug":"ECS","permalink":"/tags/ECS/"},{"name":"Crond","slug":"Crond","permalink":"/tags/Crond/"},{"name":"定时任务","slug":"定时任务","permalink":"/tags/定时任务/"}],"keywords":[{"name":"Linux","slug":"Linux","permalink":"/categories/Linux/"}]},{"title":"分布式系统理论基础","slug":"Distributed-System","date":"2019-09-06T13:01:40.000Z","updated":"2019-12-14T02:56:32.487Z","comments":true,"path":"Distributed-System/","link":"","permalink":"/Distributed-System/","excerpt":"","text":"分布式系统理论基础 分布式系统目标 提升系统整体性能和吞吐量 尽量保证分区容错性，即在分布式系统遇到某节点或网络分区故障时，仍要能够对外保证满足一致性和可用性的服务 分布式系统设计思路：中心化/去中心化1.中心化 中心化分布式系统中存在两类角色：Leader/Follower Leader负责分发任务，并监控整个系统，如果有Follower不工作则将其踢出整个系统 Follower负责执行Leader分配的任务 比如MySQL的Master/Slave架构，Master和Slave的角色是生来就是确定的。 又或者你可以参考现实中的黑心企业，领导负责分配工作给手底下的员工，并且监控员工，如果有员工过劳病倒了不能工作，领导不会尝试医治他，而是会直接开除他。 中心化分布式系统 存在的问题 &amp; 解决 单点故障问题：一旦Leader宕机，整个系统就不可用 解决：①多Leader热备或冷备，一旦Leader故障可以自动/手动切换②直接用去中心化取代中心化，一旦Leader宕机就重新进行选举 Leader能力会限制系统的扩展 2.去中心化 去中心化分布式系统不意味着没有Leader，而是由Follower来自由选择Leader。 一旦Leader宕机，集群中的Follower就会自发举行新一轮的选举，推选出新的Leader。 ZK中ZAB协议的Master选举就是此类。 去中心化分布式系统 存在的问题 &amp; 解决 网络分区（“脑裂”） 解决：小集群“自杀”或拒绝服务 基础理论（一）CAP理论 C：Consistency，一致性 —— 所有节点访问同一份最新数据副本 强一致性：任何时间所有节点访问到的数据都是最新的。最终一致性：不保证任何时间所有节点访问到的数据都是最新的，但是保证一定时间后系统中的数据都是最新的。 A：Availability，可用性 —— 每次请求都能收到非错响应，但是不保证获取的数据是最新数据 P：Partition Tolerance，分区容错性 —— 在分布式系统遇到某节点或网络分区故障时，仍能够对外保证满足一致性和可用性的服务 CAP理论常被认为是一致性（C）、可用性（A）、分区容错性（P）只能3选2。但是实际上，分区容错性（P）是分布式系统的基本能力，必须要保证。 C/A的取舍 在发生网络分区（P）的情况下，如果想要保证继续服务，那么强一致性（C）和可用性（A）只能2选1。 保证强一致性，放弃可用性 —— 可以保证用户看到的数据都是最新的数据，但是代价是响应时间急剧增加，一般不可取。 保证可用性，放弃强一致性 —— 首先保证用户的体验，允许用户看到的数据不是最新的，只保证在一定时间后系统中的数据会一致（即最终一致性） （二）BASE理论 BA：Basically Available，基本可用性 —— 在集群故障时，允许损失一部分的可用性，但绝不允许系统不可用 如：①响应时间增加；②系统功能的损失：大促期间，为了保证系统的稳定性，部分消费者会被引导到一个降级页面 S：Soft-state，软状态 —— 允许数据存在中间状态，即允许不同数据副本之间的同步存在延迟 E：Eventually Consistent，最终一致性","categories":[{"name":"分布式","slug":"分布式","permalink":"/categories/分布式/"}],"tags":[{"name":"分布式","slug":"分布式","permalink":"/tags/分布式/"},{"name":"CAP","slug":"CAP","permalink":"/tags/CAP/"},{"name":"BASE","slug":"BASE","permalink":"/tags/BASE/"},{"name":"ZooKeeper","slug":"ZooKeeper","permalink":"/tags/ZooKeeper/"},{"name":"ZAB","slug":"ZAB","permalink":"/tags/ZAB/"},{"name":"MySQL","slug":"MySQL","permalink":"/tags/MySQL/"},{"name":"高可用","slug":"高可用","permalink":"/tags/高可用/"}],"keywords":[{"name":"分布式","slug":"分布式","permalink":"/categories/分布式/"}]},{"title":"算法专题：排序","slug":"Algorithm-sort","date":"2019-08-16T12:24:26.000Z","updated":"2020-02-14T07:21:55.568Z","comments":true,"path":"Algorithm-sort/","link":"","permalink":"/Algorithm-sort/","excerpt":"","text":"排序 稳定性一个排序算法的稳定性是指，如果a=b，排序前a在b前面，那么排序后a也要在b的前面。即排序后元素的相对位置不变。 简单来说： 如果一个排序算法会将某个元素单独提到某个位置，那么它就是不稳定的； 如果一个排序算法只涉及两两相邻元素之间的交换，那么它就是稳定的。 稳定排序：冒泡排序、插入排序、希尔排序、归并排序 不稳定排序：选择排序、快排、堆排序 1.选择排序（O(N^2)） 选择排序（Selection Sort）每次排序时，从未排序序列中“选择”一个元素加入排序序列，因此得名。 选择排序需要两次遍历 —— 第一遍是遍历所有元素，确认已排序的序列范围[0,i)；第二遍是遍历所有未排序序列[i,lastIndex]，每次将当前位置与队首（i）元素比较，选择最小元素，交换到队首，所以选择排序的时间复杂度是O(N^2) 选择排序是不稳定排序，因为存在将元素单独提到某个位置的情况 //选择排序 public static int[] selectionSort(int[] in) { int lastIndex = in.length - 1; //即：循环遍历次数 for (int i = 0; i &lt;= lastIndex; i++) { //每次遍历，将最小元素浮动到最左边 //0~i是已排序序列，i~lastIndex是未排序序列，将未排序中的最小元素放在i位置 for(int j = i; j &lt;= lastIndex; j++) { //默认in[i]是最小元素，如果in[j]小于in[i]，则交换 if (in[j] &lt; in[i]) { //如果i=j，那么in[i]=in[j] //所以可以保证in[i]、in[j]是不同对象，可以通过异或进行交换 in[i] = in[i] ^ in[j]; in[j] = in[i] ^ in[j]; in[i] = in[i] ^ in[j]; } } } return in; } 选择排序 &amp; 插入排序 的区别：选择排序是每次从未排序序列中选择最小/最大的元素，加入已排序序列；插入排序是每次按顺序从未排序序列中选择一个元素，加入已排序序列中的合适位置；也就是说，选择排序遍历的未排序序列，插入排序遍历的已排序序列。 2.冒泡排序（O(N^2)） 冒泡排序（Bubble Sort）每次排序时，将未排序序列最大元素“浮动”到尾部，因此得名。 冒泡排序需要两次遍历 —— 第一遍是遍历所有元素，确认已排序的序列范围[lastIndex - i, lastIndex]；第二遍是遍历所有未排序序列（0, lastIndex - i），相邻元素两两比较，将最大元素浮动到队尾，所以冒泡排序的时间复杂度是O(N^2) 冒泡排序是稳定排序，因为只涉及相邻元素两两比较 //冒泡排序 public static int[] bubbleSort(int[] in) { int lastIndex = in.length - 1; for (int i = 0; i &lt;= lastIndex; i++) { //[lastIndex - i,lastIndex]是排好序的序列 //[0,lastIndex - i)是未排好序的序列 for(int j = 0; j &lt;= lastIndex - i - 1; j++) { //与选择排序不同，冒泡排序是两两相邻元素比较后交换 //将较大的交换到后面 if (in[j + 1] &lt; in[j]) { //不同元素异或交换 in[j + 1] = in[j] ^ in[j + 1]; in[j] = in[j] ^ in[j + 1]; in[j + 1] = in[j] ^ in[j + 1]; } } } return in; } 2.1 冒泡排序优化：交换标志位对冒泡排序的优化是加入一个交换标志位，如果某一次循环中没有进行数据交换，说明剩余的序列已经是有序的了，可以不再进行后续的循环。 //优化冒泡排序——加入交换标志位 public static int[] flagBubbleSort(int[] in) { //标志位：本趟排序是否进行了交换 //如果本趟排序没有进行元素交换，说明已经有序了，可以提前结束循环 boolean exchange; int lastIndex = in.length - 1; for (int i = 0; i &lt;= lastIndex; i++) { exchange = false; //[lastIndex - i,lastIndex]是排好序的序列 //[0,lastIndex - i)是未排好序的序列 for(int j = 0; j &lt;= lastIndex - i - 1; j++) { //与选择排序不同，冒泡排序是两两相邻元素比较后交换 //将较大的交换到后面 if (in[j + 1] &lt; in[j]) { //不同元素异或交换 in[j + 1] = in[j] ^ in[j + 1]; in[j] = in[j] ^ in[j + 1]; in[j + 1] = in[j] ^ in[j + 1]; exchange = true; //发生了交换 } } if(!exchange) break; //无交换直接退出循环 } return in; } 3.插入排序（O(N^2)） 在形容插入排序时，一般都会类比摸扑克。你的手牌就是已排序序列，牌堆就是未排序序列，每次摸牌时会选择手排中的合适位置插入。我的习惯就是强迫按顺序插好牌 - - ||| ，后来我才发现其他孩子摸牌根本不会像我一样，他们都是一把抓在手里面的，所以每次玩扑克他们都要等我抓好牌=====(￣▽￣*)b 插入排序（Insertion Sort）的原理就是将序列分为两个部分，一部分是已排序序列，另一部分是未排序序列，每次从未排序序列中选择一个元素插入已排序序列中的合适位置 插入排序需要两次循环——第一次是遍历所有元素，确定已排序序列[0,i)；第二次是遍历所有已排序序列[0,i)，将位置i的元素插入已排序序列的合理位置——由于遍历的序列是已经排好序的，所以这一步只需要用到一个临时变量。所以插入排序的时间复杂度是O(N^2) 使用一个临时变量temp存储位置i的元素。从j=i位置开始向前遍历，如果in[j] &gt; temp，那么j--；如果in[j] &lt;= temp，那么交换j位置元素和temp，然后j--，继续比较in[j]和temp。 插入排序是稳定性排序，因为只涉及到相邻元素两两比较 //插入排序 public static int[] insertionSort(int[] in) { int lastIndex = in.length - 1; //从1开始遍历，是默认最开始的已排序序列就是第一个元素，index=0 for (int i = 1; i &lt;= lastIndex; i++) { int temp = in[i]; //待比较元素 //注意i不能比1小，否则就会数组越界 while (i &gt;= 1 &amp;&amp; in[i - 1] &gt; temp) { //已排序序列[0,i)，最大下标i - 1 //i - 1位置元素大于待比较元素，i - 1位置元素后移 in[i] = in[i - 1]; i--; } //退出循环说明找到了合适的位置 in[i] = temp; } return in; } 3.1 希尔排序（O(NlogN)）/缩小增量排序 希尔排序（Shell Sort）是一种改进的插入排序，也成为缩小增量排序，1959年由Donald Shell提出。希尔排序采用了分治的思想，将原序列分为若干个子序列，对子序列分别进行插入排序，所以它的时间复杂度也理所应当是O(NlogN) 初始增量gap = len / 2，随后每次循环gap = gap / 2，直到减为1，循环终止。增量gap的意义是将序列分为多少子序列。 希尔排序存在非相邻元素交换位置，所以希尔排序是不稳定排序。 如图： 初始分组gap = len / 2 = 5，将原序列分为5组，要求每组元素之间间隔尽可能大，所以是{i, i + gap, i + 2 gap, …, i + n gap} 对5组子序列分别进行插入排序，将较小的元素交换到前面 交换完后，gap /= 2，将原序列重新分为2组，要求每组元素之间间隔尽可能大，所以是{i, i + gap, i + 2 gap, …, i + n gap} 对2组子序列分别进行插入排序，将较小的元素交换到前面 gap = 2 / 1 = 1，进行最后一次插入排序，结束循环 //希尔排序 public static int[] shellSort(int[] in) { int gap = in.length &gt;&gt; 1; //初始值，gap = len / 2 while (gap &gt; 0) { //从gap开始是因为默认[0,gap)是排好序的 //即每个子序列第一个元素是排好序的，一共gap个元素 //将序列分为gap组，对子序列进行插入排序 for (int i = gap; i &lt; in.length; i++) { int temp = in[i]; //限制了gap&gt;0，所以只需要 i-gap&gt;=0 而非 1 while ((i - gap &gt;= 0) &amp;&amp; (in[i - gap] &gt; temp) ) { in[i] = in[i - gap]; i -= gap; //每次跨度为一个gap } //退出循环说明找到了合适位置 in[i] = temp; } gap = gap &gt;&gt; 1; //gap = gap / 2 } return in; } 希尔排序 vs 插入排序：插入排序是稳定的，希尔排序不稳定；希尔排序比较次数和移动次数都要明显小于插入排序，N越大越明显；希尔排序不适用于链式结构 4.归并排序（O(NlogN)） 合并两个有序子序列的过程：创建一个和两个字序列长度和等长的序列，分别用一个指针指向两个子序列的头部，将两个子序列头部较小的那个加入到新序列，最后一个序列全部被加入新序列，就可以把另一个序列剩下的元素加入新序列。所以归并排序需要额外的内存空间 //合并两个有序子序列 //@params: left[] 左子序列 //@params: right[] 右子序列 public static void merge(int[] left, int[] right) { //结果序列，用于合并两个子有序序列 int[] rst = new int[left.length + right.length]; //左子序列、右子序列、总序列当前位置 int l = 0, r = 0, curr = 0; //遍历，直到某个子序列被遍历完，将较小的放前面 while (l &lt; left.length &amp;&amp; r &lt; right.length) { if (left[l] &lt; right[r]) { rst[curr] = left[l]; l++; curr++; }else{ rst[curr] = right[r]; r++; curr++; } } //剩余序列直接加入结果序列 while(l &lt; left.length) { rst[curr] = left[l]; l++; curr++; } while (r &lt; right.length) { rst[curr] = right[r]; r++; curr++; } return rst; } 归并排序（Merge Sort）利用了分治的思想，将序列不断进行二分，直到每组子序列只剩下两个元素（“分”），然后对这两个元素进行排序（“治”），最后将所有子序列两两进行合并，合并时重新排序（“合”），所以时间复杂度是O(NlogN) 归并排序只涉及相邻元素之间的交换，所以是稳定性排序 //归并排序：递归地使用二分法，将一个序列分解为两个子序列，直到子序列只剩下一个元素 //@params: in[] public static int[] mergeSort(int[] in) { //退出递归的条件：子序列只剩下一个元素 if(in == null || in.length &lt; 2) return in; int mid = in.length &gt;&gt; 1; //从中间将序列切分 //Arrays.copyOfRange(int[] a, int from, int to); 复制范围[from,to) int[] left = Arrays.copyOfRange(in, 0, mid); //不包括mid int[] right = Arrays.copyOfRange(in, mid, in.length); //递归调用mergeSort，然后将结果merge合并 return merge(mergeSort(left), mergeSort(right) ); } 测试： int[] in = {999, 1, 2, 4, 3, -1, 0, 0}; System.out.println(&quot;归并排序： &quot; + Arrays.toString(mergeSort(in))); //归并排序： [-1, 0, 0, 1, 2, 3, 4, 999] 5.快速排序（O(NlogN)） 参考了https://cloud.tencent.com/developer/article/1403566，说的很详细。 快速排序（Quick Sort）的中心思想是每次选取一个基准值（pivot），然后通过比较与交换，使得pivot左边的元素都小于pivot，pivot右边的元素都大于pivot；然后再通过二分法，对pivot左右的子序列分别进行快排。所以快排的时间复杂度是O(NlogN) pivot一般直接选择最左元素 交换pivot左右元素用到了快慢指针法——快指针从右往左遍历，直到找到比pivot小的元素；慢指针从左往右遍历，直到找到比pivot大的元素。由于我们的目的是让左边的更小，右边的更大，所以我们将快慢指针元素进行交换（交换之前要判断慢指针是否超过了快指针）。 如下图： 基准值是最左端元素6。慢指针i，从左往右；快指针j，从右往左 j先走，当遇到比基准值小的元素时停止（5&lt;6）；然后i再走，遇到比基准值大的元素时停止（7&gt;6） 如果慢指针没有超过快指针，就将快慢指针所在元素进行交换 重复以上步骤，直到快慢指针相遇，将快慢指针所在位置元素与基准值进行交换，基准值指针指向快慢指针所在位置 交换完成后，基准值左边的元素就都小于基准值，基准值右边的元素都大于基准值 以上操作都是相对的，如果pivot选择了最右元素，那么快指针就应该是从左往右遍历的那个 递归地对基准值左右序列进行快排，直到元素全部有序。退出递归的条件——子序列只剩下一个元素，即存在low &gt; high 同样是上述序列{6,1,2,7,9,3,4,5,10,8}，如果慢指针i先走会发生什么?（1）pivot=6，i=7&gt;6，j=5&lt;6，交换i与j：{6,1,2,&quot;5&quot;,9,3,4,&quot;7&quot;,10,8}；（2）i=9&gt;6，j=4&lt;6，交换i与j：{6,1,2,5,&quot;4&quot;,3,&quot;9&quot;,10,8}；（3）i=9=j，交换i/j与pivot：{&quot;9&quot;,1,2,5,4,3,&quot;6&quot;,10,8}，9&gt;6，很明显结果不对。结论：如果快指针先走，可以保证快慢指针相遇时元素值小于pivot，交换过来后可以保证pivot左边元素都小于pivot；但是如果慢指针先走，很可能相遇时元素值就大于pivot，交换后pivot左边就会存在比pivot大的元素。 public static void quickSort(int[] in, int low, int high) { //退出递归条件：子序列只有一个元素，此时low = high if(low &gt; high) return; int pivot = in[low]; //基准值，选最左边元素 int quick = high; //快指针，比慢指针先走一步，从右往左 int slow = low; //慢指针，从左往右 //当quick遇到了比pivot小的元素， //同时slow遇到了比pivot大的元素，那么就交换两个元素 while (slow &lt; quick) { //快指针要先走一步 //快指针向左，直到找到比pivot小的元素 while (in[quick] &gt;= pivot &amp;&amp; slow &lt; quick) { quick--; } //慢指针往右，直到找到比pivot大的元素 while (in[slow] &lt;= pivot &amp;&amp; slow &lt; quick) { slow++; } //需要再次判断slow是否已经遇到或超过了quick if (slow &lt; quick) { //交换两个元素 —— 可以肯定slow!=quick，是不同元素， //所以可以用异或交换两个元素 in[slow] = in[slow] ^ in[quick]; in[quick] = in[slow] ^ in[quick]; in[slow] = in[slow] ^ in[quick]; } } //将快慢指针所在位置元素与基准值进行交换 //slow与quick相遇的位置，就是基准值指针应该在的位置 in[low] = in[slow]; in[slow] = pivot; //slow或者quick就是新的pivot，左边元素都比它小，右边元素都比它大 //递归对pivot的左右序列进行快排 quickSort(in, low, slow - 1); //基准值不需要再排序，所以是slow-1 quickSort(in, slow + 1, high); //基准值不需要再排序，所以是slow+1 } 测试： int[] in = {999, 1, 2, 4, 3, -1, 0, 0}; quickSort(in, 0, in.length - 1); System.out.println(Arrays.toString(in)); //结果为：[-1, 0, 0, 1, 2, 3, 4, 999] 5.1 彩虹排序（NlogK，K是元素种类）彩虹排序适用于序列中元素种类是已知常数的情况。 彩虹排序（Rainbow Sort）是一种变种的快排，快排是从元素N中选择基准值进行分治，所以时间复杂度是O(NlogN)，而彩虹排序则是从元素种类K中选择基准值进行分治，所以时间复杂度是O(NlogK)，而K是常数。 具体的分治策略是：递归地从种类K中选择一个基准值，每次使得基准值左边的种类编码小于基准值，右边的种类编码大于基准值 结束递归的条件： 普通快排的结束递归条件：序列中只有一个元素，low == high（或者low &gt; high） 彩虹排序中额外的结束递归条件：序列中只有一种元素，elementFrom == elementTo（或者elementFrom &gt; elementTo） elementFrom、elementTo是指子序列（下标从start到end）中元素种类从第elementFrom种到第elementTo种，即元素种类范围。 参考LintCode 143. Sort Colors II这题，看看彩虹排序的实际应用： /** * @param colors: A list of integer * @param k: An integer * @return: nothing */ public static void sortColors2(int[] colors, int k) { if (colors == null || colors.length == 0) return; rainbowSort(colors, 0, colors.length - 1, 1, k); } //彩虹排序 //@params: colors[] 输入序列，包含从colorFrom到colorTo种类的颜色 //@params: start 子序列开始位置 //@params: end 子序列结束位置 //@params: colorFrom 颜色种类开始位置 //@params: colorTo 颜色种类结束位置 private static void rainbowSort(int[] colors, int start, int end, int colorFrom, int colorTo) { //结束递归的条件： // 1.传统快排结束条件：子序列只有一个元素； // 2.彩虹排序结束条件：子序列只有一种元素 if (start == end || colorFrom == colorTo) return; //中间颜色，即基准值pivot int colorMid = (colorFrom + colorTo) &gt;&gt; 1; int left = start, right = end; while (left &lt;= right) { //找到基准值左边大于基准值的元素 while (left &lt;= right &amp;&amp; colors[left] &lt;= colorMid) left++; //找到基准值右边小于基准值的元素 while (left &lt;= right &amp;&amp; colors[right] &gt; colorMid) right--; //再次判断，如果此时left指针没有超过right指针，就交换两个位置元素 if (left &lt;= right) { //可能相等，不能用异或 int temp = colors[left]; colors[left] = colors[right]; colors[right] = temp; left++; right--; } } //由于基准值选择的是中间位置，所以不需要将基准值交换到left所在位置 rainbowSort(colors, start, right, colorFrom, colorMid); rainbowSort(colors, left, end, colorMid + 1, colorTo); //基准值可以不作为子序列参与下一轮循环 } 测试： public static void main(String[] args) { int[] in = {3,2,2,1,4}; sortColors2(in, 4); System.out.println(Arrays.toString(in)); //[1,2,2,3,4] } 6.堆排序（O(N + KlogN)，K是排序序列长度）如果想得到一个序列中第K个最小元素之前的部分序列，最好采用堆排序！！！ 堆排序存在非相邻元素之间的交换，所以是非稳定排序 堆的特定： 堆是一棵完全二叉树。可以用数组表示，节点k有如下特点：父节点为(k-1)/2，左孩子为2k + 1，右孩子为2k + 2。 如果是大根堆，那么对于任何节点，其父节点都会比所有子节点大；如果是小根堆，那么对于任何节点，其父节点都会比所有子节点小 参考上图，理解了下面3个问题，也就理解了堆排序： 给定一个数组表示的满二叉树，如何构建一个堆？或者说，对一个堆进行了修改后，如何保证修改后的序列仍是一个堆？ heapify：对于任意节点来说，堆都有父亲节点大于（或小于）左右儿子的特点，所以，对于任意节点，将其与其左右儿子比较大小，将最大的元素替换到父亲节点，对替换下去的节点重复进行此操作，即可将满二叉树构建成堆。 比如说上图，对于5-7-8这棵子树来说，5&lt;8，所以将5和8交换位置，然后重新对替换下去的5节点进行heapify //heapify：将满二叉树构建为堆 //@param: tree[] 表示堆的数组 //@param: n 节点总数 //@param: i 对哪个节点进行heapify public static void heapify(int[] tree, int n, int i) { if(i &gt;= n) return; //结束递归条件：建堆节点下标超过节点总数，i&gt;=n //根据满二叉树的特点，有： int left = 2 * i + 1; //左子树 int right = 2 * i + 2; //右子树 //将父亲、左右子树3者中最大的数替换到父亲节点 int max = i; //注意left 和 right不能越界 if(left &lt; n &amp;&amp; tree[left] &gt; tree[max]) max = left; if (right &lt; n &amp;&amp; tree[right] &gt; tree[max]) max = right; if(max != i) { //如果父亲节点就是最大节点，就不需要重新建堆了 //交换max和i的元素 tree[max] = tree[max] ^ tree[i]; tree[i] = tree[max] ^ tree[i]; tree[max] = tree[max] ^ tree[i]; //对替换下去的节点重新建堆 heapify(tree, n, max); } } 通过步骤1，我们有了将一个修改后的堆还原成堆的能力，那么给定一个数组表示的满二叉树，如何构建出初始的堆？ 我们可以从树的倒数第二层（h-1层）逆序地对每个节点进行heapify操作，直到根节点，这样我们就能得到一个初始堆。 为什么不从树的倒数第一层（h层）开始heapify呢？因为倒数第一层没有子节点，本身就是满二叉树，没有heapify的必要。 那么如何确定倒数第二层的下标呢？我们知道满二叉树中，k节点的父亲节点是(k-1)/2，我们可以确定倒数第一层的最后一个节点（即数组尾部），该节点的父亲节点正好就位于倒数第二层，这就是我们heapify的起点//初始建堆 //@params: tree[] 满二叉树 //@params: n 节点总数 public static void buildHeap(int[] tree, int n) { int last = tree.length; int parent = (last - 1) &gt;&gt; 1; //倒数第二层 for(int i = parent; i &gt;= 0; i--) { heapify(tree, n, i); } } 现在我们有了一个初始堆，有了能够将更改后的堆构建成新堆的能力，如何进行堆排序？ 堆的特点是父亲节点大于（或小于）儿子节点，那么其根节点必定是最大的（最小的），也就是说我们每次构建好堆，都能得到一个剩余元素的最大值（最小值） 将根节点（最大值/最小值）与堆尾元素（也就是数组队尾）进行交换，然后将堆尾剔除并记录下来（当然这是逻辑上的剔除，实际上你可以在heapify的时候不传入堆尾即可），并对剩余元素重新进行heapify。重复此步骤，直到已排序的序列长度满足要求。//堆排序 //@params: tree[] 满二叉树 //@params: n 节点总数 public static void heapSort(int[] tree, int n) { //构建初始堆 buildHeap(tree, n); //如果只需要k个有序序列，可以提前结束循环 for(int i = n - 1; i &gt;= 0; i--) { //将根节点与堆尾进行交换 int temp = tree[i]; tree[i] = tree[0]; tree[0] = temp; //剔除堆尾的最大值，对剩余元素重新进行heapify heapify(tree, i, 0); } } 归并排序 vs 快排 vs 堆排序 如果从空间复杂度来考虑，首选堆排序，然后是快排，最后是归并排序（需要额外的内存空间） 如果是从稳定性来考虑，应选择归并排序，因为快排和堆排序并不稳定 如果从平均情况下的排序速度来考虑，应该选择快排 7.基数排序（O(N*D)，D为位数，N为元素个数） 通过对排序的N个元素进行若干趟“分配”与“收集”来实现排序 基数排序（Radix Sort）不需要交换元素位置，所以是稳定性排序 基数排序效率与初始序列是否有序没有关联 在基数排序中，对于任何位数上的基数进行装桶操作时，都需要n + r个临时空间 任何一个阿拉伯数字，它的各个位数上的基数都是以0 ~ 9 来表示的，我们将0 ~ 9视为10个桶。如：给定序列{50,123,543,187,49,30,0,2,11,100} 首先根据个位数元素分到指定的桶中。 将桶中元素按顺序依次弹出，即{50,30,0,100,11,2,123,543,187,49} 再根据十位数将元素分到指定桶中。 将桶中元素按顺序依次弹出，即{0,100,2,11,123,30,543,49,50,187} 再根据百位数将元素分到指定桶中。 将桶中元素按顺序依次弹出，此时元素就已经有序了 //基数排序 //不考虑负数的情况 public static int[] radixSort(int[] in) { int len = in.length; if (len &lt; 2 || in == null) return in; //0~9：10个桶，每一个桶是一个不定长的ArrayList ArrayList&lt;ArrayList&lt;Integer&gt;&gt; buckets = new ArrayList&lt;ArrayList&lt;Integer&gt;&gt;(); for (int i = 0; i &lt; 10; i++) buckets.add(new ArrayList&lt;Integer&gt;()); //找出序列中的最大值——不能用排序算法，不然还基数排序个什么劲？ int max = in[0]; for (int i = 1; i &lt; len; i++) max = in[i] &gt; max ? in[i] : max; //根据最大值，判断位数——即需要循环入桶、出桶的次数 int digit = 0; while (max != 0) { max /= 10; digit++; } //入桶 &amp; 出桶 int mod = 10, div = 1; for (int i = 0; i &lt; digit; i++, mod *= 10, div *= 10) { //遍历序列，入桶 for (int j = 0; j &lt; len; j++) { int temp = (in[j] % mod) / div; //判断对应位的元素，存入桶中 //ArrayList API: T get(int index); &amp; add(T t); buckets.get(temp).add(in[j]); } //遍历所有桶，出桶 int[] newArray = new int[len]; //出桶序列 int cnt = 0; for (int outArrayIndex = 0; outArrayIndex &lt; buckets.size(); outArrayIndex++) { for (int inArrayIndex = 0; inArrayIndex &lt; buckets.get(outArrayIndex).size(); inArrayIndex++) { newArray[cnt++] = buckets.get(outArrayIndex).get(inArrayIndex); //等价于： //newArray[cnt] = buckets.get(outArrayIndex).get(inArrayIndex); //cnt++; } //记得出桶后要清空桶，不能影响下一次循环 buckets.get(outArrayIndex).clear(); } //出桶序列替换原序列 for (int j = 0; j &lt; len; j++) in[j] = newArray[j]; } return in; } 8.计数排序计数排序（Counting Sort） 9.桶排序桶排序（Bucket Sort） 10.拓扑排序 入度：指向节点的边的个数（比如图中节点1的入度就是0） 使用BFS进行拓扑排序 找到图中入度为0的节点，从图中移除 被移除节点指向的节点，入度减1 重复2、3 如果最后不存在入度为0的节点，说明图中有环，这时候拓扑排序无解","categories":[{"name":"算法","slug":"算法","permalink":"/categories/算法/"}],"tags":[{"name":"算法","slug":"算法","permalink":"/tags/算法/"},{"name":"排序","slug":"排序","permalink":"/tags/排序/"},{"name":"位运算","slug":"位运算","permalink":"/tags/位运算/"},{"name":"分治法","slug":"分治法","permalink":"/tags/分治法/"},{"name":"递归","slug":"递归","permalink":"/tags/递归/"},{"name":"冒泡排序","slug":"冒泡排序","permalink":"/tags/冒泡排序/"},{"name":"选择排序","slug":"选择排序","permalink":"/tags/选择排序/"},{"name":"插入排序","slug":"插入排序","permalink":"/tags/插入排序/"},{"name":"希尔排序","slug":"希尔排序","permalink":"/tags/希尔排序/"},{"name":"归并排序","slug":"归并排序","permalink":"/tags/归并排序/"},{"name":"堆排序","slug":"堆排序","permalink":"/tags/堆排序/"},{"name":"基数排序","slug":"基数排序","permalink":"/tags/基数排序/"},{"name":"计数排序","slug":"计数排序","permalink":"/tags/计数排序/"},{"name":"桶排序","slug":"桶排序","permalink":"/tags/桶排序/"},{"name":"快排","slug":"快排","permalink":"/tags/快排/"},{"name":"图","slug":"图","permalink":"/tags/图/"},{"name":"拓扑排序","slug":"拓扑排序","permalink":"/tags/拓扑排序/"},{"name":"BFS","slug":"BFS","permalink":"/tags/BFS/"},{"name":"队列","slug":"队列","permalink":"/tags/队列/"},{"name":"彩虹排序","slug":"彩虹排序","permalink":"/tags/彩虹排序/"},{"name":"双指针","slug":"双指针","permalink":"/tags/双指针/"},{"name":"ArrayList","slug":"ArrayList","permalink":"/tags/ArrayList/"},{"name":"Arrays","slug":"Arrays","permalink":"/tags/Arrays/"}],"keywords":[{"name":"算法","slug":"算法","permalink":"/categories/算法/"}]},{"title":"GayHub上一些有趣的项目【持续更新~】","slug":"fun-with-GayHub","date":"2019-08-04T09:47:11.000Z","updated":"2019-12-14T02:56:58.272Z","comments":true,"path":"fun-with-GayHub/","link":"","permalink":"/fun-with-GayHub/","excerpt":"","text":"GayHub上一些有趣的项目 （一）reveal-md：使用.md来做PPT详细信息见reveal-md项目地址。相似的还有用HTML做PPT展示的reveal.js。 安装npm install -g reveal-md 使用reveal-md path/demo.md，其中，path/demo.md是你的Markdown文件地址，可以使用本地地址，也可以使用URL。使用如下的Markdown文件： # Title * Point 1 * Point 2 --- ## Second slide &gt; Best quote ever. Note: speaker notes FTW! 效果如图： 通过solarized主题使用reveal-md path/demo.md --theme solarized效果如图： （二）Logoly.Pro：不正经的Logo生成器该项目可以根据你输入的文字创建PornHub风格的Logo（知道PornHub是什么的坏孩子请面壁思过）。GitHub仓库地址Logoly.Pro在线版 比如，我输入DragonBaby，然后点击Export：修改theme/_config.yaml的avatar属性，就可以将导出的图片作为我个人博客的头像啦~ （三）emoji-mosaic：将图片转成emoji标签马赛克GitHub仓库地址emoji-mosaic在线版（有一说一，这个在线版属实简约嗷……） 效果图如下： （四）gifi：在你执行npm install时放gif图 gifi：注意它不是在你的终端播放，而是浏览器打开gif图播放，所以酌情安装。 （五）bash-insulter：在输入错误bash命令时进行羞辱的脚本Github项目地址。 git clone首先你服务器需要安装了Git。通过git clone https://github.com/hkbakke/bash-insulter bash-insulter命令克隆项目到本地。 将下载内容移动到/etc目录下sudo cp bash-insulter/src/bash.command-not-found /etc/ 修改/etc/bash.bashrc文件vim /etc/bash.bashrc打开文件，在末尾添加： #Bash Insulter if [ -f /etc/bash.command-not-found ]; then . /etc/bash.command-not-found fi source /etc/bash.bashrc 使修改生效source /etc/bash.bashrc 生效后，输入错误的bash命令就会被狠狠羞辱： （六）the-fuck：输入错误bash命令后通过fuck进行修正 the-fuck项目地址 Mac下通过brew install thefuck安装 vim ~/.bashrc，修改： eval &quot;$(thefuck --alias)&quot; source ~/.bashrc使之生效，输入错误bash命令后通过fuck命令即可进行修正，如： (base) bogon:~ dragonbaby308$ git brach git: &#39;brach&#39; is not a git command. See &#39;git --help&#39;. The most similar command is branch (base) bogon:~ dragonbaby308$ fuck git branch [enter/↑/↓/ctrl+c] （七）12306抢票 12306抢票 未测试。 （八）变声器 变声器 未测试。 （九）狗屁不通文章生成器 狗屁不通文章生成器-GitHub地址 狗屁不通文章生成器-网页版","categories":[{"name":"GitHub","slug":"GitHub","permalink":"/categories/GitHub/"}],"tags":[{"name":"GitHub","slug":"GitHub","permalink":"/tags/GitHub/"},{"name":"Git","slug":"Git","permalink":"/tags/Git/"},{"name":"Linux","slug":"Linux","permalink":"/tags/Linux/"},{"name":"Shell","slug":"Shell","permalink":"/tags/Shell/"},{"name":"Vim","slug":"Vim","permalink":"/tags/Vim/"},{"name":"前端","slug":"前端","permalink":"/tags/前端/"},{"name":"Markdown","slug":"Markdown","permalink":"/tags/Markdown/"},{"name":"Node.js","slug":"Node-js","permalink":"/tags/Node-js/"},{"name":"Vue.js","slug":"Vue-js","permalink":"/tags/Vue-js/"},{"name":"Fun!!!!!!!","slug":"Fun","permalink":"/tags/Fun/"},{"name":"JS","slug":"JS","permalink":"/tags/JS/"},{"name":"Homebrew","slug":"Homebrew","permalink":"/tags/Homebrew/"},{"name":"Mac","slug":"Mac","permalink":"/tags/Mac/"}],"keywords":[{"name":"GitHub","slug":"GitHub","permalink":"/categories/GitHub/"}]},{"title":"树莓派入门","slug":"raspberry-pi","date":"2019-07-07T05:59:25.000Z","updated":"2019-12-14T02:58:16.063Z","comments":true,"path":"raspberry-pi/","link":"","permalink":"/raspberry-pi/","excerpt":"","text":"树莓派入门外设 之前某活动白嫖的Raspberry Pi 3B一个 32G Sandisk micro SD卡一张 读卡器一个 USB接口5V、2A充电器一个 HDMI线一条 HDMI显示器一个（我直接用的客厅的电视机） 键盘、鼠标 wifi模块一个（3B+及以上的不需要） 安装Raspbian系统Raspberry Pi官方推荐的系统是Raspbian，是Debian的定制版。推荐使用NOOBS（New Out Of the Box Software）安装系统。 下载NOOBS 注意选择NOOBS，而不是NOOBS LITE。NOOBS LITE不含系统，在安装时需要网络支持。 将SD卡格式化为FAT格式，我用的是DiskGenius 将NOOBS.zip解压到SD卡根目录 注意根目录需要的是如下图的详细内容，而不是一个NOOBS_v3_1_1的子文件夹。 插入SD卡，接通电源，打开树莓派 一路回车，就可以安装好系统。 SSH登录 点击左上角树莓图标，Preference -&gt; Raspberry Pi Configuration -&gt; Interfaces -&gt; SSH设置为Enabled，之后就可以通过SSH登录树莓派。我是用的是XShell。树莓派默认用户为pi，密码raspberrypi，登录后可以通过passwd修改密码。 ifconfig查看IP 连接","categories":[{"name":"Linux","slug":"Linux","permalink":"/categories/Linux/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"/tags/Linux/"},{"name":"Raspberry Pi","slug":"Raspberry-Pi","permalink":"/tags/Raspberry-Pi/"}],"keywords":[{"name":"Linux","slug":"Linux","permalink":"/categories/Linux/"}]},{"title":"Docker应用：使用NextCloud搭建私有云盘","slug":"docker-nextcloud","date":"2019-07-06T12:13:06.000Z","updated":"2019-12-14T02:56:42.945Z","comments":true,"path":"docker-nextcloud/","link":"","permalink":"/docker-nextcloud/","excerpt":"","text":"Docker应用：使用NextCloud搭建私有云盘连接服务器，安装Docker 首先你要有自己的服务器，并且要有连接服务器的工具。在《阿里云ECS上搭建私人Git仓库》一文中介绍了XShell的安装。 同时你需要在服务器上安装Docker，参考《Docker基础》。 如果你是用的是阿里云ECS，那么你还需要打开对应端口的权限，参考《阿里云ECS上安装Nginx》。 拉取镜像，创建NextCloud容器docker run -d -p yourHostPort:yourContainerPort nextcloud，其中yourHostPort是你想要打开的服务器端口，yourContainerPort是你想打开的容器端口，一般默认是80，这里我选择了8081:80。 docker run命令参数回顾：-d 后台运行-p 指定端口 hostPort:containerPort 如果没有pull镜像的话，docker run的时候会自动去pull最新的nextcloud镜像。 通过docker images命令可以查看下载好的镜像；通过docker ps -a命令可以查看创建的容器。 使用NextCloud使用URL:8081或IP:8081的方式登录，输入管理员账户、密码后，你的NextCloud云盘就创建成功了。 你可以下载对应的客户端对它进行操作。","categories":[{"name":"Docker","slug":"Docker","permalink":"/categories/Docker/"}],"tags":[{"name":"Docker","slug":"Docker","permalink":"/tags/Docker/"},{"name":"NextCloud","slug":"NextCloud","permalink":"/tags/NextCloud/"}],"keywords":[{"name":"Docker","slug":"Docker","permalink":"/categories/Docker/"}]},{"title":"Docker 、 k8s 基础","slug":"docker","date":"2019-07-01T05:21:30.000Z","updated":"2019-12-14T02:56:50.696Z","comments":true,"path":"docker/","link":"","permalink":"/docker/","excerpt":"","text":"Docker 、 k8s 基础 （一）镜像（创建容器） &amp; 容器（封装为镜像）镜像：目的内容的一个封装，不可以改变内容。容器：可以改变内容，相当于虚拟机，默认情况下彼此封闭。 一般我们做的，就是通过镜像创建容器；当我们改变了容器的内容之后，也可以重新将容器封装为镜像。 容器(Container) vs 虚拟机(VM)Docker项目的目标是实现轻量级的操作系统虚拟化解决方案。 区别 VM：VM是硬件层面上的虚拟化。一个VM包含了应用、必须的bin/lib库，同时每个VM都必须要有Guest OS，每个都高达数十MB。 容器：容器是OS层面上的虚拟化。一个容器只包含了应用和必须的bin/lib库，所有容器共享宿主机的Host OS，但是在独立的进程上运行，可以隔离性地使用系统资源。 底层原理：LXC(Linux Container)。namespace：每个容器有各自的命名空间，用于逻辑隔离。cgroup：每个容器在Linux中有自己的分组和权限，可以用于互不干扰地访问系统资源。 容器的优点 单个容器使用的是宿主机的OS，不包含自己的OS，所以容器要比VM更加轻量级，开销更小，开发、测试、部署都更快，迁移也更方便； 容器的启动可以在秒级实现，比VM快得多； 一台主机上可以运行数千个容器，对系统资源的利用率比VM高得多 （二）安装CentOS下，yum -y install docker即可。我的版本是Docker version 1.13.1, build b2f74b2/1.13.1。 （三）使用Docker服务的启动 &amp; 停止：systemctl start/stop docker启动：systemctl start docker停止：systemctl stop docker Docker的镜像搜索：searchdocker search keyword：根据关键字，在互联网搜索镜像。如：docker search ubuntu Docker的镜像下载：pulldocker pull imageName：根据镜像名下载镜像。如：docker pull docker.io/ubuntu。 Docker本地镜像查看：imagesdocker images：查看所有本地镜像 Docker容器的创建（基于镜像创建虚拟机） &amp; 命名：run –namedocker run -tid --name containerName imageID：可以通过docker images查看imageID，一般取前4位即可。如：docker run -tid --name DistributedCrawlerUbuntu 4c10。 docker run参数及其含义：-p 指定端口号-ti 以交互的方式创建-d 后台创建-tid 创建一个容器并运行，但不进入容器里面-e 设置环境变量-p 宿主端口：容器端口-v 宿主目录：容器目录，挂载容器数据卷 Docker容器启动docker start containerID/containerName：通过ID或者名称启动某个停止的容器 Docker容器的查看：ps -adocker ps -a：查看当前所有运行的容器 Docker容器的进入：attachdocker attach containerID：可以通过docker ps -a查看containerID，一般取前4位即可。 在运行的容器中执行命令：docker execdocker exec -it ContainerName + 命令，比如docker exec -it MongoDB bash。 Docker容器的不停止退出：ctrl + p + q + Enterctrl + p + q，按下回车，即可不停止容器但是退出。 基于容器封装为Docker镜像：commitdocker commit containerID imageName:version：将已有的容器封装为镜像，containerID可以通过docker ps -a获得。如：docker commit e4cc distributed_crawler:v1 （四）网络配置：run –link linkContainerNamedocker run -tid --name containerName --link linkContainerName iamgeID/Name：在创建容器时，使其与某个容器保持网络通畅。如： docker run -tid --name host1 distributed_crawler:v1 # 创建host1 docker run -tid --name host2 --link host1 distributed_crawler:v1 # 创建host2时，link host1 （五）DockerFileDockerFile是对镜像的源码级别的描述文件。 关键字如下： FROM 基础镜像：当前镜像是基于哪个镜像的 MAINTAINER 镜像维护者的姓名和邮箱 RUN 容器构建时需要的命令 EXPOSE 当前容器对外暴露的端口 WORKDIR 创建容器后，终端默认登录进来的工作目录，一个落脚点 ENV 构建容器的过程中设置环境变量，如Java、MySQL…… ADD 将host目录下的文件拷贝进镜像，且ADD命令会自动处理URL和解压tar包 COPY 类似ADD，拷贝文件和目录到镜像 VOLUME 容器数据卷，用于数据的持久化 CMD 指定一个容器启动时需要运行的命令；DockerFile中可以有多个CMD命令，但只有最后一个会生效，且CMD会被docker run之后的参数替换 ENTRYPOINT 指定一个容器启动时需要运行的命令 ONBUILD 当构建一个被继承的DockerFile是运行命令，子镜像继承父镜像后，父镜像中的ONBUILD被触发 （六）容器数据卷(volume)容器关闭后，数据需要共享和持久化，容器数据卷(volume)就是完成此功能的，它类似于Docker的移动硬盘。 特点 数据卷可以在容器之间共享或重用数据 卷中的更改直接生效。不管是在host还是container中数据卷中修改了内容，另一方都能同步收到更新，即使container已经退出也可以更新。 卷中的更改不会包含在镜像的更新中 卷的生命周期一直持续到没有容器使用它为止 如何添加容器数据卷 在DockerFile中的VOLUME属性下添加； 直接命令添加：docker run -it -v /hostPath:/containerPath imageName。其中hostPath是宿主机绝对路径目录；containerPath是容器内目录；imageName是镜像名。 挂载Read-Only的容器数据卷： docker run -it -v /hostPath:/containerPath:ro imageName如何查看已经挂载了哪些容器数据卷？ docker inspect containerID命令，查看Volumes属性下的对应关系 （七）Docker-Compose 参考https://blog.51cto.com/9291927/2310444 简介 Docker-Compose是Docker官方的开源项目，负责实现对Docker容器集群的快速编排。 Docker-Compose的默认配置文件为docker-compose.yml Docker-Compose允许用户通过一个docker-compose.yml文件来定义一组相关联的应用容器作为一个项目。 安装# 下载 sudo curl -L https://github.com/docker/compose/releases/download/1.23.0-rc3/docker-compose-`uname -s`-`uname -m` -o /usr/local/bin/docker-compose # 更改权限 sudo chmod +x /usr/local/bin/docker-compose # 查看版本 docker-compose version docker-compose.yml文件格式包含version、services、networks三大部分： services： image：指定服务的镜像名称/ID，如果本地不存在，会尝试拉取 command：覆盖容器启动后默认执行的命令 ports：以HOST:CONTAINER的格式进行端口映射 volumes：挂载数据卷容器 version: &#39;3&#39; services: elasticsearch: image: elasticsearch:7.3.1 environment: discovery.type: single-node ports: - &quot;9200:9200&quot; - &quot;9300:9300&quot; logstash: image: logstash:7.3.1 command: logstash -f /etc/logstash/conf.d/logstash.conf volumes: # 挂载logstash配置文件 - ./config:/etc/logstash/conf.d - /user/elk/logs/:/opt/build/ ports: - &quot;5000:5000&quot; kibana: image: kibana:7.3.1 environment: -ELASTICSEARCH_URL=http://elasticsearch:9200 ports: - &quot;5601:5601&quot; Docker-Compose命令 启动：docker-compose up （八）Demo1.MongoDBdocker pull mongo # 运行 ：-p 进行端口映射；-v 容器数据卷挂载目录；-e 配置环境变量；-d 后台运行 docker run --name MongoDB -p 27017:27017 -v ~/docker-data/mongo:/data/db -e MONGO_INITDB_ROOT_USERNAME=root -e MONGO_INITDB_ROOT_PASSWORD=****** -d mongo # 查看 docker ps -a # 登录MongoDB docker exec -it MongoDB bash mongo -u root -p ****** # help # show dbs 启动web监控进入MongoDB容器后运行db.enableFreeMonitoring()会得到一个url，通过该url可以web健康你的MongoDB容器（不过贼鸡儿慢就是了……）： 2.Redisdocker pull redis docker run --name Redis -d -p 6379:6379 redis 3.MySQL主从# 端口映射：master 3307；slave01 3308 docker run --name master -p 127.0.0.1:3307:3306 -e MYSQL\\_ROOT\\_PASSWORD=xxxxxx -d mysql:5.6 docker run --name slave01 -p 127.0.0.1:3308:3306 -e MYSQL\\_ROOT\\_PASSWORD=xxxxxx -d --link master mysql:5.6 4.RedisSearch：高性能Redis全文搜索模块docker pull redislabs/redisearch:latest （九）Maven依赖包括：dockerfile-maven-plugin、maven-dependency-plugin &lt;plugin&gt; &lt;groupId&gt;com.spotify&lt;/groupId&gt; &lt;artifactId&gt;dockerfile-maven-plugin&lt;/artifactId&gt; &lt;version&gt;1.3.4&lt;/version&gt; &lt;configuration&gt; &lt;repository&gt;${docker.image.prefix}/${project.artifactId}&lt;/repository&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;plugin&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;maven-dependency-plugin&lt;/artifactId&gt; &lt;executions&gt; &lt;execution&gt; &lt;id&gt;unpack&lt;/id&gt; &lt;phase&gt;package&lt;/phase&gt; &lt;goals&gt; &lt;goal&gt;unpack&lt;/goal&gt; &lt;/goals&gt; &lt;configuration&gt; &lt;artifactItems&gt; &lt;artifactItem&gt; &lt;groupId&gt;${project.groupId}&lt;/groupId&gt; &lt;artifactId&gt;${project.artifactId}&lt;/artifactId&gt; &lt;version&gt;${project.version}&lt;/version&gt; &lt;/artifactItem&gt; &lt;/artifactItems&gt; &lt;/configuration&gt; &lt;/execution&gt; &lt;/executions&gt; &lt;/plugin&gt; （十）Kubernetes（k8s）Kubernetes（简称k8s）是谷歌开源的容器集群管理系统，在Docker技术的基础上，为容器的应用提供部署运行、资源调度（Kube-proxy）、服务发现（Kublet）和动态伸缩等一系列完整功能，提高了大规模容器集群管理的便捷性。 k8s架构 Master Node：主节点，提供管理整个k8s集群的控制面板； API server：所有REST命令的入口，是主节点内唯一的用户可以访问的组件； Datastore：持续、高可用的K/V数据存储中心； Scheduler：监控新创建的容器组（pod），并将其加入节点中； Contoller manager：管理k8s集群内处理例行任务的控制器； Worker Node：运行容器组（pod），管理容器之间的网络，和Master Node交流； Docker：节点内的单独容器； Kublet：监控容器组（pod）状态，保证所有容器正常启动、运行，并且负责和Datastore交互； Kube-proxy：单个节点内的路由网关和负载均衡器； Kubectl：提供给用户的命令行工具，用于与k8s API服务器通信 etcd：高可用、强一致性的服务发现存储仓库，一般是集群，采用的协议是Raft，通过全局锁保证强一致性 k8s集群规模限制 &amp; 优化","categories":[{"name":"Docker","slug":"Docker","permalink":"/categories/Docker/"}],"tags":[{"name":"分布式","slug":"分布式","permalink":"/tags/分布式/"},{"name":"MySQL","slug":"MySQL","permalink":"/tags/MySQL/"},{"name":"高可用","slug":"高可用","permalink":"/tags/高可用/"},{"name":"Docker","slug":"Docker","permalink":"/tags/Docker/"},{"name":"MongoDB","slug":"MongoDB","permalink":"/tags/MongoDB/"},{"name":"Redis","slug":"Redis","permalink":"/tags/Redis/"},{"name":"Spring","slug":"Spring","permalink":"/tags/Spring/"},{"name":"Maven","slug":"Maven","permalink":"/tags/Maven/"},{"name":"k8s","slug":"k8s","permalink":"/tags/k8s/"},{"name":"架构","slug":"架构","permalink":"/tags/架构/"},{"name":"REST","slug":"REST","permalink":"/tags/REST/"},{"name":"微服务","slug":"微服务","permalink":"/tags/微服务/"},{"name":"etcd","slug":"etcd","permalink":"/tags/etcd/"}],"keywords":[{"name":"Docker","slug":"Docker","permalink":"/categories/Docker/"}]},{"title":"《Debug》","slug":"Debug","date":"2019-05-22T14:37:35.000Z","updated":"2019-12-22T14:16:44.605Z","comments":true,"path":"Debug/","link":"","permalink":"/Debug/","excerpt":"","text":"应该是五一假期期间，我在归乡的大巴上偶然间看到了B站的“文豪试炼场”活动，主题是“如果突然世界末日了，我要怎么生存”。 我本来只是随便一瞥就准备关掉的，当时正是996.ICU占据热搜的时间，不知怎么的，我的脑子里突然就浮现出一个“程序员996加班加点解决了BUG，但自己却在内部结构优化时被当成BUG给解决掉了”的点子，于是我想，要不我把它写下来吧。我只是一个在校学生，虽然毕业后会是程序员，但至少还有好几个月可以舒舒服服地过。这个点子并没有多推陈出新，甚至有些跑题，我的文笔也实属平庸，我不是什么公知大V，写来下甚至不会有人能看到，我想：“我何必费力不讨好呢？” 但是我想到了马丁.尼莫拉写纳粹屠杀犹太人的诗——《我没有说话》：“起初他们迫害共产党员，我没有说话，因为我不是马克思的信徒。”“后来他们迫害犹太人，我没有说话，因为我是日耳曼人。”“再后来他们迫害天主教徒，我没有说话，因为我是新教牧师。”“最后他们迫害到我头上，我环顾四周，却再也没有人能为我说话。” 于是我在大巴上构思，回到家后，花了一个晚上，写下了这篇《Debug》，并试着进行了投稿，果不其然稿件被退回，“让你996正是给你奋斗的机会啊”、“我不给你加班费那就不算加班咯”几句被勒令修改。说来实在讽刺！这些字句我甚至没有经过任何夸张，全是“有良心的企业家”们的原话！所有人都只看到了B站作为国内最大的二次元聚集地，其风气开放、言论自由，但没人看到B站也有程序员，他们也是要加班的，对996的反对，也损害到了B站的利益。自媒体的控股者是企业家，企业家怎么会为被剥削者发声！ 我是个很倔的人，想着既然心血已经付出，只要能有一个人看到，这件事情也就值得，于是我不得不妥协，修改了部分措辞后重新进行了投稿，但是由于未被划分到“文豪试炼场”之类，所以根本就没有人看到。 我以为这些文字也就石沉大海了，我所做的只不过是为了无愧于心，但是几天后，居然有人看到了这篇文章，还在评论区表现出了他的赏识： 有一个人看到了，我的目的达到了。 2019年5月22日，我在自己的服务器上搭好了Hexo博客，将我的第一篇正式投稿作品记录下来，三五年后再来看看，我的笔力是否有所长进。 《Debug》 &emsp; &emsp; 我是“程序漏洞”，即俗称的bug，不同于我那些在开发环境就被发现的短命兄弟们，我一直隐姓埋名，苟活到了生产环境，并暗中观察着程序外的世界。 &emsp; &emsp; 从摄像头传回的数据来看，今天屏幕前坐着的仍是那个秃顶油腻中年男子——我的夙敌，两个月来，他一直致力于发现我的蛛丝马迹，好几次我都是险死还生。 &emsp; &emsp; 一阵信息扰动传来，屏幕右下角的通讯软件闪烁起来，网络中传来一条id叫“老板”的人发来的讯息——“小陈，今年还是你值班。”这让我的逻辑模块十分费解——明明老板比秃头年纪要小，怎么叫他“小陈”呢？ &emsp; &emsp; 秃头蹙眉，回道：“可是老板，去年就是我，我已经两年没回家见二老了。” &emsp; &emsp; 老板道：“你好好工作，赚了钱给他们买些补品，不就尽了孝道吗？你这上有老下有小，让你996正是给你奋斗的机会啊！” &emsp; &emsp; 秃头回道：“那老板，加班费的事情？” &emsp; &emsp; 老板道：“我拿你当兄弟，你可不要胡说！我是个有良心的企业家，时刻遵守劳动法的，我不给你加班费那就不算加班咯。” &emsp; &emsp; 秃头怒目圆睁，喘着粗气飞速在聊天框输入了一串字符——“01000011 01001110 01001101……”[注1]，正在这时，他的手机响了起来，扬声器捕捉到了他的声音—— &emsp; &emsp; “老婆。” &emsp; &emsp; “我也没有办法，工作也是为了养家，你理解一下——” &emsp; &emsp; “当然是家人重要，但不工作怎么养活一家三口？何况你肚子里又有了——” &emsp; &emsp; “不是怪你！不是怪你！全是我的错，这样吧，等忙完这一阵，我一定带你和晨晨出去旅游，咱好好放松一下。” &emsp; &emsp; “又要交补课费？上次不是才交……6000！这个月还有房贷……孕检吗？我记得了。” &emsp; &emsp; “不用麻烦岳父岳母了，我来想办法，怎么说我也是一家之主嘛。” &emsp; &emsp; “晚安，有事千万打我电话。” &emsp; &emsp; 他挂断了电话，揉了揉惺忪的睡眼，看了看聊天框未发送的消息，叹了一大口气，默默地全部删除掉。 &emsp; &emsp; 他的手机又响了—— &emsp; &emsp; “妈！” &emsp; &emsp; “我没事，身体好得很！您不用瞎操心！能有什么事，我都当爹的人了，能照顾好自己的。” &emsp; &emsp; “我实在没有办法，工作忙。明年，明年我准回来。” &emsp; &emsp; “我不累，我自己有分寸的，哪有那么容易猝死的。老板栽培，看得起我——不说这个了，爸还在生气？” &emsp; &emsp; “您劝劝他吧，我明年一定回！” &emsp; &emsp; “诶！拜拜。” &emsp; &emsp; 他摘掉了眼镜，捂住了双眼，几分钟后，用湿润的双手，给老板发了一条“谢谢”。 &emsp; &emsp; 谢什么呢？我的逻辑模块又开始费解了，真希望我能有人类的情感模块啊。老板显然就听懂了，他回复道：“你知道就好，这几个月你天天精神不好，也不好好干活，你那个部门有个小伙子每天加班到4点呢！你的工资那么高，下面的年轻人都盯着你的位置呢，你这让我很为难啊。” &emsp; &emsp; 秃子回道：“我知道，家里最近有些情况，我一定注意，不会让私生活影响工作了，老板你看能不能加薪？” &emsp; &emsp; 老板道：“这个月内，你先把线上那个bug给我解决了再说吧。” &emsp; &emsp; 于是我的日子越来越难过了，秃子开始没日没夜地盯着屏幕，左手PageDown，右手滚轮，我的世界里一道侦查的光从天逡巡，所到之处，天崩地裂、山摧海啸，世界开始崩坏了，我放眼望去，容身之所已经所剩无几了。 &emsp; &emsp; 天啊！秃子终于查到了那条调用链，我被逼到了悬崖边，万丈深渊下是灼热的熔浆，我已经无路可退了。 &emsp; &emsp; 当你凝视bug时，bug也在凝视你。这就是我的终焉了，我想。 &emsp; &emsp; 我记下了时间戳——“1549209599”[注2]，希望有人能帮我写在墓志铭——bug日志上。 &emsp; &emsp; 我的生命慢慢消逝，临死前，我看到秃子闭着眼点了一颗烟，嘴角带着似有若无的笑，仿佛在追蹑往昔峥嵘岁月，忽然一阵信息扰动传来——“你干的不错，bug修复了，加薪的事情我想了想，不能答应你。明天你自愿离职吧。” &emsp; &emsp; 秃子的笑僵在了嘴角上。 注 01000011 01001110 01001101是二进制码的CNM。 1549209599是Unix时间戳，转换为日期格式就是2019-02-03 23:59:59，大年夜。","categories":[{"name":"随笔","slug":"随笔","permalink":"/categories/随笔/"}],"tags":[{"name":"Novel","slug":"Novel","permalink":"/tags/Novel/"},{"name":"996","slug":"996","permalink":"/tags/996/"}],"keywords":[{"name":"随笔","slug":"随笔","permalink":"/categories/随笔/"}]},{"title":"静态博客Hexo搭建教程（本地、服务器两开花）","slug":"hexo","date":"2019-05-22T12:31:42.000Z","updated":"2019-12-14T02:58:08.639Z","comments":true,"path":"hexo/","link":"","permalink":"/hexo/","excerpt":"","text":"静态博客Hexo搭建 —— 本地、服务器两开花 静态博客 —— Hexo静态博客：是指没有后端数据库的博客，所有文章都是以文件的形式存储，是一种纯前端的博客框架。 本地安装1. 安装Node.js因为Hexo是通过Node.js生成的，所以首先需要根据自己的操作系统版本下载并安装Node.js。根据步骤提示进行操作后，在item（Windows是cmd）中输入命令：node -v如果能正确显示Node.js版本，则说明安装成功（本人使用的版本为v10.15.3）。 2. 通过npm安装Hexo框架Node.js安装成功后，同时会自动安装一个包管理器，称为npm（Node Package Manager）。 什么是npm？ npm是一个包管理器，发布者将自己的代码发布（npm publish）到代码仓库（registry），使用者将自己需要的包写入package.json文件中，到代码仓库中把代码下载（npm install）下来。 安装：npm install -g hexo-cli查看版本：hexo -v（本人使用的Hexo版本为1.1.0） 由于npm代码仓库的服务器在国外，由于Great Firewall的缘故，下载速度可能不尽如人意，这时你可以使用淘宝的npm代码仓库，通过npm安装cnpm：npm install -g cnpm --registry=https://registry.npm.taobao.org安装成功后，可以通过以下命令查看cnpm版本：cnpm -v通过cnpm来操作下载速度会得到很大提升，但包的版本不一定是最新的。 本地使用1. 创建目录Hexo的所有文章都是以文件的形式存储在目录下的，所以首先需要新建一个目录，我的是Hexo，在此目录下操作。 2. 初始化博客hexo init 3. 新建文章hexo new &quot;BlogName&quot;（BlogName是你的文章名称）会在source/_posts目录下生成BlogName.md文件，可以vim或其他Markdown编辑器进行修改。 4. 生成博客静态文件hexo g（g代表generate），生成博客静态文件每次修改文章后，都需要通过hexo clean清理一下，然后通过hexo g重新生成，最后也不要忘了通过hexo s重新启动Hexo。 5. 启动博客hexo s（s代表server，默认端口号是4000） 6. 更换主题将需要更换的主题下载并解压缩到theme/yourThemeName目录下，yourThemeName是你给主题取的名字，如我用的主题是next，只需要解压缩到Hexo/themes/next目录下即可,当然你也可以直接在Hexo目录下执行git clone https://github.com/theme-next/hexo-theme-next themes/next，解压完成后，修改_config.yaml文件中的theme属性，默认是landscape，修改为next： # Extensions ## Plugins: https://hexo.io/plugins/ ## Themes: https://hexo.io/themes/ theme: next #注意：“theme:”后要带一个空格 每次修改主题后，都需要通过hexo clean清理一下，然后通过hexo g重新生成，最后也不要忘了通过hexo s重新启动Hexo。 《Hexo主题 —— NexT优化》 7. 其他_config.yaml配置_config.yaml文件是Hexo项目的全局配置文件，常用的属性有： # Site # 站点标题 title: DragonBaby308&#39;s Blog # 站点副标题 subtitle: Fighting for BAT! # 站点描述 description: 记住迄今为止每一次失败时有心无力的感受，“为了更美好的明天而战”。 # 作者 author: DragonBaby308 # 语言—— 请注意，官方语言包不再支持简体中文zh-Hans，而是统一采用了zh-CN language: zh-CN # 时区——默认是本地时区 timezone: # URL # 站点地址 url: http://106.14.153.30 # 站点root，如果网站存在子目录中，url设置为&#39;http://yoursite.com/child&#39;，root设置为&#39;/child/&#39; root: / # 生成固定链接的格式 permalink: :title/ permalink_defaults: # Pagination # 每页文章数——关闭分页：0 per_page: 10 # Extensions # 主题 theme: next # Deployment # 部署配置 deploy: type: git repo: git@106.14.153.30:/usr/DragonBaby308/repo/blog.git branch: master 服务器部署（一） 本地 + github.io 白嫖部署1. 生成github.io仓库首先注册并登录GitHub，创建新public仓库，仓库名称一定要是：YourGitHubName.github.io（YourGitHubName是你的GitHub昵称，大小写敏感！） 2. 本地安装Hexo的git部署插件在Hexo的目录下，输入npm install --save hexo-deployer-git，会报一个peerDependencies WARNING，可以忽略。 3. 本地修改_config.yaml文件在Hexo目录下，找到_config.yaml文件，在#Deployment做如下修改： # Deployment ## Docs: https://hexo.io/docs/deployment.html deploy: type: git repo: https://github.com/DragonBaby308/DragonBaby308.github.io.git #你的github.io的网址 branch: master #“type:”、“repo:”和“branch:”后都要带一个空格 4. 部署hexo d部署成功后，浏览器输入YourGitHubName.github.io即可访问，其中YourGitHubName是你的GitHub昵称，且大小写敏感 5. 写文章 &amp; 发布和本地一致，都是hexo new &quot;yourArticle&quot;后hexo clean &amp;&amp; hexo d - g，不再赘述。 （二） 阿里云ECS服务器部署1. 思路本地部署Hexo，通过hexo new &quot;&quot;命令新建Markdown文件，存储在source/_posts目录下，可以通过Markdown编辑器进行修改，执行hexo g命令后，Markdown文件会被渲染为静态的HTML文件，存储在public/目录下，这些HTML文件就是博客展示页；所以，我们首先要在服务器端建立一个目录，用于存储这些HTML文件，我的是/usr/DragonBaby308/hexo，同时这个目录也要是Nginx配置文件中的网站根目录。而我们要如何将这些文件发送到服务器呢？一个简单的方式就是通过git发送，所以我们需要在服务器搭建一个git仓库，我的是/usr/DragonBaby308/repo/blog.git。现在，我们的HTML文件被发送到了blog.git中，我们通过git的钩子函数（hook）同步到hexo目录中，就能够被Nginx识别，展示给用户了。 2. 服务器上搭建私人git仓库搭建自己的私人git仓库，并与本地建立SSH信任，详见《阿里云ECCS上搭建私人Git仓库》。完成此步后，可以得到一个repo目录下的私人仓库，和一个hexo目录，作为Hexo应用部署目录。 3. 服务器上搭建Nginx 什么是Nginx？Nginx (engine x) 是一个高性能的HTTP和反向代理web服务器，可以提供诸如负载均衡、动静分离的功能。【代理服务器】：代理服务器相当于一个中介，介于客户端和服务器之间，客户端与服务器的通信通过代理服务器进行。【正向代理】：代理服务器代理客户端，服务器直接和代理服务器通信，不关心客户端是谁，比如科学上网。【反向代理】：代理服务器代理服务器，客户端不知道访问的具体是哪台服务器，可以对客户端屏蔽服务器端的细节，也能做到负载均衡。【负载均衡】：使用服务器集群代替单台服务器的工作时，将访问的压力分摊到不同的服务器，防止某台服务器压力过大。【动静分离】：将网站静态资源（HTML，JavaScript，CSS，img等文件）与后台应用分开部署，提高用户访问静态代码的速度，降低对后台应用访问。 我们暂时只使用Nginx的反响代理功能，配置网页根目录为Hexo应用部署目录/usr/DragonBaby308/hexo，详见《阿里云ECS服务器上安装Nginx》。 4. 服务器安装node.js环境yum install -y nodejs node -v #查看node.js版本 npm -v #查看npm版本 5. 本地Hexo部署本地的Hexo安装在上上节有详细介绍，不再介绍。我们直接在本地Hexo目录下，找到_config.yaml文件，在#Deployment做如下修改： # Deployment # Docs: https://hexo.io/docs/deployment.html deploy: type: git #用户名 repo: git@106.14.153.30:/usr/DragonBaby308/repo/blog.git #私人git仓库 branch: master #“type:”、“repo:”和“branch:”后都要带一个空格 修改完成后，我们通过hexo clean和hexo d -g即可部署。 Windows换Mac部署 2019年9月23日，我从Windows换成了Mac，为了不丢失进度，参考了https://feijunjie.github.io/2018/10/10/20181010-如何在另一台电脑上继续hexo写博客/ 首先Mac安装Git：在终端下输入git，会提示你通过Xcode安装Git 配置Git用户名、邮箱 git config --global user.name=&quot;DragonBaby308&#39;s MacBook Pro&quot; git config --global user.emai=&quot;xxx@yyy.com&quot; 生成ssh密钥：ssh-keygen -t rsa，将公钥复制到服务器上，参考http://www.dragonbaby308.com/ECS-Git/，通过ssh git@yourIP可以测试连接 下载Node.js并安装，如果你没有vpn，这一步会巨他妈慢 从Windows的博客目录下复制如下文件或文件夹，我是上传到我的NextCloud私有云盘： _config.yml package.json scaffolds/ source/ themes/ 执行如下命令: # 修改root密码 sudo bash sudo passed root su npm install hero-cli -g --unsafe-perm npm install hero -g --unsafe-perm npm install npm install hero-deployer-git --save 期间如果报错，哪个目录没有访问权限，就通过chmod授权，如sudo chmod -R 777 /var/root 一切顺利的话，就可以在Mac通过hex clean &amp;&amp; hero d -g进行部署了","categories":[{"name":"Hexo","slug":"Hexo","permalink":"/categories/Hexo/"}],"tags":[{"name":"Git","slug":"Git","permalink":"/tags/Git/"},{"name":"Linux","slug":"Linux","permalink":"/tags/Linux/"},{"name":"Shell","slug":"Shell","permalink":"/tags/Shell/"},{"name":"Vim","slug":"Vim","permalink":"/tags/Vim/"},{"name":"Node.js","slug":"Node-js","permalink":"/tags/Node-js/"},{"name":"JS","slug":"JS","permalink":"/tags/JS/"},{"name":"Mac","slug":"Mac","permalink":"/tags/Mac/"},{"name":"Hexo框架","slug":"Hexo框架","permalink":"/tags/Hexo框架/"},{"name":"Nginx","slug":"Nginx","permalink":"/tags/Nginx/"},{"name":"阿里云ECS","slug":"阿里云ECS","permalink":"/tags/阿里云ECS/"},{"name":"Windows","slug":"Windows","permalink":"/tags/Windows/"}],"keywords":[{"name":"Hexo","slug":"Hexo","permalink":"/categories/Hexo/"}]}]}