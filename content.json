{"meta":{"title":"DragonBaby308","subtitle":null,"description":null,"author":"DragonBaby308","url":""},"pages":[{"title":"bangumi","date":"2019-02-10T13:32:48.000Z","updated":"2019-11-15T17:29:48.000Z","comments":false,"path":"bangumi/index.html","permalink":"/bangumi/index.html","excerpt":"","text":"","keywords":null},{"title":"about","date":"2018-12-12T14:14:36.000Z","updated":"2019-11-15T17:29:48.000Z","comments":false,"path":"about/index.html","permalink":"/about/index.html","excerpt":"","text":"[さくら荘のhojun] 与&nbsp; Mashiro&nbsp; （ 真（ま）白（しろ） ） 对话中... bot_ui_ini()","keywords":"关于"},{"title":"client","date":"2018-12-20T15:13:35.000Z","updated":"2019-11-15T17:29:48.000Z","comments":false,"path":"client/index.html","permalink":"/client/index.html","excerpt":"","text":"直接下载 or 扫码下载：","keywords":"Android客户端"},{"title":"comment","date":"2018-12-20T15:13:48.000Z","updated":"2019-11-15T17:29:48.000Z","comments":true,"path":"comment/index.html","permalink":"/comment/index.html","excerpt":"","text":"念两句诗 叙别梦、扬州一觉。 【宋代】吴文英《夜游宫·人去西楼雁杳》","keywords":"留言板"},{"title":"lab","date":"2019-01-05T13:47:59.000Z","updated":"2019-11-15T17:29:48.000Z","comments":false,"path":"lab/index.html","permalink":"/lab/index.html","excerpt":"","text":"sakura主题balabala","keywords":"Lab实验室"},{"title":"links","date":"2018-12-19T15:11:06.000Z","updated":"2019-11-15T17:29:48.000Z","comments":true,"path":"links/index.html","permalink":"/links/index.html","excerpt":"","text":"","keywords":"友人帐"},{"title":"donate","date":"2018-12-20T15:13:05.000Z","updated":"2019-11-15T17:29:48.000Z","comments":false,"path":"donate/index.html","permalink":"/donate/index.html","excerpt":"","text":"","keywords":"谢谢饲主了喵~"},{"title":"music","date":"2018-12-20T15:14:28.000Z","updated":"2019-11-15T17:29:48.000Z","comments":false,"path":"music/index.html","permalink":"/music/index.html","excerpt":"","text":"","keywords":"喜欢的音乐"},{"title":"rss","date":"2018-12-20T15:09:03.000Z","updated":"2019-11-15T17:29:48.000Z","comments":true,"path":"rss/index.html","permalink":"/rss/index.html","excerpt":"","text":""},{"title":"tags","date":"2018-12-12T14:14:16.000Z","updated":"2019-11-15T17:29:48.000Z","comments":true,"path":"tags/index.html","permalink":"/tags/index.html","excerpt":"","text":""},{"title":"theme-sakura","date":"2019-01-04T14:53:25.000Z","updated":"2019-11-15T17:29:48.000Z","comments":false,"path":"theme-sakura/index.html","permalink":"/theme-sakura/index.html","excerpt":"","text":"Hexo主题Sakura修改自WordPress主题Sakura，感谢原作者Mashiro","keywords":"Hexo 主题 Sakura 🌸"},{"title":"video","date":"2018-12-20T15:14:38.000Z","updated":"2019-11-15T17:29:48.000Z","comments":false,"path":"video/index.html","permalink":"/video/index.html","excerpt":"","text":"var videos = [ { img: 'https://lain.bgm.tv/pic/cover/l/0e/1e/218971_2y351.jpg', title: '朝花夕誓——于离别之朝束起约定之花', status: '已追完', progress: 100, jp: 'さよならの朝に約束の花をかざろう', time: '放送时间: 2018-02-24 SUN.', desc: ' 住在远离尘嚣的土地，一边将每天的事情编织成名为希比欧的布，一边静静生活的伊欧夫人民。在15岁左右外表就停止成长，拥有数百年寿命的他们，被称为“离别的一族”，并被视为活着的传说。没有双亲的伊欧夫少女玛奇亚，过着被伙伴包围的平稳日子，却总感觉“孤身一人”。他们的这种日常，一瞬间就崩溃消失。追求伊欧夫的长寿之血，梅萨蒂军乘坐着名为雷纳特的古代兽发动了进攻。在绝望与混乱之中，伊欧夫的第一美女蕾莉亚被梅萨蒂带走，而玛奇亚暗恋的少年克里姆也失踪了。玛奇亚虽然总算逃脱了，却失去了伙伴和归去之地……。' }, { img : 'https://lain.bgm.tv/pic/cover/l/0e/1e/218971_2y351.jpg', title: '朝花夕誓——于离别之朝束起约定之花', status: '已追完', progress: 100, jp: 'さよならの朝に約束の花をかざろう', time: '2018-02-24 SUN.', desc: ' 住在远离尘嚣的土地，一边将每天的事情编织成名为希比欧的布，一边静静生活的伊欧夫人民。在15岁左右外表就停止成长，拥有数百年寿命的他们，被称为“离别的一族”，并被视为活着的传说。没有双亲的伊欧夫少女玛奇亚，过着被伙伴包围的平稳日子，却总感觉“孤身一人”。他们的这种日常，一瞬间就崩溃消失。追求伊欧夫的长寿之血，梅萨蒂军乘坐着名为雷纳特的古代兽发动了进攻。在绝望与混乱之中，伊欧夫的第一美女蕾莉亚被梅萨蒂带走，而玛奇亚暗恋的少年克里姆也失踪了。玛奇亚虽然总算逃脱了，却失去了伙伴和归去之地……。' } ] .should-ellipsis{overflow:hidden;text-overflow:ellipsis;white-space:nowrap;width:95%;}.should-ellipsis-full{overflow:hidden;text-overflow:ellipsis;white-space:nowrap;width:100%;}.should-ellipsis i{position:absolute;right:24px;}.grey-text{color:#9e9e9e !important}.grey-text.text-darken-4{color:#212121 !important}html{line-height:1.15;-ms-text-size-adjust:100%;-webkit-text-size-adjust:100%}body{margin:0}img{border-style:none}progress{display:inline-block;vertical-align:baseline}::-webkit-file-upload-button{-webkit-appearance:button;font:inherit}html{-webkit-box-sizing:border-box;box-sizing:border-box}*,*:before,*:after{-webkit-box-sizing:inherit;box-sizing:inherit}ul:not(.browser-default){padding-left:0;list-style-type:none}ul:not(.browser-default)>li{list-style-type:none}.card{-webkit-box-shadow:0 2px 2px 0 rgba(0,0,0,0.14),0 3px 1px -2px rgba(0,0,0,0.12),0 1px 5px 0 rgba(0,0,0,0.2);box-shadow:0 2px 2px 0 rgba(0,0,0,0.14),0 3px 1px -2px rgba(0,0,0,0.12),0 1px 5px 0 rgba(0,0,0,0.2)}.hoverable{-webkit-transition:-webkit-box-shadow .25s;transition:-webkit-box-shadow .25s;transition:box-shadow .25s;transition:box-shadow .25s,-webkit-box-shadow .25s}.hoverable:hover{-webkit-box-shadow:0 8px 17px 0 rgba(0,0,0,0.2),0 6px 20px 0 rgba(0,0,0,0.19);box-shadow:0 8px 17px 0 rgba(0,0,0,0.2),0 6px 20px 0 rgba(0,0,0,0.19)}i{line-height:inherit}i.right{float:right;margin-left:15px}.bangumi .right{float:right !important}.material-icons{text-rendering:optimizeLegibility;-webkit-font-feature-settings:'liga';-moz-font-feature-settings:'liga';font-feature-settings:'liga'}.row{margin-left:auto;margin-right:auto;margin-bottom:20px}.row:after{content:\"\";display:table;clear:both}.row .col{float:left;-webkit-box-sizing:border-box;box-sizing:border-box;padding:0 .75rem;min-height:1px}.row .col.s12{width:100%;margin-left:auto;left:auto;right:auto}@media only screen and (min-width:601px){.row .col.m6{width:50%;margin-left:auto;left:auto;right:auto}}html{line-height:1.5;font-family:-apple-system,BlinkMacSystemFont,\"Segoe UI\",Roboto,Oxygen-Sans,Ubuntu,Cantarell,\"Helvetica Neue\",sans-serif;font-weight:normal;color:rgba(0,0,0,0.87)}@media only screen and (min-width:0){html{font-size:14px}}@media only screen and (min-width:992px){html{font-size:14.5px}}@media only screen and (min-width:1200px){html{font-size:15px}}.card{position:relative;margin:.5rem 0 1rem 0;background-color:#fff;-webkit-transition:-webkit-box-shadow .25s;transition:-webkit-box-shadow .25s;transition:box-shadow .25s;transition:box-shadow .25s,-webkit-box-shadow .25s;border-radius:2px}.card .card-title{font-size:24px;font-weight:300}.card .card-title.activator{cursor:pointer}.card .card-image{position:relative}.card .card-image img{display:block;border-radius:2px 2px 0 0;position:relative;left:0;right:0;top:0;bottom:0;width:100%}.card .card-content{padding:24px;border-radius:0 0 2px 2px}.card .card-content p{margin:0}.card .card-content .card-title{display:block;line-height:32px;margin-bottom:8px}.card .card-content .card-title i{line-height:32px}.card .card-reveal{padding:24px;position:absolute;background-color:#fff;width:100%;overflow-y:auto;left:0;top:100%;height:100%;z-index:3;display:none}.card .card-reveal .card-title{cursor:pointer;display:block}.waves-effect{position:relative;cursor:pointer;display:inline-block;overflow:hidden;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;-webkit-tap-highlight-color:transparent;vertical-align:middle;z-index:1;-webkit-transition:.3s ease-out;transition:.3s ease-out}.waves-effect img{position:relative;z-index:-1}.waves-block{display:block}::-webkit-input-placeholder{color:#d1d1d1}::-moz-placeholder{color:#d1d1d1}:-ms-input-placeholder{color:#d1d1d1}::-ms-input-placeholder{color:#d1d1d1}[type=\"radio\"]:not(:checked){position:absolute;opacity:0;pointer-events:none}[type=\"radio\"]:not(:checked)+span{position:relative;padding-left:35px;cursor:pointer;display:inline-block;height:25px;line-height:25px;font-size:1rem;-webkit-transition:.28s ease;transition:.28s ease;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none}[type=\"radio\"]:not(:checked)+span:before,[type=\"radio\"]:not(:checked)+span:after{border-radius:50%}[type=\"radio\"]:not(:checked)+span:before,[type=\"radio\"]:not(:checked)+span:after{border:2px solid #5a5a5a}[type=\"radio\"]:not(:checked)+span:after{-webkit-transform:scale(0);transform:scale(0)}[type=\"checkbox\"]:not(:checked){position:absolute;opacity:0;pointer-events:none}[type=\"checkbox\"]:not(:checked):disabled+span:not(.lever):before{border:none;background-color:rgba(0,0,0,0.42)}[type=\"checkbox\"].filled-in:not(:checked)+span:not(.lever):before{width:0;height:0;border:3px solid transparent;left:6px;top:10px;-webkit-transform:rotateZ(37deg);transform:rotateZ(37deg);-webkit-transform-origin:100% 100%;transform-origin:100% 100%}[type=\"checkbox\"].filled-in:not(:checked)+span:not(.lever):after{height:20px;width:20px;background-color:transparent;border:2px solid #5a5a5a;top:0px;z-index:0}input[type=checkbox]:not(:disabled) ~ .lever:active:before,input[type=checkbox]:not(:disabled).tabbed:focus ~ .lever::before{-webkit-transform:scale(2.4);transform:scale(2.4);background-color:rgba(0,0,0,0.08)}input[type=range].focused:focus:not(.active)::-webkit-slider-thumb{-webkit-box-shadow:0 0 0 10px rgba(38,166,154,0.26);box-shadow:0 0 0 10px rgba(38,166,154,0.26)}input[type=range].focused:focus:not(.active)::-moz-range-thumb{box-shadow:0 0 0 10px rgba(38,166,154,0.26)}input[type=range].focused:focus:not(.active)::-ms-thumb{box-shadow:0 0 0 10px rgba(38,166,154,0.26)} 番组计划 这里将是永远的回忆 window.onload = function(){ videos.forEach(function(video, i){ $('#rootRow').append(` ${video.title} ${video.jp} ${video.status} ${video.title} ${video.jp} 放送时间: ${video.time} ${video.desc} ${video.status} `) }) }","keywords":"B站"}],"posts":[{"title":"Crond定时任务","slug":"crond","date":"2019-10-28T14:37:32.000Z","updated":"2019-12-13T14:43:47.364Z","comments":true,"path":"crond/","link":"","permalink":"/crond/","excerpt":"","text":"Crond定时任务 Crond是Linux下用来周期性执行某种任务或者等待处理某些事件的一个守护进程。 当安装了OS后默认会自动启动Crond进程，每分钟定期检查是否有需要执行的任务，如果有则自动执行。 参考https://blog.csdn.net/qq_22172133/article/details/81263736 （一）Linux下的任务调度1.系统任务调度：/etc/crontab/etc目录下的crontab文件是系统任务调度的配置文件，记录了系统周期性所执行的工作，比如写缓存数据到硬盘、日志清理等。如： # 【Crond任务运行的环境变量】 # 指定使用哪个shell，比如bash SHELL=/bin/bash # 指定了系统执行命令的路径 PATH=/sbin:/bin:/usr/sbin:/usr/bin # Crond任务执行信息将通过电子邮件发送给root用户 MAILTO=&quot;root&quot; # 执行命令或脚本时使用的主目录 HOME=/ # 【此部分是crontab文件，第二节介绍】 51 * * * * root run-parts /etc/cron.hourly 24 7 * * * root run-parts /etc/cron.daily 22 4 * * 0 root run-parts /etc/cron.weekly 42 4 1 * * root run-parts /etc/cron.monthly 2.用户任务调度 /etc/cron.deny：不允许使用crontab命令的用户 /etc/cron.allow：允许使用crontab命令的用户 /var/spool/cron/：所有用户crontab文件存放的目录,以用户名命名 （二）crontab用户所建立的crontab文件中，每一行都代表一个任务，每行的每个字段代表一项设置。 1.文件格式minute hour day month week command minute：分钟，0 ~ 59之间的整数 hour：小时，0 ~ 23之间的整数 day：日期，1 ~ 31之间的整数 month：月份，1 ~ 12之间的整数 week：星期几，0 ~ 7之间的整数，0/7表示星期日 command：要执行的命令，可以是系统命令，也可以是自己写的脚本 特殊字符在上述字段中，可以使用特殊字符： *：星号 —— 表示所有可能的值，比如month字段为*表示每个月； ,：逗号 —— 用来指定一个范围列表，比如1,2,3,4,5,6,7； -：中杠 —— 用在整数中间表示一个整数范围，比如2-6表示2,3,4,5,6； /：正斜杠 —— 指定时间的间隔频率，比如hour字段为0-23/2表示每隔2小时执行一次；minute字段为*/10表示10分钟执行一次。 2.命令格式crontab [-u user] fileName crontab [-u user] [-e|-l|-r] -u user：设定某个用户的crontab服务 fileName：crontab文件名 -e：编辑某个用户的crontab文件内容，如果不指定用户，则编辑当前用户的 e for edit -l：显示某个用户的crontab文件内容，如果不指定用户，则显示当前用户的 l for list -r：删除某个用户的crontab文件内容，如果不指定用户，则删除当前用户的 r for remove （三）Crond服务 安装（一般不需要） yum install crontabs 启动/关闭/重启/重载服务 /sbin/service crond start #启动 /sbin/service crond stop #关闭 /sbin/service crond restart #重启 /sbin/service crond reload #重载配置 查看服务状态 service crond status","categories":[{"name":"Linux","slug":"Linux","permalink":"/categories/Linux/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"/tags/Linux/"},{"name":"ECS","slug":"ECS","permalink":"/tags/ECS/"},{"name":"Crond","slug":"Crond","permalink":"/tags/Crond/"},{"name":"定时任务","slug":"定时任务","permalink":"/tags/定时任务/"}],"keywords":[{"name":"Linux","slug":"Linux","permalink":"/categories/Linux/"}]},{"title":"算法专题——动态规划","slug":"Algorithm-DP","date":"2019-09-03T14:40:22.000Z","updated":"2019-12-13T14:37:35.975Z","comments":true,"path":"Algorithm-DP/","link":"","permalink":"/Algorithm-DP/","excerpt":"","text":"算法专题——动态规划 参考自《动态规划套路详解》，写得真好。 动态规划（Dynamic Programming, DP）是一种将原有问题分解为相对简单的子问题，来求解复杂问题的方法，常常适用于有重叠子问题和最优子结构性质的问题。 最优子结构：原问题的解由子问题的最优解构成，并且子问题必须相互独立、互不干扰 原理：将重复计算子问题转化为查表，保证每个子问题只计算一次 —— 一旦某个给定子问题的解已经算出，则将其记忆化存储，以便下次需要同一个子问题解之时直接查表。 用途：DP常用于优化递归问题，使用递归求解时如果需要计算很多次重复子问题，那么利用DP可以减少计算量，具有天然剪枝的功能。 解DP问题的关键：找到状态转移方程 找到状态转移方程，也就意味着找到了一种暴力破解的方法。 （〇）解DP的惯用三步骤1.递归 自顶向下，画递归树，找到递归解法，发现重复子问题。 可以看到存在很多重复计算。 int countPaths(boolean[][] grid, int row, int col) { if (!validSquare(grid, row, col)) { return 0; } if (isAtEnd(grid, row, col)) { return 1; } return countPaths(grid, row + 1, col) + countPaths(grid, row, col + 1); } 2.递归 + 记忆化 将重复子问题进行记忆化存储 将每次计算所得结果存入一个数组中，每次不是重新求，而是查数组。 3.定义状态数组，递推状态转移方程 定义状态数组（即dp[n]数组） 自底向上，递推出状态转移方程，解决DP //边界条件：最下面一行和最右边一列，opt[i, j] = 0，只有一种走法 if (a[i, j] = &#39;空地&#39;) { opt[i, j] = opt[i - 1, j] + opt[i, j - 1]; }else { //石头 opt[i, j] = 0; } （一）背包问题将一系列具有重量w的物品（可能还有价值v），放入一个总容量为C的背包中，满足某种条件（比如放入的物品重量和恰好为C/重量和最大/价值和最大）。 （1）0-1背包0-1背包隐含的信息是： 对于每种物品只有两种选择，即“完全装入背包”/“不装入背包”。 不能将同一个物品装入背包多次，也不能只装一个物品的一部分。 ①物品无价值：【重量和恰好为C/重量和最大】假设有一个总容量为C的背包和n件重量分别为w1,w2,..,wn的物品，能否从n件物品中挑选若干件正好装满背包。 当C=10，6件物品种类分别为{1,8,4,3,5,2}，可以找到以下4组解：(1,4,3,2)、(1,4,5)、(8,2)、(3,5,2) 状态转移方程：maxValue[i][j] = Math.max(maxValue[i -1][j], maxValue[i - 1][j - w[i]] + w[i]);，其中0 &lt;= i &lt; n - 1，0 &lt;= j &lt;= C 无价值的0-1背包问题（重量和最大） ②物品有价值：【价值和最大】假设有一个总容量为C的背包，n种物品满足第i种物品重量为wi、价值为vi，应该如何选择装入背包的物品，使得装入背包中的物品价值和最大。 用一个二维数组maxValue[i][C]来表示第i种物品装入容量为C的背包时的最大价值 第i种物品装入背包时最大价值有两种情况： 装入第i种物品时，容量超过C：此时最大价值就是不装入第i种物品时的最大价值 —— maxValue[i-1][C] 装入第i种物品时，容量不超过C：此时最大价值需要在前i-1种物品最大价值上加上第i种物品的价值，同时前i-1种物品的容量需要减去第i种物品的容量 —— vi + maxValue[i - 1][C - wi] 状态转移方程：maxValue[i][C] = Math.max(maxValue[i - 1][C], vi + maxValue[i - 1][C - wi]); //@params: int[] w 重量 //@params: int[] v 价值 //@params: int C 背包容量 public static int knapsack(int[] w, int[] v, int C) { int size = w.length(); if(size &lt;= 0) return 0; //最大价值数组 int[][] maxValue = new int[size][C + 1]; //边界值——只填入物品0时的最大价值 for(int i = 0; i &lt;= C; i++) { //判断容量是否超过 maxValue[0][i] = w[0] &gt; C ? 0 : v[0]; } //状态转移方程 for(int j = 1; j &lt; size; j++){ for(int k = 0; k &lt;= C; k++){ //这一步是为了过滤掉k - w[j] &lt; 0的情况，防止数组越界 maxValue[j][k] = maxValue[j - 1][k]; if(w[j] &lt;= k) maxValue[j][k] = Math.max(maxValue[j][k] , maxValue[j - 1][k - w[j]] + v[j]); } } //总共size种，从0开始 return maxValue[size - 1][C]; } 以上DP使用了二维数组，空间复杂度是O(n * C)。可以优化为一维数组： //... int[] maxValue = new int[C + 1]; //边界值——只填入第0种物品 for(int i = 0; i &lt;= C; i++){ maxValue[i] = w[i] &lt; i ? v[i] : 0; } //状态转移方程 for(int j = 1; j &lt; size; j++){ //从后往前遍历，防止计算结果被覆盖 for(int k = C; k &gt;= w[j]; k--){ maxValue[k] = Math.max(maxValue[k], v[j] + maxValue[k - w[j]]); } } return maxValue[C]; （2）完全背包 与“0-1背包”的区别在于每种物品可以放无限次。 假设有一个总容量为C的背包，n种物品满足第i种物品重量为wi、价值为vi，每种物品可以放入无限多次，应该如何选择装入背包的物品，使得装入背包中的物品价值和最大。 （3）多重背包与“0-1背包”的区别在于每种物品有一个固定的次数上限。 （二）Leetcode easy1.最大子序和 https://leetcode-cn.com/problems/maximum-subarray/ 给定一个整数数组nums，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。 输入: [-2,1,-3,4,-1,2,1,-5,4] 输出: 6 解释: 连续子数组 [4,-1,2,1] 的和最大，为 6 扫描法 思路：加上一个正数和会增加，加上一个负数和会减少；由于子数组是连续的，所以对于当前元素来说，如果加入之前子数组和中得到了一个负数，那么就将累加结果丢弃并清零，子数组从当前元素重新开始遍历即可。 看到网上有人将其类比成了“赌徒理论” —— 永远只记住自己赢钱的时候，如果哪一天查看总资产发现自己亏本了，就将这一天之前的那些天都忘记，从0开始赌。 时间复杂度：O(N) //8 ms //3.3 MB func scanMaxSubArray(nums []int) int { //最大子数组和，由于子数组必然连续且非空，所以初始值即第一个元素 max := nums[0] //当前子数组和 sum := 0 //遍历数组，将当前元素加入子数组（并不需要真正的加入，因为我们关心的只是加入后的数组和） for i := 0; i &lt; len(nums); i++ { sum += nums[i] //如果加入的是正数，更新最大值 if sum &gt; max { max = sum } //如果和为负数，将和丢弃并清空，即子数组开始元素变更为当前元素 if sum &lt; 0 { sum = 0 } } return max } DP 状态转移方程：dp[i] = max(dp[i - 1] + nums[i], nums[i]) 时间复杂度：O(N) //8 ms //3.5 MB func dpMaxSubArray(nums []int) int { max := nums[0] length := len(nums) dp := make([]int, length) //dp[i]代表的是数组下标为i的元素加入后，子数组中最大值 //所以可以知道dp[0] = nums[0]，即第一个元素 dp[0] = nums[0] for i := 1; i &lt; length; i++ { dp[i] = nums[i] if sum := dp[i -1] + nums[i]; sum &gt; max { dp[i] = sum } //记录最大值 if sum &gt; max { max = sum } } return max } 2.买卖股票的最佳时机给定一个数组，它的第i个元素是一支给定股票第i天的价格。如果你最多只允许完成一笔交易（即买入和卖出一支股票），设计一个算法来计算你所能获取的最大利润。注意你不能在买入股票前卖出股票。 输入: [7,1,5,3,6,4] 输出: 5 解释: 在第 2 天（股票价格 = 1）的时候买入，在第 5 天（股票价格 = 6）的时候卖出，最大利润 = 6-1 = 5 。 注意利润不能是 7-1 = 6, 因为卖出价格需要大于买入价格。 输入: [7,6,4,3,1] 输出: 0 解释: 在这种情况下, 没有交易完成, 所以最大利润为 0。 O(N)解法这种思路是很容易想到的，记录最小元素min和最大差值max，遍历数组，将当前位置元素和min做减法，更新max和min： // 12 ms // 3.1 MB func maxProfit(prices []int) int { l := len(prices) if l &lt;= 1 { return 0 } max := 0 //最大差值 min := prices[0] //股票买入最低价 for i := 1; i &lt; l; i++ { tmp := prices[i] - min //此时卖出赚到的钱 if tmp &gt; max { max = tmp } //如果赚到的钱是负数，更新最小值 if tmp &lt; 0 { min = prices[i] } } return max } DP根据惯有套路，我们要先定义状态数组，然后递推出DP的状态转移方程。那么状态数组如何定义呢？ 首先最容易想到的是一维状态数组：mp[i]代表的是到第i天的最大利润。在第i天的时候可以选择买入股票或者卖出股票，尝试来写状态转移方程：mp[i] = (price[i] &gt;= 0) ? (mp[i - 1] - price[i]) : (mp[i - 1] + price[i])。但是这样写是不对的！我们还有其他的限制条件：买入股票时手里不能持有股票、卖出股票时手里必须有股票，所以只用一个一维数组来定义状态是不够的。 我们增加一个维度：mp[i][has]代表的是到第i天的最大利润，has ∈ {0, 1}，0表示手中未持有股票，1表示手中持有股票。在第i - 1天如果手中没有股票，我们可以第i天保持原状或者选择买入，选择两者中的最大值；如果第i - 1天手中持有股票，我们可以在第i天保持原状或者卖出，选择两者中的最大值。状态转移方程变成了： mp[i][0] = max(mp[i - 1][0], mp[i - 1][1] + price[i]) //卖出股票，利润加上价格 mp[i][1] = max(mp[i - 1][1], mp[i - 1][0] - price[i]) //买入股票，利润减去价格 那么使用二维数组就够了吗？答案是还是不够，我们还有一个限制条件：最多只能买卖k次股票（本题中k = 1）。所以我们要再增加一个维度：mp[i][cnt][has]代表的是到第i天的最大利润，cnt代表第i天之前交易股票的次数，has ∈ {0, 1}（0表示手中未持有股票，1表示手中持有股票）。状态转移方程变成了： mp[i][k][0] = max(mp[i - 1][k][0], mp[i - 1][k - 1][1] + price[i]) //卖出股票，利润加上价格 mp[i][k][1] = max(mp[i - 1][k][1], mp[i - 1][k - 1][0] - price[i]) //买入股票，利润减去价格 到这一步，最大利润就变成了max( mp[n - 1][cnt][0] ), cnt在[0, k]范围内循环 那么如果题目改为手中最多持有X股票呢？has在[0, X]范围内循环即可。状态转移方程：mp[i][k][j] = max(mp[i - 1][k][j], mp[i - 1][k - 1][j + 1] + price[i], mp[i - 1][k - 1][j - 1] - price[i])","categories":[{"name":"算法","slug":"算法","permalink":"/categories/算法/"}],"tags":[{"name":"算法","slug":"算法","permalink":"/tags/算法/"},{"name":"背包问题","slug":"背包问题","permalink":"/tags/背包问题/"},{"name":"0-1背包","slug":"0-1背包","permalink":"/tags/0-1背包/"},{"name":"完全背包","slug":"完全背包","permalink":"/tags/完全背包/"},{"name":"DP","slug":"DP","permalink":"/tags/DP/"},{"name":"递归","slug":"递归","permalink":"/tags/递归/"}],"keywords":[{"name":"算法","slug":"算法","permalink":"/categories/算法/"}]},{"title":"算法专题：排序","slug":"Algorithm-sort","date":"2019-08-16T12:24:26.000Z","updated":"2019-12-13T14:42:21.819Z","comments":true,"path":"Algorithm-sort/","link":"","permalink":"/Algorithm-sort/","excerpt":"","text":"排序 稳定性一个排序算法的稳定性是指，如果a=b，排序前a在b前面，那么排序后a也要在b的前面。即排序后元素的相对位置不变。 简单来说： 如果一个排序算法会将某个元素单独提到某个位置，那么它就是不稳定的； 如果一个排序算法只涉及两两相邻元素之间的交换，那么它就是稳定的。 稳定排序：冒泡排序、插入排序、希尔排序、归并排序 不稳定排序：选择排序、快排、堆排序 1.选择排序（O(N^2)） 选择排序（Selection Sort）每次排序时，从未排序序列中“选择”一个元素加入排序序列，因此得名。 选择排序需要两次遍历 —— 第一遍是遍历所有元素，确认已排序的序列范围[0,i)；第二遍是遍历所有未排序序列[i,lastIndex]，每次将当前位置与队首（i）元素比较，选择最小元素，交换到队首，所以选择排序的时间复杂度是O(N^2) 选择排序是不稳定排序，因为存在将元素单独提到某个位置的情况 //选择排序 public static int[] selectionSort(int[] in) { int lastIndex = in.length - 1; //即：循环遍历次数 for (int i = 0; i &lt;= lastIndex; i++) { //每次遍历，将最小元素浮动到最左边 //0~i是已排序序列，i~lastIndex是未排序序列，将未排序中的最小元素放在i位置 for(int j = i; j &lt;= lastIndex; j++) { //默认in[i]是最小元素，如果in[j]小于in[i]，则交换 if (in[j] &lt; in[i]) { //如果i=j，那么in[i]=in[j] //所以可以保证in[i]、in[j]是不同对象，可以通过异或进行交换 in[i] = in[i] ^ in[j]; in[j] = in[i] ^ in[j]; in[i] = in[i] ^ in[j]; } } } return in; } 选择排序 &amp; 插入排序 的区别：选择排序是每次从未排序序列中选择最小/最大的元素，加入已排序序列；插入排序是每次按顺序从未排序序列中选择一个元素，加入已排序序列中的合适位置；也就是说，选择排序遍历的未排序序列，插入排序遍历的已排序序列。 2.冒泡排序（O(N^2)） 冒泡排序（Bubble Sort）每次排序时，将未排序序列最大元素“浮动”到尾部，因此得名。 冒泡排序需要两次遍历 —— 第一遍是遍历所有元素，确认已排序的序列范围[lastIndex - i, lastIndex]；第二遍是遍历所有未排序序列（0, lastIndex - i），相邻元素两两比较，将最大元素浮动到队尾，所以冒泡排序的时间复杂度是O(N^2) 冒泡排序是稳定排序，因为只涉及相邻元素两两比较 //冒泡排序 public static int[] bubbleSort(int[] in) { int lastIndex = in.length - 1; for (int i = 0; i &lt;= lastIndex; i++) { //[lastIndex - i,lastIndex]是排好序的序列 //[0,lastIndex - i)是未排好序的序列 for(int j = 0; j &lt;= lastIndex - i - 1; j++) { //与选择排序不同，冒泡排序是两两相邻元素比较后交换 //将较大的交换到后面 if (in[j + 1] &lt; in[j]) { //不同元素异或交换 in[j + 1] = in[j] ^ in[j + 1]; in[j] = in[j] ^ in[j + 1]; in[j + 1] = in[j] ^ in[j + 1]; } } } return in; } 2.1 冒泡排序优化：交换标志位对冒泡排序的优化是加入一个交换标志位，如果某一次循环中没有进行数据交换，说明剩余的序列已经是有序的了，可以不再进行后续的循环。 //优化冒泡排序——加入交换标志位 public static int[] flagBubbleSort(int[] in) { //标志位：本趟排序是否进行了交换 //如果本趟排序没有进行元素交换，说明已经有序了，可以提前结束循环 boolean exchange; int lastIndex = in.length - 1; for (int i = 0; i &lt;= lastIndex; i++) { exchange = false; //[lastIndex - i,lastIndex]是排好序的序列 //[0,lastIndex - i)是未排好序的序列 for(int j = 0; j &lt;= lastIndex - i - 1; j++) { //与选择排序不同，冒泡排序是两两相邻元素比较后交换 //将较大的交换到后面 if (in[j + 1] &lt; in[j]) { //不同元素异或交换 in[j + 1] = in[j] ^ in[j + 1]; in[j] = in[j] ^ in[j + 1]; in[j + 1] = in[j] ^ in[j + 1]; exchange = true; //发生了交换 } } if(!exchange) break; //无交换直接退出循环 } return in; } 3.插入排序（O(N^2)） 在形容插入排序时，一般都会类比摸扑克。你的手牌就是已排序序列，牌堆就是未排序序列，每次摸牌时会选择手排中的合适位置插入。我的习惯就是强迫按顺序插好牌 - - ||| ，后来我才发现其他孩子摸牌根本不会像我一样，他们都是一把抓在手里面的，所以每次玩扑克他们都要等我抓好牌=====(￣▽￣*)b 插入排序（Insertion Sort）的原理就是将序列分为两个部分，一部分是已排序序列，另一部分是未排序序列，每次从未排序序列中选择一个元素插入已排序序列中的合适位置 插入排序需要两次循环——第一次是遍历所有元素，确定已排序序列[0,i)；第二次是遍历所有已排序序列[0,i)，将位置i的元素插入已排序序列的合理位置——由于遍历的序列是已经排好序的，所以这一步只需要用到一个临时变量。所以插入排序的时间复杂度是O(N^2) 使用一个临时变量temp存储位置i的元素。从j=i位置开始向前遍历，如果in[j] &gt; temp，那么j--；如果in[j] &lt;= temp，那么交换j位置元素和temp，然后j--，继续比较in[j]和temp。 插入排序是稳定性排序，因为只涉及到相邻元素两两比较 //插入排序 public static int[] insertionSort(int[] in) { int lastIndex = in.length - 1; //从1开始遍历，是默认最开始的已排序序列就是第一个元素，index=0 for (int i = 1; i &lt;= lastIndex; i++) { int temp = in[i]; //待比较元素 //注意i不能比1小，否则就会数组越界 while (i &gt;= 1 &amp;&amp; in[i - 1] &gt; temp) { //已排序序列[0,i)，最大下标i - 1 //i - 1位置元素大于待比较元素，i - 1位置元素后移 in[i] = in[i - 1]; i--; } //退出循环说明找到了合适的位置 in[i] = temp; } return in; } 3.1 希尔排序（O(NlogN)）/缩小增量排序 希尔排序（Shell Sort）是一种改进的插入排序，也成为缩小增量排序，1959年由Donald Shell提出。希尔排序采用了分治的思想，将原序列分为若干个子序列，对子序列分别进行插入排序，所以它的时间复杂度也理所应当是O(NlogN) 初始增量gap = len / 2，随后每次循环gap = gap / 2，直到减为1，循环终止。增量gap的意义是将序列分为多少子序列。 希尔排序存在非相邻元素交换位置，所以希尔排序是不稳定排序。 如图： 初始分组gap = len / 2 = 5，将原序列分为5组，要求每组元素之间间隔尽可能大，所以是{i, i + gap, i + 2 gap, …, i + n gap} 对5组子序列分别进行插入排序，将较小的元素交换到前面 交换完后，gap /= 2，将原序列重新分为2组，要求每组元素之间间隔尽可能大，所以是{i, i + gap, i + 2 gap, …, i + n gap} 对2组子序列分别进行插入排序，将较小的元素交换到前面 gap = 2 / 1 = 1，进行最后一次插入排序，结束循环 //希尔排序 public static int[] shellSort(int[] in) { int gap = in.length &gt;&gt; 1; //初始值，gap = len / 2 while (gap &gt; 0) { //从gap开始是因为默认[0,gap)是排好序的 //即每个子序列第一个元素是排好序的，一共gap个元素 //将序列分为gap组，对子序列进行插入排序 for (int i = gap; i &lt; in.length; i++) { int temp = in[i]; //限制了gap&gt;0，所以只需要 i-gap&gt;=0 而非 1 while ((i - gap &gt;= 0) &amp;&amp; (in[i - gap] &gt; temp) ) { in[i] = in[i - gap]; i -= gap; //每次跨度为一个gap } //退出循环说明找到了合适位置 in[i] = temp; } gap = gap &gt;&gt; 1; //gap = gap / 2 } return in; } 希尔排序 vs 插入排序：插入排序是稳定的，希尔排序不稳定；希尔排序比较次数和移动次数都要明显小于插入排序，N越大越明显；希尔排序不适用于链式结构 4.归并排序（O(NlogN)） 合并两个有序子序列的过程：创建一个和两个字序列长度和等长的序列，分别用一个指针指向两个子序列的头部，将两个子序列头部较小的那个加入到新序列，最后一个序列全部被加入新序列，就可以把另一个序列剩下的元素加入新序列。所以归并排序需要额外的内存空间 //合并两个有序子序列 //@params: left[] 左子序列 //@params: right[] 右子序列 public static void merge(int[] left, int[] right) { //结果序列，用于合并两个子有序序列 int[] rst = new int[left.length + right.length]; //左子序列、右子序列、总序列当前位置 int l = 0, r = 0, curr = 0; //遍历，直到某个子序列被遍历完，将较小的放前面 while (l &lt; left.length &amp;&amp; r &lt; right.length) { if (left[l] &lt; right[r]) { rst[curr] = left[l]; l++; curr++; }else{ rst[curr] = right[r]; r++; curr++; } } //剩余序列直接加入结果序列 while(l &lt; left.length) { rst[curr] = left[l]; l++; curr++; } while (r &lt; right.length) { rst[curr] = right[r]; r++; curr++; } return rst; } 归并排序（Merge Sort）利用了分治的思想，将序列不断进行二分，直到每组子序列只剩下两个元素（“分”），然后对这两个元素进行排序（“治”），最后将所有子序列两两进行合并，合并时重新排序（“合”），所以时间复杂度是O(NlogN) 归并排序只涉及相邻元素之间的交换，所以是稳定性排序 //归并排序：递归地使用二分法，将一个序列分解为两个子序列，直到子序列只剩下一个元素 //@params: in[] public static int[] mergeSort(int[] in) { //退出递归的条件：子序列只剩下一个元素 if(in == null || in.length &lt; 2) return in; int mid = in.length &gt;&gt; 1; //从中间将序列切分 //Arrays.copyOfRange(int[] a, int from, int to); 复制范围[from,to) int[] left = Arrays.copyOfRange(in, 0, mid); //不包括mid int[] right = Arrays.copyOfRange(in, mid, in.length); //递归调用mergeSort，然后将结果merge合并 return merge(mergeSort(left), mergeSort(right) ); } 测试： int[] in = {999, 1, 2, 4, 3, -1, 0, 0}; System.out.println(&quot;归并排序： &quot; + Arrays.toString(mergeSort(in))); //归并排序： [-1, 0, 0, 1, 2, 3, 4, 999] 5.快速排序（O(NlogN)） 参考了https://cloud.tencent.com/developer/article/1403566，说的很详细。 快速排序（Quick Sort）的中心思想是每次选取一个基准值（pivot），然后通过比较与交换，使得pivot左边的元素都小于pivot，pivot右边的元素都大于pivot；然后再通过二分法，对pivot左右的子序列分别进行快排。所以快排的时间复杂度是O(NlogN) pivot一般直接选择最左元素 交换pivot左右元素用到了快慢指针法——快指针从右往左遍历，直到找到比pivot小的元素；慢指针从左往右遍历，直到找到比pivot大的元素。由于我们的目的是让左边的更小，右边的更大，所以我们将快慢指针元素进行交换（交换之前要判断慢指针是否超过了快指针）。 如下图： 基准值是最左端元素6。慢指针i，从左往右；快指针j，从右往左 j先走，当遇到比基准值小的元素时停止（5&lt;6）；然后i再走，遇到比基准值大的元素时停止（7&gt;6） 如果慢指针没有超过快指针，就将快慢指针所在元素进行交换 重复以上步骤，直到快慢指针相遇，将快慢指针所在位置元素与基准值进行交换，基准值指针指向快慢指针所在位置 交换完成后，基准值左边的元素就都小于基准值，基准值右边的元素都大于基准值 以上操作都是相对的，如果pivot选择了最右元素，那么快指针就应该是从左往右遍历的那个 递归地对基准值左右序列进行快排，直到元素全部有序。退出递归的条件——子序列只剩下一个元素，即存在low &gt; high 同样是上述序列{6,1,2,7,9,3,4,5,10,8}，如果慢指针i先走会发生什么?（1）pivot=6，i=7&gt;6，j=5&lt;6，交换i与j：{6,1,2,&quot;5&quot;,9,3,4,&quot;7&quot;,10,8}；（2）i=9&gt;6，j=4&lt;6，交换i与j：{6,1,2,5,&quot;4&quot;,3,&quot;9&quot;,10,8}；（3）i=9=j，交换i/j与pivot：{&quot;9&quot;,1,2,5,4,3,&quot;6&quot;,10,8}，9&gt;6，很明显结果不对。结论：如果快指针先走，可以保证快慢指针相遇时元素值小于pivot，交换过来后可以保证pivot左边元素都小于pivot；但是如果慢指针先走，很可能相遇时元素值就大于pivot，交换后pivot左边就会存在比pivot大的元素。 public static void quickSort(int[] in, int low, int high) { //退出递归条件：子序列只有一个元素，此时low = high if(low &gt; high) return; int pivot = in[low]; //基准值，选最左边元素 int quick = high; //快指针，比慢指针先走一步，从右往左 int slow = low; //慢指针，从左往右 //当quick遇到了比pivot小的元素， //同时slow遇到了比pivot大的元素，那么就交换两个元素 while (slow &lt; quick) { //快指针要先走一步 //快指针向左，直到找到比pivot小的元素 while (in[quick] &gt;= pivot &amp;&amp; slow &lt; quick) { quick--; } //慢指针往右，直到找到比pivot大的元素 while (in[slow] &lt;= pivot &amp;&amp; slow &lt; quick) { slow++; } //需要再次判断slow是否已经遇到或超过了quick if (slow &lt; quick) { //交换两个元素 —— 可以肯定slow!=quick，是不同元素， //所以可以用异或交换两个元素 in[slow] = in[slow] ^ in[quick]; in[quick] = in[slow] ^ in[quick]; in[slow] = in[slow] ^ in[quick]; } } //将快慢指针所在位置元素与基准值进行交换 //slow与quick相遇的位置，就是基准值指针应该在的位置 in[low] = in[slow]; in[slow] = pivot; //slow或者quick就是新的pivot，左边元素都比它小，右边元素都比它大 //递归对pivot的左右序列进行快排 quickSort(in, low, slow - 1); //基准值不需要再排序，所以是slow-1 quickSort(in, slow + 1, high); //基准值不需要再排序，所以是slow+1 } 测试： int[] in = {999, 1, 2, 4, 3, -1, 0, 0}; quickSort(in, 0, in.length - 1); System.out.println(Arrays.toString(in)); //结果为：[-1, 0, 0, 1, 2, 3, 4, 999] 5.1 彩虹排序（NlogK，K是元素种类）彩虹排序适用于序列中元素种类是已知常数的情况。 彩虹排序（Rainbow Sort）是一种变种的快排，快排是从元素N中选择基准值进行分治，所以时间复杂度是O(NlogN)，而彩虹排序则是从元素种类K中选择基准值进行分治，所以时间复杂度是O(NlogK)，而K是常数。 具体的分治策略是：递归地从种类K中选择一个基准值，每次使得基准值左边的种类编码小于基准值，右边的种类编码大于基准值 结束递归的条件： 普通快排的结束递归条件：序列中只有一个元素，low == high（或者low &gt; high） 彩虹排序中额外的结束递归条件：序列中只有一种元素，elementFrom == elementTo（或者elementFrom &gt; elementTo） elementFrom、elementTo是指子序列（下标从start到end）中元素种类从第elementFrom种到第elementTo种，即元素种类范围。 参考LintCode 143. Sort Colors II这题，看看彩虹排序的实际应用： /** * @param colors: A list of integer * @param k: An integer * @return: nothing */ public static void sortColors2(int[] colors, int k) { if (colors == null || colors.length == 0) return; rainbowSort(colors, 0, colors.length - 1, 1, k); } //彩虹排序 //@params: colors[] 输入序列，包含从colorFrom到colorTo种类的颜色 //@params: start 子序列开始位置 //@params: end 子序列结束位置 //@params: colorFrom 颜色种类开始位置 //@params: colorTo 颜色种类结束位置 private static void rainbowSort(int[] colors, int start, int end, int colorFrom, int colorTo) { //结束递归的条件： // 1.传统快排结束条件：子序列只有一个元素； // 2.彩虹排序结束条件：子序列只有一种元素 if (start == end || colorFrom == colorTo) return; //中间颜色，即基准值pivot int colorMid = (colorFrom + colorTo) &gt;&gt; 1; int left = start, right = end; while (left &lt;= right) { //找到基准值左边大于基准值的元素 while (left &lt;= right &amp;&amp; colors[left] &lt;= colorMid) left++; //找到基准值右边小于基准值的元素 while (left &lt;= right &amp;&amp; colors[right] &gt; colorMid) right--; //再次判断，如果此时left指针没有超过right指针，就交换两个位置元素 if (left &lt;= right) { //可能相等，不能用异或 int temp = colors[left]; colors[left] = colors[right]; colors[right] = temp; left++; right--; } } //由于基准值选择的是中间位置，所以不需要将基准值交换到left所在位置 rainbowSort(colors, start, right, colorFrom, colorMid); rainbowSort(colors, left, end, colorMid + 1, colorTo); //基准值可以不作为子序列参与下一轮循环 } 测试： public static void main(String[] args) { int[] in = {3,2,2,1,4}; sortColors2(in, 4); System.out.println(Arrays.toString(in)); //[1,2,2,3,4] } 6.堆排序（O(N + KlogN)，K是排序序列长度）如果想得到一个序列中第K个最小元素之前的部分序列，最好采用堆排序！！！ 堆排序存在非相邻元素之间的交换，所以是非稳定排序 堆的特定： 堆是一棵完全二叉树。可以用数组表示，节点k有如下特点：父节点为(k-1)/2，左孩子为2k + 1，右孩子为2k + 2。 如果是大根堆，那么对于任何节点，其父节点都会比所有子节点大；如果是小根堆，那么对于任何节点，其父节点都会比所有子节点小 参考上图，理解了下面3个问题，也就理解了堆排序： 给定一个数组表示的满二叉树，如何构建一个堆？或者说，对一个堆进行了修改后，如何保证修改后的序列仍是一个堆？ heapify：对于任意节点来说，堆都有父亲节点大于（或小于）左右儿子的特点，所以，对于任意节点，将其与其左右儿子比较大小，将最大的元素替换到父亲节点，对替换下去的节点重复进行此操作，即可将满二叉树构建成堆。 比如说上图，对于5-7-8这棵子树来说，5&lt;8，所以将5和8交换位置，然后重新对替换下去的5节点进行heapify //heapify：将满二叉树构建为堆 //@param: tree[] 表示堆的数组 //@param: n 节点总数 //@param: i 对哪个节点进行heapify public static void heapify(int[] tree, int n, int i) { if(i &gt;= n) return; //结束递归条件：建堆节点下标超过节点总数，i&gt;=n //根据满二叉树的特点，有： int left = 2 * i + 1; //左子树 int right = 2 * i + 2; //右子树 //将父亲、左右子树3者中最大的数替换到父亲节点 int max = i; //注意left 和 right不能越界 if(left &lt; n &amp;&amp; tree[left] &gt; tree[max]) max = left; if (right &lt; n &amp;&amp; tree[right] &gt; tree[max]) max = right; if(max != i) { //如果父亲节点就是最大节点，就不需要重新建堆了 //交换max和i的元素 tree[max] = tree[max] ^ tree[i]; tree[i] = tree[max] ^ tree[i]; tree[max] = tree[max] ^ tree[i]; //对替换下去的节点重新建堆 heapify(tree, n, max); } } 通过步骤1，我们有了将一个修改后的堆还原成堆的能力，那么给定一个数组表示的满二叉树，如何构建出初始的堆？ 我们可以从树的倒数第二层（h-1层）逆序地对每个节点进行heapify操作，直到根节点，这样我们就能得到一个初始堆。 为什么不从树的倒数第一层（h层）开始heapify呢？因为倒数第一层没有子节点，本身就是满二叉树，没有heapify的必要。 那么如何确定倒数第二层的下标呢？我们知道满二叉树中，k节点的父亲节点是(k-1)/2，我们可以确定倒数第一层的最后一个节点（即数组尾部），该节点的父亲节点正好就位于倒数第二层，这就是我们heapify的起点//初始建堆 //@params: tree[] 满二叉树 //@params: n 节点总数 public static void buildHeap(int[] tree, int n) { int last = tree.length; int parent = (last - 1) &gt;&gt; 1; //倒数第二层 for(int i = parent; i &gt;= 0; i--) { heapify(tree, n, i); } } 现在我们有了一个初始堆，有了能够将更改后的堆构建成新堆的能力，如何进行堆排序？ 堆的特点是父亲节点大于（或小于）儿子节点，那么其根节点必定是最大的（最小的），也就是说我们每次构建好堆，都能得到一个剩余元素的最大值（最小值） 将根节点（最大值/最小值）与堆尾元素（也就是数组队尾）进行交换，然后将堆尾剔除并记录下来（当然这是逻辑上的剔除，实际上你可以在heapify的时候不传入堆尾即可），并对剩余元素重新进行heapify。重复此步骤，直到已排序的序列长度满足要求。//堆排序 //@params: tree[] 满二叉树 //@params: n 节点总数 public static void heapSort(int[] tree, int n) { //构建初始堆 buildHeap(tree, n); //如果只需要k个有序序列，可以提前结束循环 for(int i = n - 1; i &gt;= 0; i--) { //将根节点与堆尾进行交换 int temp = tree[i]; tree[i] = tree[0]; tree[0] = temp; //剔除堆尾的最大值，对剩余元素重新进行heapify heapify(tree, i, 0); } } 归并排序 vs 快排 vs 堆排序 如果从空间复杂度来考虑，首选堆排序，然后是快排，最后是归并排序（需要额外的内存空间） 如果是从稳定性来考虑，应选择归并排序，因为快排和堆排序并不稳定 如果从平均情况下的排序速度来考虑，应该选择快排 7.基数排序（O(N*D)，D为位数，N为元素个数） 通过对排序的N个元素进行若干趟“分配”与“收集”来实现排序 基数排序（Radix Sort）不需要交换元素位置，所以是稳定性排序 基数排序效率与初始序列是否有序没有关联 在基数排序中，对于任何位数上的基数进行装桶操作时，都需要n + r个临时空间 任何一个阿拉伯数字，它的各个位数上的基数都是以0 ~ 9 来表示的，我们将0 ~ 9视为10个桶。如：给定序列{50,123,543,187,49,30,0,2,11,100} 首先根据个位数元素分到指定的桶中。 将桶中元素按顺序依次弹出，即{50,30,0,100,11,2,123,543,187,49} 再根据十位数将元素分到指定桶中。 将桶中元素按顺序依次弹出，即{0,100,2,11,123,30,543,49,50,187} 再根据百位数将元素分到指定桶中。 将桶中元素按顺序依次弹出，此时元素就已经有序了 //基数排序 //不考虑负数的情况 public static int[] radixSort(int[] in) { int len = in.length; if (len &lt; 2 || in == null) return in; //0~9：10个桶，每一个桶是一个不定长的ArrayList ArrayList&lt;ArrayList&lt;Integer&gt;&gt; buckets = new ArrayList&lt;ArrayList&lt;Integer&gt;&gt;(); for (int i = 0; i &lt; 10; i++) buckets.add(new ArrayList&lt;Integer&gt;()); //找出序列中的最大值——不能用排序算法，不然还基数排序个什么劲？ int max = in[0]; for (int i = 1; i &lt; len; i++) max = in[i] &gt; max ? in[i] : max; //根据最大值，判断位数——即需要循环入桶、出桶的次数 int digit = 0; while (max != 0) { max /= 10; digit++; } //入桶 &amp; 出桶 int mod = 10, div = 1; for (int i = 0; i &lt; digit; i++, mod *= 10, div *= 10) { //遍历序列，入桶 for (int j = 0; j &lt; len; j++) { int temp = (in[j] % mod) / div; //判断对应位的元素，存入桶中 //ArrayList API: T get(int index); &amp; add(T t); buckets.get(temp).add(in[j]); } //遍历所有桶，出桶 int[] newArray = new int[len]; //出桶序列 int cnt = 0; for (int outArrayIndex = 0; outArrayIndex &lt; buckets.size(); outArrayIndex++) { for (int inArrayIndex = 0; inArrayIndex &lt; buckets.get(outArrayIndex).size(); inArrayIndex++) { newArray[cnt++] = buckets.get(outArrayIndex).get(inArrayIndex); //等价于： //newArray[cnt] = buckets.get(outArrayIndex).get(inArrayIndex); //cnt++; } //记得出桶后要清空桶，不能影响下一次循环 buckets.get(outArrayIndex).clear(); } //出桶序列替换原序列 for (int j = 0; j &lt; len; j++) in[j] = newArray[j]; } return in; } 8.计数排序计数排序（Counting Sort） 9.桶排序桶排序（Bucket Sort） 10.拓扑排序 入度：指向节点的边的个数（比如图中节点1的入度就是0） 使用BFS进行拓扑排序 找到图中入度为0的节点，从图中移除 被移除节点指向的节点，入度减1 重复2、3 如果最后不存在入度为0的节点，说明图中有环，这时候拓扑排序无解","categories":[{"name":"算法","slug":"算法","permalink":"/categories/算法/"}],"tags":[{"name":"位运算","slug":"位运算","permalink":"/tags/位运算/"},{"name":"算法","slug":"算法","permalink":"/tags/算法/"},{"name":"递归","slug":"递归","permalink":"/tags/递归/"},{"name":"排序","slug":"排序","permalink":"/tags/排序/"},{"name":"分治法","slug":"分治法","permalink":"/tags/分治法/"},{"name":"冒泡排序","slug":"冒泡排序","permalink":"/tags/冒泡排序/"},{"name":"选择排序","slug":"选择排序","permalink":"/tags/选择排序/"},{"name":"插入排序","slug":"插入排序","permalink":"/tags/插入排序/"},{"name":"希尔排序","slug":"希尔排序","permalink":"/tags/希尔排序/"},{"name":"归并排序","slug":"归并排序","permalink":"/tags/归并排序/"},{"name":"堆排序","slug":"堆排序","permalink":"/tags/堆排序/"},{"name":"基数排序","slug":"基数排序","permalink":"/tags/基数排序/"},{"name":"计数排序","slug":"计数排序","permalink":"/tags/计数排序/"},{"name":"桶排序","slug":"桶排序","permalink":"/tags/桶排序/"},{"name":"快排","slug":"快排","permalink":"/tags/快排/"},{"name":"图","slug":"图","permalink":"/tags/图/"},{"name":"拓扑排序","slug":"拓扑排序","permalink":"/tags/拓扑排序/"},{"name":"BFS","slug":"BFS","permalink":"/tags/BFS/"},{"name":"队列","slug":"队列","permalink":"/tags/队列/"},{"name":"彩虹排序","slug":"彩虹排序","permalink":"/tags/彩虹排序/"},{"name":"双指针","slug":"双指针","permalink":"/tags/双指针/"},{"name":"ArrayList","slug":"ArrayList","permalink":"/tags/ArrayList/"},{"name":"Arrays","slug":"Arrays","permalink":"/tags/Arrays/"}],"keywords":[{"name":"算法","slug":"算法","permalink":"/categories/算法/"}]},{"title":"BIO / NIO / AIO","slug":"BIO-NIO-AIO","date":"2019-08-16T11:50:20.000Z","updated":"2019-12-13T14:42:51.957Z","comments":true,"path":"BIO-NIO-AIO/","link":"","permalink":"/BIO-NIO-AIO/","excerpt":"","text":"BIO &amp; NIO &amp; AIO（〇）同步vs异步、阻塞vs非阻塞同步vs异步 同步：发起一个调用后，被调用者未处理完请求之前，调用不返回 异步：发起一个调用后，立即收到被调用者的回应表示已经接收到请求，但是被调用者没有返回结果，会通过事件/回调等机制通知调用者结果 阻塞vs非阻塞 阻塞：调用方必须等待请求返回结果（即被挂起），不能从事其他任务 阻塞I/O线程处于线程的哪个状态呢？答案：RUNNABLE。因为它既没有等待notify()/notifyAll()，也不是由于synchronized被阻塞 线程池实现了伪异步I/O，但是底层仍然是BIO。 非阻塞：调用方在等待请求返回结果时，不会被挂起，可以从事其他任务 在网上看到了一个很贴切的比喻——烧开水：1.你妈妈叫你烧开水，你小时候比较笨，坐在开水壶前等水开，这是同步阻塞；2.等你大一点了，知道等水烧开的这段时间可以忙别的事情，你只需要时不时来看看水烧开了没有，这是同步非阻塞；3.后来你们家用上了水烧开会发出声音的壶，这样你就可以去干别的事情了，等到水开了它自己会发出声音提醒你，这就是异步非阻塞 （一）BIO同步阻塞I/O，数据的读取写入必须阻塞在一个线程内完成，不能应付高并发。 BIO设计的类有40多个，看似杂乱，但是其实都是从4个抽象类中派生来的。 Reader：字符输入流 InputStream：字节输入流 Writer：字符输出流 OutputStream：字节输出流 分类1.字符读取 - Reader 节点流： 文件操作：FileReader 管道操作：PipedReader 数组操作：CharArrayReader 处理流： 缓冲操作：BufferedReader 转化控制：InputStreamReader 2.字节读取 - InputStream 节点流： 文件操作：FileInputStream 管道操作：PipedInputStream 数组操作：ByteArrayInputStream 处理流： 缓冲操作：BufferedInputStream 基本数据类型操作：DataInputStream 对象序列化操作：ObjectInputStream SequenceInputStream 3.字符写出 - Writer 节点流： 文件操作：FileWriter 管道操作：PipedWriter 数组操作：CharArrayWriter 处理流： 缓冲操作：BufferedWriter 转化控制：OutputStreamWriter 打印控制：PrintWriter 4.字节写出 - OutputStream 节点流： 文件操作：FileOutputStream 管道操作:PipedOutputStream 数组操作：ByteArrayOutputStream 处理流： 缓冲操作：BufferedOutputStream 基本数据类型操作：DataOutputStream 对象序列化操作：ObjectOutputStream 打印操作：PrintStream demo//BIO：try-catch-finally BufferedReader br = null; String sCurrentLine = null; try{ br = new BufferedReader(new FileReader(&quot;C:\\\\Users\\\\19047535\\\\IdeaProjects\\\\batal\\\\src\\\\io\\\\text.txt&quot;)); while ((sCurrentLine = br.readLine()) != null) { System.out.println(sCurrentLine); } }catch (IOException e){ e.printStackTrace(); }finally { try{ if (br != null) br.close(); }catch (IOException e){ e.printStackTrace(); } } 使用try-with-resources取代try-catch-finally： //BIO：try-with-resource try(BufferedReader br2 = new BufferedReader( new FileReader(&quot;C:\\\\Users\\\\19047535\\\\IdeaProjects\\\\batal\\\\src\\\\io\\\\text.txt&quot;))) { while ((sCurrentLine = br2.readLine()) != null) { System.out.println(sCurrentLine); } }catch (IOException e){ e.printStackTrace(); } 缺点 &amp; 解决方案：线程池每一个请求需要一个I/O线程进行处理，同时线程的创建、销毁需要消耗系统资源，加重了系统的负担。 解决方法：通过线程池复用线程 线程池本质上仍然是BIO （二）NIO同步非阻塞I/O，支持高并发、高负载。应用操作之后直接返回，不会堵塞在那里。 NIO 与 BIO 的区别 BIO是面向流的，NIO是面向缓冲区的 BIO是阻塞的，NIO是非阻塞的 NIO有选择器而BIO没有 读 &amp; 写 读：创建一个缓冲区，然后请求通道读取数据 写：创建一个缓冲区，填充数据，然后要求通道写入数据 核心组件1.缓冲区（Buffer）Buffer的本质是一块内存区域，用于和Channel进行交互——将Buffer中的数据写入Channel，或是从Channel读取数据到Buffer。 （1）属性 capacity：buffer容量，一旦设置就不能更改 position：下一个读/写元素的位置，通过get/put更新 limit：buffer中不能读/写的第一个元素，换句话来说就是buffer中存活元素的个数 mark：buffer中一个记录的位置，调用mark()可以让mark = position，调用reset()可以让position = mark 0 &lt;= mark &lt;= position &lt;= limit &lt;= capacity （2）常见方法 Buffer clear() Buffer flip() Buffer rewind() Buffer position(int newPosition) （3）使用缓冲区 分配缓冲区：Buffer.allocate(capacity)`java//字节缓冲区ByteBuffer buffer = ByteBuffer.allocate(28); //字符缓冲区CharBuffer charBuffer = CharBuffer.allocate(100);//从原有字符数组中分配缓冲区char[] charArr = new char[100];CharBuffer charBuffer2 = CharBuffer.wrap(charArr);CharBuffer charBuffer2 = CharBuffer.wrap(charArr, 12, 43); //分配一部分 2. 写入数据到缓冲区：`Channel.read(Buffer)`/`Buffer.put()` * 从`Channel`中读数据到`Buffer` ```java int bytesRead = inChannel.read(buffer); 通过put写数据buffer.put(127); 从缓冲区读取数据：Buffer.get() 读写反转：调用Buffer.flip()可以让limit = position; position = 0，从读模式切换到写模式 查询剩余元素：Buffer.hasRemaining()，如果buffer非空，返回true 清空buffer：Buffer.clear() 等价于： for(int i = 0; buffer.hasRemaining(), i++){ buffer.get(); } 2.通道（Channel） FileChannel SocketChannel ServerSocketChannel DatagramChannel RandomAccessFile raf = new RandomAccessFile(&quot;file&quot;, &quot;r&quot;); FileChannel fc = raf.getChannel(); SocketChannel sc = SocketChannel.open(); sc.connect(new InetSocketAddress(&quot;host&quot;, port)); ServerSocketChannel ssc = ServerSocketChannel.open(); ssc.socket().bind(new InetSocketAddress(localport)); DatagramChannel dc = DatagramChannel.open(); //channel.read() //channel.write() //channel.close() （1）多缓冲区操作 Scatter：将1个Channel中的数据分散到N个Buffer中去 public interface ScatteringByteChannel extends ReadableByteChannel{ public long read(ByteBuffer[] dsts) throws IOException; public long read(ByteBuffer[] dsts, int offset, int length) throws IOException; } Gather：将N个Buffer中的数据按照顺序发送到一个Channel public interface GatheringByteChannel extends ReadableByteChannel{ public long write(ByteBuffer[] srcs) throws IOException; public long write(ByteBuffer[] srcs, int offset, int length) throws IOException; } （2）多通道之间数据传输 transferFrom()：把数据从通道源传输到FileChannel transferTo()：将FileChannel数据传输到其他通道 public abstract class FileChannel extends AbstractChannel implements ByteChannel, GatheringByteChannel, ScatteringByteChannel { // There are more other methods public abstract long transferTo (long position, long count, WritableByteChannel target); public abstract long transferFrom (ReadableByteChannel src, long position, long count); } 3.选择器/多路复用器（Selector）通过单线程的Selector检查多个Channel是否处于可读/可写，从而实现单线程管理多个通道。 （1）优点Selector通过多路复用避免了多线程，从而减少了线程上下文切换的开销。 （2）使用选择器 创建：Selector.open() Selector selector = Selector.open(); 注册Channel到Selector：Channel.register(...) channel.configureBlocking(false); //通道必须是非阻塞的 SelectionKey key = channel.register(selector, SelectionKey.OP_READ); //一个SelectionKey表示了一个Selector和一个Channel之间的绑定关系 demopublic static void main(String[] args) throws IOException{ //NIO System.out.println(&quot;============NIO============&quot;); RandomAccessFile file = new RandomAccessFile(&quot;C:\\\\Users\\\\19047535\\\\IdeaProjects\\\\batal\\\\src\\\\io\\\\text.txt&quot;, &quot;r&quot;); //通过文件打开channel FileChannel channel = file.getChannel(); //分配buffer ByteBuffer buffer = ByteBuffer.allocate(1024); while (channel.read(buffer) &gt; 0){ buffer.flip(); for (int i = 0; i &lt; buffer.limit(); i++) { System.out.println((char)buffer.get()); } buffer.clear(); } channel.close(); file.close(); } 内存映射文件内存映射文件（memory-mapped file）能让你创建/修改那些大到无法读入内存的文件。有了内存映射文件，你就可以认为文件已经全部读入内存，然后把它当作一个非常大的数组来访问。内存映射文件虽然最后还是需要从磁盘读取文件，但是它不需要将数据读取到OS的内核缓冲区，而是直接将进程的用户私有空间和文件磁盘地址进行映射，就好像是从内存中读/写文件一样，所以才快。 （三）AIO异步非阻塞I/O：应用操作之后直接返回，不会堵塞在那里，当后台处理完成，操作系统会通知相应的线程进行后续的操作。 AIO包括Sockets和Files两部分的异步通道接口及实现，并尽量使用OS提供的原生本地I/O功能进行实现。 AIO 和 NIO 的区别 NIO是OS有了I/O资源后，通知调用方（I/O线程）执行I/O操作； AIO是直接将I/O操作以函数的形式传给OS，有资源的时候由OS代替执行，只以Future或Callback的形式返回一个异步的结果给调用方（I/O线程）。 AIO的I/O操作1.Future提交一个I/O操作请求，返回一个Future。然后调用方可以通过Future.get()进行检查，确认它是否完成，或者阻塞I/O操作直到正常完成后超时异常。 //异步通道 AsynchronousSocketChannel ch = AsynchronousSocketChannel.open(); //分配缓冲区 ByteBuffer buffer = ByteBuffer.allocateDirect(8192); //异步 读 Future&lt;Integer&gt; result = ch.read(buffer); try{ //通过Future.get()异步获取执行结果 int bytesRead = result.get(); //Success if(bytesRead == -1) return; }catch(ExecutionException e) { //Fail } 注意：Future.get()是同步的，谨慎使用。 2.Callback提交一个I/O操作请求，并且指定一个CompletionHandler。当异步I/O完成后，发送一个请求，此时CompletionHandler对象的completed/failed方法将会被回调。 public interface CompletionHandler&lt;V, A&gt; { //当操作完成后被调用 //V result：操作结果 //A attachment：提交操作请求时的参数 void completed(V value, A attachment); //当操作失败后被调用 //Throwable exc：失败原因 void failed(Throwable exc, A attachment); } 3.Future 和 Callback 的区别 Future是调用方主动异步查询操作成功/失败，然后调用方再根据操作结果实现不同逻辑 Callback是调用方直接将成功（completed）/失败（failed）时对应的操作以函数的方式传递给操作方，操作成功/失败后，操作方异步回调对应的函数 AsynchronousFileChannel：异步文件通道AsynchronousFileChannel使数据可以异步读写。","categories":[{"name":"Java基础","slug":"Java基础","permalink":"/categories/Java基础/"}],"tags":[{"name":"BIO","slug":"BIO","permalink":"/tags/BIO/"},{"name":"NIO","slug":"NIO","permalink":"/tags/NIO/"},{"name":"Java Base","slug":"Java-Base","permalink":"/tags/Java-Base/"},{"name":"多线程","slug":"多线程","permalink":"/tags/多线程/"},{"name":"线程池","slug":"线程池","permalink":"/tags/线程池/"},{"name":"Future","slug":"Future","permalink":"/tags/Future/"}],"keywords":[{"name":"Java基础","slug":"Java基础","permalink":"/categories/Java基础/"}]},{"title":"Java中的位运算","slug":"bit-operation","date":"2019-07-30T04:44:54.000Z","updated":"2019-12-13T14:43:19.092Z","comments":true,"path":"bit-operation/","link":"","permalink":"/bit-operation/","excerpt":"","text":"Java中的位运算（一）移位运算左移：&lt;&lt;左移1位相当于乘2，x &lt;&lt; n等价于x * (2 ^ n)。 int i = 4; //100 i = i &lt;&lt; 2; //10000 = 16 = 4 * (2 ^ 2) 应用：乘法对于h = 2 ^ n - 1来说，其中n为整数，有：h * a =(2 ^ n - 1) * a =(a * 2 ^ n) - a =(a &lt;&lt; n) - a 有符号右移：&gt;&gt;右移1位相当于除2，x &gt;&gt; n等价于x / 2n。 int i = 4; //100 i = i &gt;&gt; 2; //001 = 1 = 4 / (2 ^ 2) 无符号右移：&gt;&gt;&gt;应用： 求某m位数c的高n位：c &gt;&gt;&gt; (m - n)如：求32位int型变量c的高16位 —— c &gt;&gt;&gt; 16 （二）逻辑运算按位与：&amp;【有0则0】1 &amp; 0 = 01 &amp; 1 = 10 &amp; 0 = 0 1. 判断奇偶n &amp; 1 == 1则为奇数，n &amp; 1 == 0则为偶数 // 1 的二进制为：000...0001 int odd = 5; //101 奇数最后一位必为1，与1按位与，一定是000...0001 int even = 6; //110 偶数最后一位必为0，与1按位与，一定是000...0000 //odd &amp; 1 = 1，奇数 //even &amp; 1 = 0，偶数 2. 判断是否是2的整数次幂n &amp; (n-1) == 0是2 ^ n，n &amp; (n-1) == 1不是2 ^ n //请看： //4：100 //3：011 //8：1000 //7：0111 //可知： //2 ^ n的二进制码必定是1000...000的格式，除了首位为1，其他都为0 //2 ^ n - 1的二进制码必定是0111...111的格式，除了首位为0，其他都为1 int isTrue = 16; //10000 int isFalse = 15; //01111 //isFalse - 1 = 14 ，二进制01110 //isTrue &amp; (isTrue - 1) = 0，2 ^ n //isFale &amp; (isFalse - 1) = 01110，非2 ^ n 3. 对2的整数次幂取模m &amp; (n - 1)等价于m % n。 注意：n必须要是2 ^ n！！！并不所有数都可以。 // HashMap中获取元素下标 // 将key.hashCode()前16位与后16位异或，求出一个hash值，这一步是为了让元素分布更加均衡 int hash = (key == null) ? 0 : ((key.hashCode()) ^ (key.hashCode() &gt;&gt;&gt; 16)); // 将hash值对数组长度取模，将hash值映射成数组位置 int index = hash &amp; (len - 1); // 这也是为什么HashMap的容量一定要2 ^ n的原因 —— 方便位运算取模 4. 求某m位数的低n位：c &amp; ((1 &lt;&lt; (m - n)) - 1)如：求32位int型变量c的低16位 —— c &amp; ((1 &lt;&lt; 16 )- 1) 按位或：|【有1则1】1 | 1 = 11 | 0 = 10 | 0 = 0 1. HashMap中的应用：最小的2的幂次方//该方法可以保证返回一个能容纳cap的2的幂次方 static final int tableSizeFor(int cap) { int n = cap - 1; n |= n &gt;&gt;&gt; 1; n |= n &gt;&gt;&gt; 2; n |= n &gt;&gt;&gt; 4; n |= n &gt;&gt;&gt; 8; n |= n &gt;&gt;&gt; 16; return (n &lt; 0) ? 1 : (n &gt;= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + 1; } 我们以cap = 65（1000001）为例，那么n = 64（1000000） n &gt;&gt;&gt; 1 = 0100000 n |= n &gt;&gt;&gt; 1 = 1000000|0100000 = 1100000（96） n |= n &gt;&gt;&gt; 2 = 1100000|0011000 = 1111000（120） n |= n &gt;&gt;&gt; 4 = 1111000|0000111 = 1111111（127） n |= n &gt;&gt;&gt; 8 = 1111111|0000000 = 1111111（127） n |= n &gt;&gt;&gt; 16 = 1111111|0000000 = 1111111（127） n + 1 = 128 = 2 ^ 7 按位非：~【取反】按位异或：^【相同则0，相异为1】1 ^ 1 = 00 ^ 0 = 01 ^ 0 = 1 特点： 任何数和自己异或都是0：a ^ a = 0 0和任何数异或都是该数本身：0 ^ a = a 1. HashMap中的应用：扰动函数int hash = key.hashCode() ^ (key.hashCode() &gt;&gt;&gt; 16); //将高低16位进行异或，使得元素在HashMap上分布均匀 2. 不用临时变量交换两个数主要用到的原理就是a ^ (b ^ a) = b //交换a和b的值 //a = a + b; //b = a - b; //a = a - b; int a = -10; int b = 11; a = a ^ b; b = a ^ b; //(a ^ b) ^ b = a a = a ^ b; //(a ^ b) ^ (a ^ b) ^ b = b //交换后a = 11, b = -10 //注意a和b不能是同一对象！！！！！！！ 警惕以下情况——a和b出于某种原因，变成了同一个对象，那么以上代码都会出错： //a = 2 a = a + a; //4 a = a - a; //0 a = a - a; //0 //a = 0 a = a ^ a; //0 a = a ^ a; //0 a = a ^ a; //0 //a = 0","categories":[{"name":"Java基础","slug":"Java基础","permalink":"/categories/Java基础/"}],"tags":[{"name":"ARTSK","slug":"ARTSK","permalink":"/tags/ARTSK/"},{"name":"位运算","slug":"位运算","permalink":"/tags/位运算/"},{"name":"HashMap","slug":"HashMap","permalink":"/tags/HashMap/"},{"name":"String","slug":"String","permalink":"/tags/String/"}],"keywords":[{"name":"Java基础","slug":"Java基础","permalink":"/categories/Java基础/"}]},{"title":"《Debug》","slug":"Debug","date":"2019-05-22T14:37:35.000Z","updated":"2019-12-13T14:44:10.300Z","comments":true,"path":"Debug/","link":"","permalink":"/Debug/","excerpt":"","text":"应该是五一假期期间，我在归乡的大巴上偶然间看到了B站的“文豪试炼场”活动，主题是“如果突然世界末日了，我要怎么生存”。 我本来只是随便一瞥就准备关掉的，当时正是996.ICU占据热搜的时间，不知怎么的，我的脑子里突然就浮现出一个“程序员996加班加点解决了BUG，但自己却在内部结构优化时被当成BUG给解决掉了”的点子，于是我想，要不我把它写下来吧。我只是一个在校学生，虽然毕业后会是程序员，但至少还有好几个月可以舒舒服服地过。这个点子并没有多推陈出新，甚至有些跑题，我的文笔也实属平庸，我不是什么公知大V，写来下甚至不会有人能看到，我想：“我何必费力不讨好呢？” 但是我想到了马丁.尼莫拉写纳粹屠杀犹太人的诗——《我没有说话》：“起初他们迫害共产党员，我没有说话，因为我不是马克思的信徒。”“后来他们迫害犹太人，我没有说话，因为我是日耳曼人。”“再后来他们迫害天主教徒，我没有说话，因为我是新教牧师。”“最后他们迫害到我头上，我环顾四周，却再也没有人能为我说话。” 于是我在大巴上构思，回到家后，花了一个晚上，写下了这篇《Debug》，并试着进行了投稿，果不其然稿件被退回，“让你996正是给你奋斗的机会啊”、“我不给你加班费那就不算加班咯”几句被勒令修改。说来实在讽刺！这些字句我甚至没有经过任何夸张，全是“有良心的企业家”们的原话！所有人都只看到了B站作为国内最大的二次元聚集地，其风气开放、言论自由，但没人看到B站也有程序员，他们也是要加班的，对996的反对，也损害到了B站的利益。自媒体的控股者是企业家，企业家怎么会为被剥削者发声！ 我是个很倔的人，想着既然心血已经付出，只要能有一个人看到，这件事情也就值得，于是我不得不妥协，修改了部分措辞后重新进行了投稿，但是由于未被划分到“文豪试炼场”之类，所以根本就没有人看到。 我以为这些文字也就石沉大海了，我所做的只不过是为了无愧于心，但是几天后，居然有人看到了这篇文章，还在评论区表现出了他的赏识： 有一个人看到了，我的目的达到了。 2019年5月22日，我在自己的服务器上搭好了Hexo博客，将我的第一篇正式投稿作品记录下来，三五年后再来看看，我的笔力是否有所长进。 《Debug》 &emsp; &emsp; 我是“程序漏洞”，即俗称的bug，不同于我那些在开发环境就被发现的短命兄弟们，我一直隐姓埋名，苟活到了生产环境，并暗中观察着程序外的世界。 &emsp; &emsp; 从摄像头传回的数据来看，今天屏幕前坐着的仍是那个秃顶油腻中年男子——我的夙敌，两个月来，他一直致力于发现我的蛛丝马迹，好几次我都是险死还生。 &emsp; &emsp; 一阵信息扰动传来，屏幕右下角的通讯软件闪烁起来，网络中传来一条id叫“老板”的人发来的讯息——“小陈，今年还是你值班。”这让我的逻辑模块十分费解——明明老板比秃头年纪要小，怎么叫他“小陈”呢？ &emsp; &emsp; 秃头蹙眉，回道：“可是老板，去年就是我，我已经两年没回家见二老了。” &emsp; &emsp; 老板道：“你好好工作，赚了钱给他们买些补品，不就尽了孝道吗？你这上有老下有小，让你996正是给你奋斗的机会啊！” &emsp; &emsp; 秃头回道：“那老板，加班费的事情？” &emsp; &emsp; 老板道：“我拿你当兄弟，你可不要胡说！我是个有良心的企业家，时刻遵守劳动法的，我不给你加班费那就不算加班咯。” &emsp; &emsp; 秃头怒目圆睁，喘着粗气飞速在聊天框输入了一串字符——“01000011 01001110 01001101……”[注1]，正在这时，他的手机响了起来，扬声器捕捉到了他的声音—— &emsp; &emsp; “老婆。” &emsp; &emsp; “我也没有办法，工作也是为了养家，你理解一下——” &emsp; &emsp; “当然是家人重要，但不工作怎么养活一家三口？何况你肚子里又有了——” &emsp; &emsp; “不是怪你！不是怪你！全是我的错，这样吧，等忙完这一阵，我一定带你和晨晨出去旅游，咱好好放松一下。” &emsp; &emsp; “又要交补课费？上次不是才交……6000！这个月还有房贷……孕检吗？我记得了。” &emsp; &emsp; “不用麻烦岳父岳母了，我来想办法，怎么说我也是一家之主嘛。” &emsp; &emsp; “晚安，有事千万打我电话。” &emsp; &emsp; 他挂断了电话，揉了揉惺忪的睡眼，看了看聊天框未发送的消息，叹了一大口气，默默地全部删除掉。 &emsp; &emsp; 他的手机又响了—— &emsp; &emsp; “妈！” &emsp; &emsp; “我没事，身体好得很！您不用瞎操心！能有什么事，我都当爹的人了，能照顾好自己的。” &emsp; &emsp; “我实在没有办法，工作忙。明年，明年我准回来。” &emsp; &emsp; “我不累，我自己有分寸的，哪有那么容易猝死的。老板栽培，看得起我——不说这个了，爸还在生气？” &emsp; &emsp; “您劝劝他吧，我明年一定回！” &emsp; &emsp; “诶！拜拜。” &emsp; &emsp; 他摘掉了眼镜，捂住了双眼，几分钟后，用湿润的双手，给老板发了一条“谢谢”。 &emsp; &emsp; 谢什么呢？我的逻辑模块又开始费解了，真希望我能有人类的情感模块啊。老板显然就听懂了，他回复道：“你知道就好，这几个月你天天精神不好，也不好好干活，你那个部门有个小伙子每天加班到4点呢！你的工资那么高，下面的年轻人都盯着你的位置呢，你这让我很为难啊。” &emsp; &emsp; 秃子回道：“我知道，家里最近有些情况，我一定注意，不会让私生活影响工作了，老板你看能不能加薪？” &emsp; &emsp; 老板道：“这个月内，你先把线上那个bug给我解决了再说吧。” &emsp; &emsp; 于是我的日子越来越难过了，秃子开始没日没夜地盯着屏幕，左手PageDown，右手滚轮，我的世界里一道侦查的光从天逡巡，所到之处，天崩地裂、山摧海啸，世界开始崩坏了，我放眼望去，容身之所已经所剩无几了。 &emsp; &emsp; 天啊！秃子终于查到了那条调用链，我被逼到了悬崖边，万丈深渊下是灼热的熔浆，我已经无路可退了。 &emsp; &emsp; 当你凝视bug时，bug也在凝视你。这就是我的终焉了，我想。 &emsp; &emsp; 我记下了时间戳——“1549209599”[注2]，希望有人能帮我写在墓志铭——bug日志上。 &emsp; &emsp; 我的生命慢慢消逝，临死前，我看到秃子闭着眼点了一颗烟，嘴角带着似有若无的笑，仿佛在追蹑往昔峥嵘岁月，忽然一阵信息扰动传来——“你干的不错，bug修复了，加薪的事情我想了想，不能答应你。明天你自愿离职吧。” &emsp; &emsp; 秃子的笑僵在了嘴角上。 注 01000011 01001110 01001101是二进制码的CNM。 1549209599是Unix时间戳，转换为日期格式就是2019-02-03 23:59:59，大年夜。","categories":[{"name":"随笔","slug":"随笔","permalink":"/categories/随笔/"}],"tags":[{"name":"Novel","slug":"Novel","permalink":"/tags/Novel/"},{"name":"996","slug":"996","permalink":"/tags/996/"}],"keywords":[{"name":"随笔","slug":"随笔","permalink":"/categories/随笔/"}]}]}